/// <reference path="./global.d.ts" />

import type { DisplayObject } from '@pixi/display';
import { EventEmitter } from '@pixi/utils';
import type { IPointData } from '@pixi/math';
import type { IRenderableObject } from '@pixi/core';
import { Point } from '@pixi/math';

export declare type Cursor = 'auto' | 'default' | 'none' | 'context-menu' | 'help' | 'pointer' | 'progress' | 'wait' | 'cell' | 'crosshair' | 'text' | 'vertical-text' | 'alias' | 'copy' | 'move' | 'no-drop' | 'not-allowed' | 'e-resize' | 'n-resize' | 'ne-resize' | 'nw-resize' | 's-resize' | 'se-resize' | 'sw-resize' | 'w-resize' | 'ns-resize' | 'ew-resize' | 'nesw-resize' | 'col-resize' | 'nwse-resize' | 'row-resize' | 'all-scroll' | 'zoom-in' | 'zoom-out' | 'grab' | 'grabbing';

/**
 * Event boundaries are "barriers" where events coming from an upstream scene are modified before downstream propagation.
 *
 * ## Root event boundary
 *
 * The {@link PIXI.EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.
 * {@link PIXI.EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}
 * into {@link PIXI.FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch
 * for the upstream normalized event.
 *
 * ## Additional event boundaries
 *
 * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is
 * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the
 * container can be detached from the scene and glued using a custom event boundary.
 *
 * ```ts
 * import { Container } from '@pixi/display';
 * import { EventBoundary } from '@pixi/events';
 * import { SpatialHash } from 'pixi-spatial-hash';
 *
 * class HashedHitTestingEventBoundary
 * {
 *     private spatialHash: SpatialHash;
 *
 *     constructor(scene: Container, spatialHash: SpatialHash)
 *     {
 *         super(scene);
 *         this.spatialHash = spatialHash;
 *     }
 *
 *     hitTestRecursive(...)
 *     {
 *         // TODO: If target === this.rootTarget, then use spatial hash to get a
 *         // list of possible children that match the given (x,y) coordinates.
 *     }
 * }
 *
 * class VastScene extends DisplayObject
 * {
 *     protected eventBoundary: EventBoundary;
 *     protected scene: Container;
 *     protected spatialHash: SpatialHash;
 *
 *     constructor()
 *     {
 *         this.scene = new Container();
 *         this.spatialHash = new SpatialHash();
 *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);
 *
 *         // Populate this.scene with a ton of children, while updating this.spatialHash
 *     }
 * }
 * ```
 *
 * @memberof PIXI
 */
export declare class EventBoundary {
    /**
     * The root event-target residing below the event boundary.
     *
     * All events are dispatched trickling down and bubbling up to this `rootTarget`.
     */
    rootTarget: DisplayObject;
    /**
     * Emits events after they were dispatched into the scene graph.
     *
     * This can be used for global events listening, regardless of the scene graph being used. It should
     * not be used by interactive libraries for normal use.
     *
     * Special events that do not bubble all the way to the root target are not emitted from here,
     * e.g. pointerenter, pointerleave, click.
     */
    dispatch: EventEmitter;
    /**
     * The cursor preferred by the event targets underneath this boundary.
     */
    cursor: Cursor | string;
    /**
     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all DisplayObjects.
     *
     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of
     * the Pointer Event API's approach.
     */
    moveOnAll: boolean;
    /**
     * Maps event types to forwarding handles for them.
     *
     * {@link PIXI.EventBoundary EventBoundary} provides mapping for "pointerdown", "pointermove",
     * "pointerout", "pointerleave", "pointerover", "pointerup", and "pointerupoutside" by default.
     *
     * @see PIXI.EventBoundary#addEventMapping
     */
    protected mappingTable: Record<string, Array<{
        fn: (e: FederatedEvent) => void;
        priority: number;
    }>>;
    /**
     * State object for mapping methods.
     *
     * @see PIXI.EventBoundary#trackingData
     */
    protected mappingState: Record<string, any>;
    /**
     * The event pool maps event constructors to an free pool of instances of those specific events.
     *
     * @see PIXI.EventBoundary#allocateEvent
     * @see PIXI.EventBoundary#freeEvent
     */
    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]>;
    /**
     * @param rootTarget - The holder of the event boundary.
     */
    constructor(rootTarget?: DisplayObject);
    /**
     * Adds an event mapping for the event `type` handled by `fn`.
     *
     * Event mappings can be used to implement additional or custom events. They take an event
     * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events
     * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.
     *
     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
     * instead.
     *
     * @param type - The type of upstream event to map.
     * @param fn - The mapping method. The context of this function must be bound manually, if desired.
     */
    addEventMapping(type: string, fn: (e: FederatedEvent) => void): void;
    /** Dispatches the given event */
    dispatchEvent(e: FederatedEvent, type?: string): void;
    /** Maps the given upstream event through the event boundary and propagates it downstream. */
    mapEvent(e: FederatedEvent): void;
    /**
     * Finds the DisplayObject that is the target of a event at the given coordinates.
     *
     * The passed (x,y) coordinates are in the world space above this event boundary.
     */
    hitTest(x: number, y: number): DisplayObject;
    /**
     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
     * target {@code e.target}.
     *
     * @param e - The event to propagate.
     */
    propagate(e: FederatedEvent, type?: string): void;
    /**
     * Emits the event {@link e} to all display objects. The event is propagated in the bubbling phase always.
     *
     * This is used in the `pointermove` legacy mode.
     *
     * @param e - The emitted event.
     * @param type - The listeners to notify.
     */
    all(e: FederatedEvent, type?: string, target?: FederatedEventTarget): void;
    /**
     * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed
     * {@code target}. The last element in the path is {@code target}.
     *
     * @param target
     */
    propagationPath(target: FederatedEventTarget): FederatedEventTarget[];
    /**
     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
     *
     * @param currentTarget - The DisplayObject that is to be hit tested.
     * @param interactive - Flags whether `currentTarget` or one of its parents are interactive.
     * @param location - The location that is being tested for overlap.
     * @param testFn - Callback that determines whether the target passes hit testing. This callback
     *  can assume that `pruneFn` failed to prune the display object.
     * @param pruneFn - Callback that determiness whether the target and all of its children
     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
     *  of the scene graph.
     * @return An array holding the hit testing target and all its ancestors in order. The first element
     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
     */
    protected hitTestRecursive(currentTarget: DisplayObject, interactive: boolean, location: Point, testFn: (object: DisplayObject, pt: Point) => boolean, pruneFn?: (object: DisplayObject, pt: Point) => boolean): DisplayObject[];
    /**
     * Checks whether the display object or any of its children cannot pass the hit test at all.
     *
     * {@link EventBoundary}'s implementation uses the {@link PIXI.DisplayObject.hitArea hitArea}
     * and {@link PIXI.DisplayObject._mask} for pruning.
     *
     * @param displayObject
     * @param location
     */
    protected hitPruneFn(displayObject: DisplayObject, location: Point): boolean;
    /**
     * Checks whether the display object passes hit testing for the given location.
     *
     * @param displayObject
     * @param location
     * @return - Whether `displayObject` passes hit testing for `location`.
     */
    protected hitTestFn(displayObject: DisplayObject, location: Point): boolean;
    /**
     * Notify all the listeners to the event's `currentTarget`.
     *
     * @param e - The event passed to the target.
     */
    protected notifyTarget(e: FederatedEvent, type?: string): void;
    /**
     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
     *
     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
     *
     * @param from
     */
    protected mapPointerDown(from: FederatedEvent): void;
    /**
     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
     *
     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
     *
     * @param from - The upstream `pointermove` event.
     */
    protected mapPointerMove(from: FederatedEvent): void;
    /**
     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
     *
     * The tracking data for the specific pointer gets a new `overTarget`.
     *
     * @param from - The upstream `pointerover` event.
     */
    protected mapPointerOver(from: FederatedEvent): void;
    /**
     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
     *
     * The tracking data for the specific pointer is cleared of a `overTarget`.
     *
     * @param from - The upstream `pointerout` event.
     */
    protected mapPointerOut(from: FederatedEvent): void;
    /**
     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`, and `click`/`pointertap` events,
     * in that order.
     *
     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
     * specific pointer types.
     *
     * @param from - The upstream `pointerup` event.
     */
    protected mapPointerUp(from: FederatedEvent): void;
    /**
     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
     * `pointerdown` target to `rootTarget`.
     *
     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the {@code EventBoundary}'s
     * root because the `pointerup` event occurred outside of the boundary.)
     *
     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
     *
     * @param from - The upstream `pointerupoutside` event.
     */
    protected mapPointerUpOutside(from: FederatedEvent): void;
    /**
     * Maps the upstream `wheel` event to a downstream `wheel` event.
     *
     * @param from - The upstream `wheel` event.
     */
    protected mapWheel(from: FederatedEvent): void;
    /**
     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
     *
     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
     * or `pointerover` target was unmounted from the scene graph.
     *
     * @param propagationPath - The propagation path was valid in the past.
     * @return - The most specific event-target still mounted at the same location in the scene graph.
     */
    protected findMountedTarget(propagationPath: FederatedEventTarget[]): FederatedEventTarget;
    /**
     * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
     *
     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
     *
     * @param from - The {@code originalEvent} for the returned event.
     * @param [type=from.type] - The type of the returned event.
     * @param target - The target of the returned event.
     */
    protected createPointerEvent(from: FederatedPointerEvent, type?: string, target?: FederatedEventTarget): FederatedPointerEvent;
    /**
     * Creates a wheel event whose {@code originalEvent} is {@code from}.
     *
     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
     *
     * @param from - The upstream wheel event.
     */
    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent;
    /**
     * Clones the event {@code from}, with an optional {@code type} override.
     *
     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.
     *
     * @param from - The event to clone.
     * @param [type=from.type] - The type of the returned event.
     */
    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent;
    /**
     * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.
     *
     * The following properties are copied:
     * + deltaMode
     * + deltaX
     * + deltaY
     * + deltaZ
     *
     * @param from
     * @param to
     */
    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void;
    /**
     * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.
     *
     * The following properties are copied:
     * + pointerId
     * + width
     * + height
     * + isPrimary
     * + pointerType
     * + pressure
     * + tangentialPressure
     * + tiltX
     * + tiltY
     *
     * @param from
     * @param to
     */
    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void;
    /**
     * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.
     *
     * The following properties are copied:
     * + altKey
     * + button
     * + buttons
     * + clientX
     * + clientY
     * + metaKey
     * + movementX
     * + movementY
     * + pageX
     * + pageY
     * + x
     * + y
     * + screen
     * + global
     *
     * @param from
     * @param to
     */
    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void;
    /**
     * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.
     *
     * The following properties are copied:
     * + isTrusted
     * + srcElement
     * + timeStamp
     * + type
     *
     * @param from - The event to copy data from.
     * @param to - The event to copy data into.
     */
    protected copyData(from: FederatedEvent, to: FederatedEvent): void;
    /**
     * @param id - The pointer ID.
     * @return The tracking data stored for the given pointer. If no data exists, a blank
     *  state will be created.
     */
    protected trackingData(id: number): TrackingData;
    /**
     * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.
     *
     * This allocation is constructor-agnostic, as long as it only takes one argument - this event
     * boundary.
     *
     * @param constructor - The event's constructor.
     */
    protected allocateEvent<T extends FederatedEvent>(constructor: {
        new (boundary: EventBoundary): T;
    }): T;
    /**
     * Frees the event and puts it back into the event pool.
     *
     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
     *
     * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}
     * not be freed. This is because of the possibility that the same event is freed twice, which can cause
     * it to be allocated twice & result in overwriting.
     *
     * @param event - The event to be freed.
     * @throws Error if the event is managed by another event boundary.
     */
    protected freeEvent<T extends FederatedEvent>(event: T): void;
    /**
     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
     * is set on the event.
     *
     * @param e - The event to call each listener with.
     * @param type - The event key.
     */
    private notifyListeners;
}

/**
 * The system for handling UI events.
 *
 * @memberof PIXI
 */
export declare class EventSystem {
    /**
     * The {@link PIXI.EventBoundary} for the stage.
     *
     * The {@link PIXI.EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to
     * the last rendered object before any event processing is initiated. This means the main scene
     * needs to be rendered atleast once before UI events will start propagating.
     *
     * The root boundary should only be changed during initialization. Otherwise, any state held by the
     * event boundary may be lost (like hovered & pressed DisplayObjects).
     */
    readonly rootBoundary: EventBoundary;
    /**
     * Does the device support touch events
     * https://www.w3.org/TR/touch-events/
     */
    readonly supportsTouchEvents: boolean;
    /**
     * Does the device support pointer events
     * https://www.w3.org/Submission/pointer-events/
     */
    readonly supportsPointerEvents: boolean;
    /**
     * Should default browser actions automatically be prevented.
     * Does not apply to pointer events for backwards compatibility
     * preventDefault on pointer events stops mouse events from firing
     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.
     *
     * @default true
     */
    autoPreventDefault: boolean;
    /**
     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor
     * values, objects are handled as dictionaries of CSS values for {@code domElement},
     * and functions are called instead of changing the CSS.
     * Default CSS cursor values are provided for 'default' and 'pointer' modes.
     *
     * @member {Object.<string, string | ((mode: string) => void) | CSSStyleDeclaration>}
     */
    cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;
    /**
     * The DOM element to which the root event listeners are bound. This is automatically set to
     * the renderer's {@link PIXI.Renderer#view view}.
     */
    domElement: HTMLElement;
    /**
     * The resolution used to convert between the DOM client space into world space.
     */
    resolution: number;
    /**
     * The renderer managing this {@link EventSystem}.
     */
    renderer: Renderer;
    private currentCursor;
    private rootPointerEvent;
    private rootWheelEvent;
    private eventsAdded;
    /**
     * @param {PIXI.Renderer} renderer
     */
    constructor(renderer: Renderer);
    /**
     * Destroys all event listeners and detaches the renderer.
     */
    destroy(): void;
    /**
     * Sets the current cursor mode, handling any callbacks or CSS style changes.
     *
     * @param mode - cursor mode, a key from the cursorStyles dictionary
     */
    setCursor(mode: string): void;
    /**
     * Event handler for pointer down events on {@link PIXI.EventSystem#domElement this.domElement}.
     *
     * @param nativeEvent - The native mouse/pointer/touch event.
     */
    private onPointerDown;
    /**
     * Event handler for pointer move events on on {@link PIXI.EventSystem#domElement this.domElement}.
     *
     * @param nativeEvent - The native mouse/pointer/touch events.
     */
    private onPointerMove;
    /**
     * Event handler for pointer up events on {@link PIXI.EventSystem#domElement this.domElement}.
     *
     * @param nativeEvent - The native mouse/pointer/touch event.
     */
    private onPointerUp;
    /**
     * Event handler for pointer over & out events on {@link PIXI.EventSystem#domElement this.domElement}.
     *
     * @param nativeEvent - The native mouse/pointer/touch event.
     */
    private onPointerOverOut;
    /**
     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
     *
     * @param nativeEvent - The native wheel event.
     */
    protected onWheel(nativeEvent: WheelEvent): void;
    /**
     * Sets the {@link PIXI.EventSystem#domElement domElement} and binds event listeners.
     *
     * To deregister the current DOM element without setting a new one, pass {@code null}.
     *
     * @param element - The new DOM element.
     */
    setTargetElement(element: HTMLElement): void;
    /**
     * Register event listeners on {@link PIXI.Renderer#domElement this.domElement}.
     */
    private addEvents;
    /**
     * Unregister event listeners on {@link PIXI.EventSystem#domElement this.domElement}.
     */
    private removeEvents;
    /**
     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
     * resulting value is stored in the point. This takes into account the fact that the DOM
     * element could be scaled and positioned anywhere on the screen.
     *
     * @param  {PIXI.IPointData} point - the point that the result will be stored in
     * @param  {number} x - the x coord of the position to map
     * @param  {number} y - the y coord of the position to map
     */
    mapPositionToPoint(point: IPointData, x: number, y: number): void;
    /**
     * Ensures that the original event object contains all data that a regular pointer event would have
     *
     * @param event - The original event data from a touch or mouse event
     * @return An array containing a single normalized pointer event, in the case of a pointer
     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
     */
    private normalizeToPointerData;
    /**
     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
     *
     * The returned {@link PIXI.FederatedWheelEvent} is a shared instance. It will not persist across
     * multiple native wheel events.
     *
     * @param nativeEvent - The native wheel event that occurred on the canvas.
     * @return A federated wheel event.
     */
    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent;
    /**
     * Normalizes the {@code nativeEvent} into a federateed {@code FederatedPointerEvent}.
     *
     * @param event
     * @param nativeEvent
     */
    private bootstrapEvent;
    /**
     * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
     *
     * @param event
     * @param nativeEvent
     */
    private transferMouseData;
}

export declare const FederatedDisplayObject: Omit<FederatedEventTarget, 'parent' | 'children' | keyof EventEmitter | 'cursor'>;

/**
 * An DOM-compatible synthetic event implementation that is "forwarded" on behalf of an original
 * FederatedEvent or native {@link https://dom.spec.whatwg.org/#event Event}.
 *
 * @memberof PIXI
 * @typeParam N - The type of native event held.
 */
export declare class FederatedEvent<N extends UIEvent = UIEvent> implements UIEvent {
    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */
    bubbles: boolean;
    /** @deprecated */
    cancelBubble: boolean;
    /**
     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always
     * false (for now).
     */
    readonly cancelable = false;
    /**
     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events
     * API.
     *
     * @see https://dom.spec.whatwg.org/#dom-event-composed
     */
    readonly composed = false;
    /** The listeners of the event target that are being notified. */
    currentTarget: FederatedEventTarget;
    /** Flags whether the default response of the user agent was prevent through this event. */
    defaultPrevented: boolean;
    /**
     * The propagation phase.
     *
     * @default {@link FederatedEvent.NONE}
     */
    eventPhase: number;
    /** Flags whether this is a user-trusted event */
    isTrusted: boolean;
    /** @deprecated */
    returnValue: boolean;
    /** @deprecated */
    srcElement: EventTarget;
    /** The event target that this will be dispatched to. */
    target: FederatedEventTarget;
    /** The timestamp of when the event was created. */
    timeStamp: number;
    /** The type of event, e.g. {@code "mouseup"}. */
    type: string;
    /** The native event that caused the foremost original event. */
    nativeEvent: N;
    /** The original event that caused this event, if any. */
    originalEvent: FederatedEvent<N>;
    /** Flags whether propagation was stopped. */
    propagationStopped: boolean;
    /** Flags whether propagation was immediately stopped. */
    propagationImmediatelyStopped: boolean;
    /** The composed path of the event's propagation. The {@code target} is at the end. */
    path: FederatedEventTarget[];
    /** The {@link EventBoundary} that manages this event. Null for root events. */
    readonly manager: EventBoundary;
    /** Event-specific detail */
    detail: number;
    /** The global Window object. */
    view: WindowProxy;
    /**
     * Not supported.
     * @deprecated
     */
    which: number;
    /**
     * The coordinates of the evnet relative to the nearest DOM layer. This is a non-standard
     * property.
     */
    layer: Point;
    /** @readonly */
    get layerX(): number;
    /** @readonly */
    get layerY(): number;
    /**
     * The coordinates of the event relative to the DOM document. This is a non-standard property.
     */
    page: Point;
    /** @readonly */
    get pageX(): number;
    /** @readonly */
    get pageY(): number;
    /**
     * @param manager - The event boundary which manages this event. Propagation can only occur
     *  within the boundary's jurisdiction.
     */
    constructor(manager: EventBoundary);
    /**
     * Fallback for the deprecated {@link PIXI.InteractionEvent.data}.
     *
     * @deprecated
     */
    get data(): this;
    /**
     * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.
     */
    composedPath(): FederatedEventTarget[];
    /**
     * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw
     * an {@code Error}.
     */
    initEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void;
    /**
     * Prevent default behavior of PixiJS and the user agent.
     */
    preventDefault(): void;
    /**
     * Stop this event from propagating to any addition listeners, including on the
     * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
     * event targets on the propagation path.
     */
    stopImmediatePropagation(): void;
    /**
     * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
     * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
     */
    stopPropagation(): void;
    AT_TARGET: number;
    BUBBLING_PHASE: number;
    CAPTURING_PHASE: number;
    NONE: number;
}

/**
 * Describes the shape for a {@link FederatedEvent}'s' `eventTarget`.
 *
 * @memberof PIXI
 */
export declare interface FederatedEventTarget extends EventEmitter, EventTarget {
    /** The cursor preferred when the mouse pointer is hovering over. */
    cursor: Cursor | string;
    /** The parent of this event target. */
    readonly parent?: FederatedEventTarget;
    /** The children of this event target. */
    readonly children?: ReadonlyArray<FederatedEventTarget>;
    /** Whether this event target should fire UI events. */
    interactive: boolean;
    /**
     * Whether this event target has any children that need UI events. This can be used optimize
     * event propagation.
     */
    interactiveChildren: boolean;
    /** The hit-area specifies the area for which pointer events should be captured by this event target. */
    hitArea: IHitArea | null;
}

/**
 * A {@link PIXI.FederatedEvent} for mouse events.
 *
 * @memberof PIXI
 */
export declare class FederatedMouseEvent extends FederatedEvent<MouseEvent | PointerEvent | TouchEvent> implements MouseEvent {
    /** Whether the "alt" key was pressed when this mouse event occurred. */
    altKey: boolean;
    /** The specific button that was pressed in this mouse event. */
    button: number;
    /** The button depressed when this event occurred. */
    buttons: number;
    /** Whether the "control" key was pressed when this mouse event occurred. */
    ctrlKey: boolean;
    /** Whether the "meta" key was pressed when this mouse event occurred. */
    metaKey: boolean;
    /** This is currently not implemented in the Federated Events API. */
    relatedTarget: EventTarget;
    /** Whether the "shift" key was pressed when this mouse event occurred. */
    shiftKey: boolean;
    /**
     * The coordinates of the mouse event relative to the canvas.
     */
    client: Point;
    /** @readonly */
    get clientX(): number;
    /** @readonly */
    get clientY(): number;
    /**
     * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
     *
     * @readonly
     */
    get x(): number;
    /**
     * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
     *
     * @readonly
     */
    get y(): number;
    /**
     * This is the number of clicks that occurs in 200ms/click of each other.
     */
    detail: number;
    /**
     * The movement in this pointer relative to the last `mousemove` event.
     */
    movement: Point;
    /** @readonly */
    get movementX(): number;
    /** @readonly */
    get movementY(): number;
    /**
     * The offset of the pointer coordinates w.r.t. target DisplayObject in world space. This is
     * not supported at the moment.
     */
    offset: Point;
    /** @readonly */
    get offsetX(): number;
    /** @readonly */
    get offsetY(): number;
    /**
     * The pointer coordinates in world space.
     */
    global: Point;
    /** @readonly */
    get globalX(): number;
    /** @readonly */
    get globalY(): number;
    /**
     * The pointer coordinates in the renderer's {@link PIXI.Renderer.screen screen}. This has slightly
     * different semantics than native PointerEvent screenX/screenY.
     */
    screen: Point;
    /**
     * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
     *
     * @readonly
     */
    get screenX(): number;
    /**
     * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
     *
     * @readonly
     */
    get screenY(): number;
    /**
     * Whether the modifier key was pressed when this event natively occurred.
     *
     * @param key - The modifier key.
     */
    getModifierState(key: string): boolean;
    /**
     * Not supported.
     *
     * @deprecated
     */
    initMouseEvent(_typeArg: string, _canBubbleArg: boolean, _cancelableArg: boolean, _viewArg: Window, _detailArg: number, _screenXArg: number, _screenYArg: number, _clientXArg: number, _clientYArg: number, _ctrlKeyArg: boolean, _altKeyArg: boolean, _shiftKeyArg: boolean, _metaKeyArg: boolean, _buttonArg: number, _relatedTargetArg: EventTarget): void;
}

/**
 * A {@link PIXI.FederatedEvent} for pointer events.
 *
 * @memberof PIXI
 */
export declare class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent {
    /**
     * The unique identifier of the pointer.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}
     */
    pointerId: number;
    /**
     * The width of the pointer's contact along the x-axis, measured in CSS pixels.
     * radiusX of TouchEvents will be represented by this value.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width
     */
    width: number;
    /**
     * The height of the pointer's contact along the y-axis, measured in CSS pixels.
     * radiusY of TouchEvents will be represented by this value.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height
     */
    height: number;
    /**
     * Indicates whether or not the pointer device that created the event is the primary pointer.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary
     */
    isPrimary: boolean;
    /**
     * The type of pointer that triggered the event.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
     */
    pointerType: string;
    /**
     * Pressure applied by the pointing device during the event.
     *s
     * A Touch's force property will be represented by this value.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
     */
    pressure: number;
    /**
     * Barrel pressure on a stylus pointer.
     *
     * @see https://w3c.github.io/pointerevents/#pointerevent-interface
     */
    tangentialPressure: number;
    /**
     * The angle, in degrees, between the pointer device and the screen.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
     */
    tiltX: number;
    /**
     * The angle, in degrees, between the pointer device and the screen.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
     */
    tiltY: number;
    /**
     * Twist of a stylus pointer.
     *
     * @see https://w3c.github.io/pointerevents/#pointerevent-interface
     */
    twist: number;
    /**
     * This is the number of clicks that occurs in 200ms/click of each other.
     */
    detail: number;
    getCoalescedEvents(): PointerEvent[];
    getPredictedEvents(): PointerEvent[];
}

/**
 * A {@link PIXI.FederatedEvent} for wheel events.
 *
 * @memberof PIXI
 */
export declare class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent {
    /**
     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,
     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.
     */
    deltaMode: number;
    /** Horizontal scroll amount */
    deltaX: number;
    /** Vertical scroll amount */
    deltaY: number;
    /** z-axis scroll amount. */
    deltaZ: number;
    /** Units specified in lines. */
    DOM_DELTA_LINE: number;
    /** Units specified in pages. */
    DOM_DELTA_PAGE: number;
    /** Units specified in pixels. */
    DOM_DELTA_PIXEL: number;
}

export declare interface IHitArea {
    contains(x: number, y: number): boolean;
}

declare interface Renderer {
    _lastObjectRendered: IRenderableObject;
    view: HTMLCanvasElement;
    resolution: number;
    plugins: Record<string, any>;
}

/**
 * The tracking data for each pointer held in the state of an {@link PIXI.EventBoundary}.
 *
 * ```ts
 * pressTargetsByButton: {
 *      [id: number]: FederatedEventTarget[];
 * };
 * clicksByButton: {
 *     [id: number]: {
 *         clickCount: number;
 *         target: FederatedEventTarget;
 *         timeStamp: number;
 *     }
 * };
 * overTargets: FederatedEventTarget[];
 * ```
 *
 * @typedef {object} TrackingData@typedef {object} TrackingData
 * @property {Record.<number, PIXI.FederatedEventTarget>} pressTargetsByButton - The pressed display objects'
 *  propagation paths by each button of the pointer.
 * @property {Record.<number, Object>} clicksByButton - Holds clicking data for each button of the pointer.
 * @property {PIXI.DisplayObject[]} overTargets - The DisplayObject propagation path over which the pointer is hovering.
 * @memberof PIXI
 */
declare type TrackingData = {
    pressTargetsByButton: {
        [id: number]: FederatedEventTarget[];
    };
    clicksByButton: {
        [id: number]: {
            clickCount: number;
            target: FederatedEventTarget;
            timeStamp: number;
        };
    };
    overTargets: FederatedEventTarget[];
};

export { }
