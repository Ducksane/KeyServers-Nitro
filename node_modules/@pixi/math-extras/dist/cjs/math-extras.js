/*!
 * @pixi/math-extras - v6.3.0
 * Compiled Wed, 23 Mar 2022 18:58:56 UTC
 *
 * @pixi/math-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var math = require('@pixi/math');

var mixins = {
    /**
     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method add
     * @memberof PIXI.Point#
     * @param {IPointData} other - The point to add to `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.
     */
    /**
     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method add
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The point to add to `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.
     */
    add: function (other, outPoint) {
        if (!outPoint) {
            outPoint = new math.Point();
        }
        outPoint.x = this.x + other.x;
        outPoint.y = this.y + other.y;
        return outPoint;
    },
    /**
     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method subtract
     * @memberof PIXI.Point#
     * @param {IPointData} other - The point to subtract to `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.
     */
    /**
     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method subtract
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The point to subtract to `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.
     */
    subtract: function (other, outPoint) {
        if (!outPoint) {
            outPoint = new math.Point();
        }
        outPoint.x = this.x - other.x;
        outPoint.y = this.y - other.y;
        return outPoint;
    },
    /**
     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method multiply
     * @memberof PIXI.Point#
     * @param {IPointData} other - The point to multiply with `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.
     */
    /**
     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method multiply
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The point to multiply with `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.
     */
    multiply: function (other, outPoint) {
        if (!outPoint) {
            outPoint = new math.Point();
        }
        outPoint.x = this.x * other.x;
        outPoint.y = this.y * other.y;
        return outPoint;
    },
    /**
     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method multiplyScalar
     * @memberof PIXI.Point#
     * @param {number} scalar - The number to multiply both components of `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.
     */
    /**
     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method multiplyScalar
     * @memberof PIXI.ObservablePoint#
     * @param {number} scalar - The number to multiply both components of `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.
     */
    multiplyScalar: function (scalar, outPoint) {
        if (!outPoint) {
            outPoint = new math.Point();
        }
        outPoint.x = this.x * scalar;
        outPoint.y = this.y * scalar;
        return outPoint;
    },
    /**
     * Computes the dot product of `other` with `this` point.
     * The dot product is the sum of the products of the corresponding components of two vectors.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method dot
     * @memberof PIXI.Point#
     * @param {IPointData} other - The other point to calculate the dot product with `this`.
     * @returns {number} The result of the dot product. This is an scalar value.
     */
    /**
     * Computes the dot product of `other` with `this` point.
     * The dot product is the sum of the products of the corresponding components of two vectors.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method dot
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The other point to calculate the dot product with `this`.
     * @returns {number} The result of the dot product. This is an scalar value.
     */
    dot: function (other) {
        return (this.x * other.x) + (this.y * other.y);
    },
    /**
     * Computes the cross product of `other` with `this` point.
     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read "a cross b"),
     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.
     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and
     * the result becomes a vector that will only have magnitude on the z axis.
     *
     * This function returns the z component of the cross product of the two points.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method cross
     * @memberof PIXI.Point#
     * @param {IPointData} other - The other point to calculate the cross product with `this`.
     * @returns {number} The z component of the result of the cross product.
     */
    /**
     * Computes the cross product of `other` with `this` point.
     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read "a cross b"),
     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.
     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and
     * the result becomes a vector that will only have magnitude on the z axis.
     *
     * This function returns the z component of the cross product of the two points.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method cross
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} other - The other point to calculate the cross product with `this`.
     * @returns {number} The z component of the result of the cross product.
     */
    cross: function (other) {
        /*
         * Returns the magnitude of the vector that would result
         * from a regular 3D cross product of the input vectors,
         * taking their Z values implicitly as 0
         * (i.e. treating the 2D space as a plane in the 3D space).
         * The 3D cross product will be perpendicular to that plane,
         * and thus have 0 X & Y components
         * (thus the scalar returned is the Z value of the 3D cross product vector).
         */
        return (this.x * other.y) - (this.y * other.x);
    },
    /**
     * Computes a normalized version of `this` point.
     *
     * A normalized vector is a vector of magnitude (length) 1
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method normalize
     * @memberof PIXI.Point#
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The normalized point.
     */
    /**
     * Computes a normalized version of `this` point.
     *
     * A normalized vector is a vector of magnitude (length) 1
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method normalize
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The normalized point.
     */
    normalize: function (outPoint) {
        if (!outPoint) {
            outPoint = new math.Point();
        }
        var magnitude = Math.sqrt((this.x * this.x) + (this.y * this.y));
        outPoint.x = this.x / magnitude;
        outPoint.y = this.y / magnitude;
        return outPoint;
    },
    /**
     * Computes the magnitude of this point (Euclidean distance from 0, 0).
     *
     * Defined as the square root of the sum of the squares of each component.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method magnitude
     * @memberof PIXI.Point#
     * @returns {number} The magnitude (length) of the vector.
     */
    /**
     * Computes the magnitude of this point (Euclidean distance from 0, 0).
     *
     * Defined as the square root of the sum of the squares of each component.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method magnitude
     * @memberof PIXI.ObservablePoint#
     * @returns {number} The magnitude (length) of the vector.
     */
    magnitude: function () {
        return Math.sqrt((this.x * this.x) + (this.y * this.y));
    },
    /**
     * Computes the square magnitude of this point.
     * If you are comparing the lengths of vectors, you should compare the length squared instead
     * as it is slightly more efficient to calculate.
     *
     * Defined as the sum of the squares of each component.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method magnitudeSquared
     * @memberof PIXI.Point#
     * @returns {number} The magnitude squared (length squared) of the vector.
     */
    /**
     * Computes the square magnitude of this point.
     * If you are comparing the lengths of vectors, you should compare the length squared instead
     * as it is slightly more efficient to calculate.
     *
     * Defined as the sum of the squares of each component.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method magnitudeSquared
     * @memberof PIXI.ObservablePoint#
     * @returns {number} The magnitude squared (length squared) of the vector.
     */
    magnitudeSquared: function () {
        return (this.x * this.x) + (this.y * this.y);
    },
    /**
     * Computes vector projection of `this` on `onto`.
     *
     * Imagine a light source, parallel to `onto`, above `this`.
     * The light would cast rays perpendicular to `onto`.
     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method project
     * @memberof PIXI.Point#
     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `this` on `onto` projection.
     */
    /**
     * Computes vector projection of `this` on `onto`.
     *
     * Imagine a light source, parallel to `onto`, above `this`.
     * The light would cast rays perpendicular to `onto`.
     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method project
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The `this` on `onto` projection.
     */
    project: function (onto, outPoint) {
        if (!outPoint) {
            outPoint = new math.Point();
        }
        // Math says: a Projected over b = [(a·b) / (b·b)] * b;
        var normalizedScalarProjection = ((this.x * onto.x) + (this.y * onto.y)) / ((onto.x * onto.x) + (onto.y * onto.y));
        outPoint.x = onto.x * normalizedScalarProjection;
        outPoint.y = onto.y * normalizedScalarProjection;
        return outPoint;
    },
    /**
     * Reflects `this` vector off of a plane orthogonal to `normal`.
     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.
     *
     * Imagine a light source bouncing onto a mirror.
     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.
     * `this.reflect(normal)` is the reflection of `this` on that mirror.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method reflect
     * @memberof PIXI.Point#
     * @param {IPointData} normal - The normal vector of your reflecting plane.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The reflection of `this` on your reflecting plane.
     */
    /**
     * Reflects `this` vector off of a plane orthogonal to `normal`.
     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.
     *
     * Imagine a light source bouncing onto a mirror.
     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.
     * `this.reflect(normal)` is the reflection of `this` on that mirror.
     *
     * _Note: Only available with **@pixi/math-extras**._
     *
     * @method reflect
     * @memberof PIXI.ObservablePoint#
     * @param {IPointData} normal - The normal vector of your reflecting plane.
     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
     * optional (otherwise will create a new Point).
     * @returns {IPointData} The reflection of `this` on your reflecting plane.
     */
    reflect: function (normal, outPoint) {
        if (!outPoint) {
            outPoint = new math.Point();
        }
        // Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n
        var dotProduct = (this.x * normal.x) + (this.y * normal.y);
        outPoint.x = this.x - (2 * dotProduct * normal.x);
        outPoint.y = this.y - (2 * dotProduct * normal.y);
        return outPoint;
    }
};
Object.assign(math.Point.prototype, mixins);
Object.assign(math.ObservablePoint.prototype, mixins);

/**
 * Determines whether the `other` Rectangle is contained within `this` Rectangle object.
 * Rectangles that occupy the same space are considered to be containing each other.
 * Rectangles without area (width or height equal to zero) can't contain anything,
 * not even other arealess rectangles.
 *
 * _Note: Only available with **@pixi/math-extras**._
 *
 * @method containsRect
 * @memberof PIXI.Rectangle#
 * @param {Rectangle} other - The Rectangle to fit inside `this`.
 * @returns {boolean} A value of `true` if `this` Rectangle contains `other`; otherwise `false`.
 */
math.Rectangle.prototype.containsRect = function containsRect(other) {
    if (other.width <= 0 || other.height <= 0) {
        return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;
    }
    return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;
};
/**
 * Accepts `other` Rectangle and returns true if the given Rectangle is equal to `this` Rectangle.
 *
 * _Note: Only available with **@pixi/math-extras**._
 *
 * @method equals
 * @memberof PIXI.Rectangle#
 * @param {Rectangle} other - The Rectangle to compare with `this`
 * @returns {boolean} Returns true if all `x`, `y`, `width`, and `height` are equal.
 */
math.Rectangle.prototype.equals = function equals(other) {
    if (other === this) {
        return true;
    }
    return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
};
/**
 * If the area of the intersection between the Rectangles `other` and `this` is not zero,
 * returns the area of intersection as a Rectangle object. Otherwise, return an empty Rectangle
 * with its properties set to zero.
 * Rectangles without area (width or height equal to zero) can't intersect or be intersected
 * and will always return an empty rectangle with its properties set to zero.
 *
 * _Note: Only available with **@pixi/math-extras**._
 *
 * @method intersects
 * @memberof PIXI.Rectangle#
 * @param {Rectangle} other - The Rectangle to intersect with `this`.
 * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,
 * optional (otherwise will create a new Rectangle).
 * @returns {Rectangle} The intersection of `this` and `other`.
 */
math.Rectangle.prototype.intersection = function intersection(other, outRect) {
    if (!outRect) {
        outRect = new math.Rectangle();
    }
    var x0 = this.x < other.x ? other.x : this.x;
    var x1 = this.right > other.right ? other.right : this.right;
    if (x1 <= x0) {
        outRect.x = outRect.y = outRect.width = outRect.height = 0;
        return outRect;
    }
    var y0 = this.y < other.y ? other.y : this.y;
    var y1 = this.bottom > other.bottom ? other.bottom : this.bottom;
    if (y1 <= y0) {
        outRect.x = outRect.y = outRect.width = outRect.height = 0;
        return outRect;
    }
    outRect.x = x0;
    outRect.y = y0;
    outRect.width = x1 - x0;
    outRect.height = y1 - y0;
    return outRect;
};
/**
 * Adds `this` and `other` Rectangles together to create a new Rectangle object filling
 * the horizontal and vertical space between the two rectangles.
 *
 * _Note: Only available with **@pixi/math-extras**._
 *
 * @method intersects
 * @memberof PIXI.Rectangle#
 * @param {Rectangle} other - The Rectangle to unite with `this`.
 * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,
 * optional (otherwise will create a new Rectangle).
 * @returns {Rectangle} The union of `this` and `other`.
 */
math.Rectangle.prototype.union = function union(other, outRect) {
    if (!outRect) {
        outRect = new math.Rectangle();
    }
    var x1 = Math.min(this.x, other.x);
    var x2 = Math.max(this.x + this.width, other.x + other.width);
    var y1 = Math.min(this.y, other.y);
    var y2 = Math.max(this.y + this.height, other.y + other.height);
    outRect.x = x1;
    outRect.y = y1;
    outRect.width = x2 - x1;
    outRect.height = y2 - y1;
    return outRect;
};

function floatEqual(a, b, epsilon) {
    if (epsilon === void 0) { epsilon = Number.EPSILON; }
    if (a === b) {
        return true;
    }
    var diff = Math.abs(a - b);
    return diff < epsilon;
}
/**
 * Generic line or segment intersection.
 * A line can intersect outside the two points defining it, the segment can't.
 * @param aStart - First point of the first line.
 * @param aEnd - Second point of the first line.
 * @param bStart - First point of the second line.
 * @param bEnd - Second point of the second line.
 * @param isLine - Set to true if you want Line (unbounded) intersection.
 * @param {IPointData} [outPoint] - A Point-like object in which to store the value,
 * optional (otherwise will create a new Point).
 * @returns {IPointData} The point where the lines/segments intersect or a `NaN` Point.
 */
function genericLineIntersection(aStart, aEnd, bStart, bEnd, isLine, outPoint) {
    if (!outPoint) {
        outPoint = new math.Point();
    }
    var dxa = aEnd.x - aStart.x;
    var dya = aEnd.y - aStart.y;
    var dxb = bEnd.x - bStart.x;
    var dyb = bEnd.y - bStart.y;
    // In order to find the position of the intersection in respect to the line segments, we can define lines
    // in terms of first degree Bézier parameters, and find the two parameters `ua` and `ub` for the two lines to touch.
    // both `ua` and `ub` formula share the same denominator so it is only calculated once.
    var denominator = ((dyb * dxa) - (dxb * dya));
    // If lines are parallel or overlapping, the intersection can be nowhere or everywhere... NaN.
    if (floatEqual(denominator, 0)) {
        outPoint.x = NaN;
        outPoint.y = NaN;
        return outPoint;
    }
    // ua is the factor of line a where the intersection occurs. ub is the factor of line b where the intersection occurs.
    var ua = ((dxb * (aStart.y - bStart.y)) - (dyb * (aStart.x - bStart.x))) / denominator;
    var ub = ((dxa * (aStart.y - bStart.y)) - (dya * (aStart.x - bStart.x))) / denominator;
    // Line intersection extends beyond the bounds of the segment.
    // The intersection is inside the segments if 0.0 ≤ ua ≤ 1.0 and 0.0 ≤ ub ≤ 1.0
    if (!isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1)) {
        outPoint.x = NaN;
        outPoint.y = NaN;
        return outPoint;
    }
    outPoint.x = aStart.x + (ua * dxa);
    outPoint.y = bStart.y + (ub * dyb);
    return outPoint;
}
function lineIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
    return genericLineIntersection(aStart, aEnd, bStart, bEnd, true, outPoint);
}
function segmentIntersection(aStart, aEnd, bStart, bEnd, outPoint) {
    return genericLineIntersection(aStart, aEnd, bStart, bEnd, false, outPoint);
}

exports.floatEqual = floatEqual;
exports.lineIntersection = lineIntersection;
exports.segmentIntersection = segmentIntersection;
//# sourceMappingURL=math-extras.js.map
