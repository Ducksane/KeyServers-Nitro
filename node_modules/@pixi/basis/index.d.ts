import { INTERNAL_FORMATS } from '@pixi/compressed-textures';
import { LoaderResource } from '@pixi/loaders';
import { Runner } from '@pixi/runner';
import { TYPES } from '@pixi/constants';

/**
 * Binding to basis_universal WebGL library.
 *
 * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/build/basis_transcoder.js
 * @ignore
 */
export declare type BASIS = (opts?: {
    wasmBinary: ArrayBuffer;
}) => Promise<BasisBinding>;

/**
 * Maps {@link BASIS_FORMATS} to {@link PIXI.INTERNAL_FORMATS}
 *
 * @ignore
 */
export declare const BASIS_FORMAT_TO_INTERNAL_FORMAT: {
    [id: number]: INTERNAL_FORMATS;
};

/**
 * Maps {@link BASIS_FORMATS} to {@link PIXI.TYPES}. These formats are a fallback when the basis file cannot be transcoded
 * to a valid compressed texture format.
 *
 * NOTE: {@link BASIS_FORMATS.cTFBGR565} is not supported, while {@link BASIS_FORMATS.cTFRGBA4444} is not implemented by
 *  [at]pixi/basis.
 *
 * @ignore
 */
export declare const BASIS_FORMAT_TO_TYPE: {
    [id: number]: TYPES;
};

/**
 * The transcoding formats provided by basis_universal.
 *
 * NOTE: Not all of these formats are supported on WebGL!
 *
 * @ignore
 */
export declare enum BASIS_FORMATS {
    cTFETC1 = 0,
    cTFETC2 = 1,
    cTFBC1 = 2,
    cTFBC3 = 3,
    cTFBC4 = 4,
    cTFBC5 = 5,
    cTFBC7 = 6,
    cTFPVRTC1_4_RGB = 8,
    cTFPVRTC1_4_RGBA = 9,
    cTFASTC_4x4 = 10,
    cTFATC_RGB = 11,
    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,
    cTFRGBA32 = 13,
    cTFRGB565 = 14,
    cTFBGR565 = 15,
    cTFRGBA4444 = 16
}

/**
 * Enumerates the basis formats with alpha components
 *
 * @ignore
 */
export declare const BASIS_FORMATS_ALPHA: {
    [id: number]: boolean;
};

/**
 * API provided by basis_universal WebGL library.
 *
 * @ignore
 */
export declare type BasisBinding = {
    BasisFile: typeof BasisFile;
    initializeBasis(): void;
};

/**
 * Binding to C++ {@code BasisFile} wrapper class.
 *
 * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/basis_wrappers.cpp
 * @private
 */
export declare class BasisFile {
    constructor(buffer: Uint8Array);
    getNumImages(): number;
    getNumLevels(imageId: number): number;
    getImageWidth(imageId: number, level: number): number;
    getImageHeight(imageId: number, level: number): number;
    getHasAlpha(): boolean;
    startTranscoding(): boolean;
    getImageTranscodedSizeInBytes(imageId: number, level: number, basisFormat: number): number;
    transcodeImage(dstBuff: Uint8Array, imageId: number, level: number, basisFormat: BASIS_FORMATS, pvrtcWrapAddressing: boolean, getAlphaForOpaqueFormats: boolean): number;
    close(): void;
    delete(): void;
}

/**
 * Loader plugin for handling BASIS supercompressed texture files.
 *
 * To use this loader, you must bind the basis_universal WebAssembly transcoder. There are two ways of
 * doing this:
 *
 * 1. Adding a &lt;script&gt; tag to your HTML page to the transcoder bundle in this package, and serving
 * the WASM binary from the same location.
 *
 * ```js
 * // Copy ./node_modules/@pixi/basis/assets/basis_.wasm into your assets directory
 * // as well, so it is served from the same folder as the JavaScript!
 * &lt;script src="./node_modules/@pixi/basis/assets/basis_transcoder.js" /&gt;
 * ```
 *
 * NOTE: `basis_transcoder.js` expects the WebAssembly binary to be named `basis_transcoder.wasm`.
 * NOTE-2: This method supports transcoding on the main-thread. Only use this if you have 1 or 2 *.basis
 * files.
 *
 * 2. Loading the transcoder source from a URL.
 *
 * ```js
 * // Use this if you to use the default CDN url for @pixi/basis
 * BasisLoader.loadTranscoder();
 *
 * // Use this if you want to serve the transcoder on your own
 * BasisLoader.loadTranscoder('./basis_transcoder.js', './basis_transcoder.wasm');
 * ```
 *
 * NOTE: This can only be used with web-workers.
 *
 * @class
 * @memberof PIXI
 * @implements PIXI.ILoaderPlugin
 */
export declare class BasisLoader {
    private static basisBinding;
    private static defaultRGBFormat;
    private static defaultRGBAFormat;
    private static fallbackMode;
    private static workerPool;
    /**
     * Transcodes the *.basis data when the data is loaded. If the transcoder is not bound yet, it
     * will hook transcoding to {@link BasisResource#onTranscoderInitialized}.
     *
     * @see PIXI.Loader.loaderMiddleware
     * @param resource - loader resource that is checked to see if it is a basis file
     * @param next - callback Function to call when done
     */
    static use(resource: LoaderResource, next: (...args: any[]) => void): void;
    /**
     * Runs transcoding and populates {@link imageArray}. It will run the transcoding in a web worker
     * if they are available.
     *
     * @private
     */
    private static transcode;
    /**
     * Creates textures and adds them to the texture cache
     * @private
     * @param url - url of the texture to be used as its ID for the texture cache
     * @param resources - the transcoded resources
     * @param metadata - resource metadata
     */
    private static registerTextures;
    /**
     * Finds a suitable worker for transcoding and sends a transcoding request
     *
     * @private
     * @async
     */
    private static transcodeAsync;
    /**
     * Runs transcoding on the main thread.
     *
     * @private
     */
    private static transcodeSync;
    /**
     * Detects the available compressed texture formats on the device.
     *
     * @param extensions - extensions provided by a WebGL context
     * @ignore
     */
    static autoDetectFormats(extensions?: Partial<BasisTextureExtensions>): void;
    /**
     * Binds the basis_universal transcoder to decompress *.basis files. You must initialize the transcoder library yourself.
     *
     * ```js
     * import { BasisLoader } from '@pixi/basis';
     * import { Loader } from '@pixi/loaders';
     *
     * // window.BASIS() returns a Promise-like object
     * window.BASIS().then((basisLibrary) =>
     * {
     *     // Initialize basis-library; otherwise, transcoded results maybe corrupt!
     *     basisLibrary.initializeBasis();
     *
     *     // Bind BasisLoader to the transcoder
     *     BasisLoader.bindTranscoder(basisLibrary);
     * });
     * ```
     *
     * @param basisLibrary - the initialized transcoder library
     * @private
     */
    static bindTranscoder(basisLibrary: BasisBinding): void;
    /**
     * Loads the transcoder source code for use in {@link PIXI.BasisLoader.TranscoderWorker}.
     *
     * @private
     * @param jsURL - URL to the javascript basis transcoder
     * @param wasmURL - URL to the wasm basis transcoder
     */
    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>;
    /**
     * Set the transcoder source code directly
     *
     * @private
     * @param jsSource - source for the javascript basis transcoder
     * @param wasmSource - source for the wasm basis transcoder
     */
    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void;
    static TranscoderWorker: typeof TranscoderWorker;
    static get TRANSCODER_WORKER_POOL_LIMIT(): number;
    static set TRANSCODER_WORKER_POOL_LIMIT(limit: number);
}

/**
 * Compressed texture extensions relevant to the formats into which Basis can decompress into.
 *
 * @ignore
 */
export declare type BasisTextureExtensions = {
    s3tc?: WEBGL_compressed_texture_s3tc;
    s3tc_sRGB: WEBGL_compressed_texture_s3tc_srgb;
    etc: any;
    etc1: any;
    pvrtc: any;
    atc: any;
    astc: WEBGL_compressed_texture_astc;
};

/**
 * Maps {@link PIXI.INTERNAL_FORMATS} to {@link BASIS_FORMATS}
 *
 * @ignore
 */
export declare const INTERNAL_FORMAT_TO_BASIS_FORMAT: {
    [id: number]: number;
};

/**
 * Response format for {@link TranscoderWorker}.
 * @ignore
 */
declare interface ITranscodeResponse {
    type: 'init' | 'transcode';
    requestID?: number;
    success: boolean;
    basisFormat?: BASIS_FORMATS;
    imageArray?: Array<{
        imageID: number;
        levelArray: Array<{
            levelID: number;
            levelWidth: number;
            levelHeight: number;
            levelBuffer: Uint8Array;
        }>;
        width: number;
        height: number;
    }>;
}

/**
 * Worker class for transcoding *.basis files in background threads.
 *
 * To enable asynchronous transcoding, you need to provide the URL to the basis_universal transcoding
 * library.
 *
 * @memberof PIXI.BasisLoader
 */
declare class TranscoderWorker {
    /** URL for the script containing the basis_universal library. */
    static bindingURL: string;
    static jsSource: string;
    static wasmSource: ArrayBuffer;
    static onTranscoderInitialized: Runner;
    isInit: boolean;
    load: number;
    requests: {
        [id: number]: {
            resolve: (data: ITranscodeResponse) => void;
            reject: () => void;
        };
    };
    private static _workerURL;
    private static _tempID;
    /** Generated URL for the transcoder worker script. */
    static get workerURL(): string;
    protected worker: Worker;
    protected initPromise: Promise<void>;
    protected onInit: () => void;
    constructor();
    /** @returns a promise that is resolved when the web-worker is initialized */
    initAsync(): Promise<void>;
    /**
     * Creates a promise that will resolve when the transcoding of a *.basis file is complete.
     * @param basisData - *.basis file contents
     * @param rgbaFormat - transcoding format for RGBA files
     * @param rgbFormat - transcoding format for RGB files
     * @returns a promise that is resolved with the transcoding response of the web-worker
     */
    transcodeAsync(basisData: Uint8Array, rgbaFormat: BASIS_FORMATS, rgbFormat: BASIS_FORMATS): Promise<ITranscodeResponse>;
    /**
     * Handles responses from the web-worker
     *
     * @param e - a message event containing the transcoded response
     */
    protected onMessage: (e: MessageEvent) => void;
    /**
     * Loads the transcoder source code
     *
     * @param jsURL - URL to the javascript basis transcoder
     * @param wasmURL - URL to the wasm basis transcoder
     * @returns A promise that resolves when both the js and wasm transcoders have been loaded.
     */
    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>;
    /**
     * Set the transcoder source code directly
     *
     * @param jsSource - source for the javascript basis transcoder
     * @param wasmSource - source for the wasm basis transcoder
     */
    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void;
}

export { }
