{"version":3,"file":"basis.min.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/Basis.ts","../../src/TranscoderWorkerWrapper.ts","../../src/TranscoderWorker.ts","../../src/BasisLoader.ts","../../src/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { TYPES } from '@pixi/constants';\nimport { INTERNAL_FORMATS } from '@pixi/compressed-textures';\n\n/**\n * The transcoding formats provided by basis_universal.\n *\n * NOTE: Not all of these formats are supported on WebGL!\n *\n * @ignore\n */\n/* eslint-disable camelcase */\nexport enum BASIS_FORMATS {\n    cTFETC1 = 0,\n    cTFETC2 = 1,\n    cTFBC1 = 2,\n    cTFBC3 = 3,\n    cTFBC4 = 4,\n    cTFBC5 = 5,\n    cTFBC7 = 6,\n    cTFPVRTC1_4_RGB = 8,\n    cTFPVRTC1_4_RGBA = 9,\n    cTFASTC_4x4 = 10,\n    cTFATC_RGB = 11,\n    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,\n    cTFRGBA32 = 13,\n    cTFRGB565 = 14,\n    cTFBGR565 = 15,\n    cTFRGBA4444 = 16,\n}\n/* eslint-enable camelcase */\n\n/**\n * Maps {@link BASIS_FORMATS} to {@link PIXI.INTERNAL_FORMATS}\n *\n * @ignore\n */\nexport const BASIS_FORMAT_TO_INTERNAL_FORMAT: { [id: number]: INTERNAL_FORMATS } = {\n    [BASIS_FORMATS.cTFETC1]: INTERNAL_FORMATS.COMPRESSED_RGB_ETC1_WEBGL,\n    [BASIS_FORMATS.cTFBC1]: INTERNAL_FORMATS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n    [BASIS_FORMATS.cTFBC3]: INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGB]: INTERNAL_FORMATS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGBA]: INTERNAL_FORMATS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n    [BASIS_FORMATS.cTFATC_RGB]: INTERNAL_FORMATS.COMPRESSED_RGB_ATC_WEBGL,\n    [BASIS_FORMATS.cTFASTC_4x4]: INTERNAL_FORMATS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n};\n\n/**\n * Maps {@link BASIS_FORMATS} to {@link PIXI.TYPES}. These formats are a fallback when the basis file cannot be transcoded\n * to a valid compressed texture format.\n *\n * NOTE: {@link BASIS_FORMATS.cTFBGR565} is not supported, while {@link BASIS_FORMATS.cTFRGBA4444} is not implemented by\n *  [at]pixi/basis.\n *\n * @ignore\n */\nexport const BASIS_FORMAT_TO_TYPE: { [id: number]: TYPES } = {\n    [BASIS_FORMATS.cTFRGBA32]: TYPES.UNSIGNED_BYTE,\n    [BASIS_FORMATS.cTFRGB565]: TYPES.UNSIGNED_SHORT_5_6_5,\n    [BASIS_FORMATS.cTFRGBA4444]: TYPES.UNSIGNED_SHORT_4_4_4_4\n};\n\n/**\n * Maps {@link PIXI.INTERNAL_FORMATS} to {@link BASIS_FORMATS}\n *\n * @ignore\n */\nexport const INTERNAL_FORMAT_TO_BASIS_FORMAT: { [id: number]: number }\n    = (Object.keys(BASIS_FORMAT_TO_INTERNAL_FORMAT) as string[])\n        .map((key: string) => Number(key))\n        .reduce((reverseMap: any, basisFormat: any) =>\n        {\n            reverseMap[(BASIS_FORMAT_TO_INTERNAL_FORMAT as any)[basisFormat]] = basisFormat;\n\n            return reverseMap;\n        }, {});\n\n/**\n * Enumerates the basis formats with alpha components\n *\n * @ignore\n */\nexport const BASIS_FORMATS_ALPHA: { [id: number]: boolean } = {\n    [BASIS_FORMATS.cTFBC3]: true,\n    [BASIS_FORMATS.cTFPVRTC1_4_RGBA]: true,\n    [BASIS_FORMATS.cTFASTC_4x4]: true\n};\n\n/**\n * Binding to C++ {@code BasisFile} wrapper class.\n *\n * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/basis_wrappers.cpp\n * @private\n */\nexport declare class BasisFile\n{\n    constructor(buffer: Uint8Array);\n    getNumImages(): number;\n    getNumLevels(imageId: number): number;\n    getImageWidth(imageId: number, level: number): number;\n    getImageHeight(imageId: number, level: number): number;\n    getHasAlpha(): boolean;\n    startTranscoding(): boolean;\n    getImageTranscodedSizeInBytes(\n        imageId: number,\n        level: number,\n        basisFormat: number): number;\n    transcodeImage(dstBuff: Uint8Array,\n        imageId: number,\n        level: number,\n        basisFormat: BASIS_FORMATS,\n        pvrtcWrapAddressing: boolean,\n        getAlphaForOpaqueFormats: boolean): number;\n    close(): void;\n    delete(): void;\n}\n\n// Missing typings? - https://github.com/microsoft/TypeScript/issues/39655\n/**\n * Compressed texture extensions relevant to the formats into which Basis can decompress into.\n *\n * @ignore\n */\n/* eslint-disable camelcase */\nexport type BasisTextureExtensions = {\n    s3tc?: WEBGL_compressed_texture_s3tc,\n    s3tc_sRGB: WEBGL_compressed_texture_s3tc_srgb,\n    etc: any,\n    etc1: any,\n    pvrtc: any,\n    atc: any,\n    astc: WEBGL_compressed_texture_astc\n};\n/* eslint-enable camelcase */\n\n/**\n * API provided by basis_universal WebGL library.\n *\n * @ignore\n */\nexport type BasisBinding = {\n    BasisFile: typeof BasisFile,\n    initializeBasis(): void\n};\n\n/**\n * Binding to basis_universal WebGL library.\n *\n * @see https://github.com/BinomialLLC/basis_universal/blob/master/webgl/transcoder/build/basis_transcoder.js\n * @ignore\n */\nexport type BASIS = (opts?: { wasmBinary: ArrayBuffer }) => Promise<BasisBinding>;\n","import type { BASIS, BASIS_FORMATS, BasisBinding } from './Basis';\n\n/**\n * Initialization message sent by the main thread.\n * @ignore\n */\nexport interface IInitializeTranscoderMessage {\n    wasmSource: ArrayBuffer;\n    type: 'init';\n}\n\n/**\n * Request parameters for transcoding basis files. It only supports transcoding all of the basis file at once.\n * @ignore\n */\nexport interface ITranscodeMessage\n{\n    requestID?: number;\n    rgbFormat: number;\n    rgbaFormat?: number;\n    basisData?: Uint8Array;\n    type: 'transcode';\n}\n\n/** @ignore */\nexport interface ITranscodedImage {\n    imageID: number;\n    levelArray: Array<{\n        levelID: number,\n        levelWidth: number,\n        levelHeight: number,\n        levelBuffer: Uint8Array\n    }>;\n    width: number;\n    height: number;\n}\n\n/**\n * Response format for {@link TranscoderWorker}.\n * @ignore\n */\nexport interface ITranscodeResponse {\n    type: 'init' | 'transcode';\n    requestID?: number;\n    success: boolean;\n    basisFormat?: BASIS_FORMATS;\n    imageArray?: Array<{\n        imageID: number,\n        levelArray: Array<{\n            levelID: number,\n            levelWidth: number,\n            levelHeight: number,\n            levelBuffer: Uint8Array\n        }>,\n        width: number,\n        height: number\n    }>;\n}\n\ndeclare global {\n    interface Window {\n        BASIS: BASIS;\n    }\n}\n\n/**\n * This wraps the transcoder web-worker functionality; it can be converted into a string to get the source code. It expects\n * you to prepend the transcoder JavaScript code so that the `BASIS` namespace is available.\n *\n * The transcoder worker responds to two types of messages: \"init\" and \"transcode\". You must always send the first \"init\"\n * {@link IInitializeTranscoderMessage} message with the WebAssembly binary; if the transcoder is successfully initialized,\n * the web-worker will respond by sending another {@link ITranscodeResponse} message with `success: true`.\n *\n * @ignore\n */\nexport function TranscoderWorkerWrapper(): void\n{\n    let basisBinding: BasisBinding;\n\n    const messageHandlers = {\n        init: (message: IInitializeTranscoderMessage): ITranscodeResponse =>\n        {\n            if (!self.BASIS)\n            {\n                console.warn('jsSource was not prepended?');\n\n                return {\n                    type: 'init',\n                    success: false\n                };\n            }\n\n            self.BASIS({ wasmBinary: message.wasmSource }).then((basisLibrary) =>\n            {\n                basisLibrary.initializeBasis();\n                basisBinding = basisLibrary;\n\n                (self as any).postMessage({\n                    type: 'init',\n                    success: true\n                });\n            });\n\n            return null;\n        },\n        transcode(message: ITranscodeMessage): ITranscodeResponse\n        {\n            const basisData = message.basisData;\n            const BASIS = basisBinding;\n\n            const data = basisData;\n            const basisFile = new BASIS.BasisFile(data);\n            const imageCount = basisFile.getNumImages();\n            const hasAlpha = basisFile.getHasAlpha();\n\n            const basisFormat = hasAlpha\n                ? message.rgbaFormat\n                : message.rgbFormat;\n            const basisFallbackFormat = 14;// BASIS_FORMATS.cTFRGB565 (cannot import values into web-worker!)\n            const imageArray = new Array(imageCount);\n\n            let fallbackMode = false;\n\n            if (!basisFile.startTranscoding())\n            {\n                basisFile.close();\n                basisFile.delete();\n\n                return {\n                    type: 'transcode',\n                    requestID: message.requestID,\n                    success: false,\n                    imageArray: null\n                };\n            }\n\n            for (let i = 0; i < imageCount; i++)\n            {\n                const levels = basisFile.getNumLevels(i);\n                const imageResource: ITranscodedImage = {\n                    imageID: i,\n                    levelArray: new Array<{\n                        levelID: number,\n                        levelWidth: number,\n                        levelHeight: number,\n                        levelBuffer: Uint8Array\n                    }>(),\n                    width: null,\n                    height: null\n                };\n\n                for (let j = 0; j < levels; j++)\n                {\n                    const format = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n                    const width = basisFile.getImageWidth(i, j);\n                    const height = basisFile.getImageHeight(i, j);\n                    const byteSize = basisFile.getImageTranscodedSizeInBytes(i, j, format);\n\n                    const alignedWidth = (width + 3) & ~3;\n                    const alignedHeight = (height + 3) & ~3;\n\n                    // Level 0 is texture's actual width, height\n                    if (j === 0)\n                    {\n                        imageResource.width = alignedWidth;\n                        imageResource.height = alignedHeight;\n                    }\n\n                    const imageBuffer = new Uint8Array(byteSize);\n\n                    if (!basisFile.transcodeImage(imageBuffer, i, j, format, false, false))\n                    {\n                        if (fallbackMode)\n                        {\n                            // We failed in fallback mode as well!\n                            console.error(`Basis failed to transcode image ${i}, level ${j}!`);\n\n                            return { type: 'transcode', requestID: message.requestID, success: false };\n                        }\n\n                        /* eslint-disable-next-line max-len */\n                        console.warn(`Basis failed to transcode image ${i}, level ${j}! Retrying to an uncompressed texture format!`);\n                        i = -1;\n                        fallbackMode = true;\n\n                        break;\n                    }\n\n                    imageResource.levelArray.push({\n                        levelID: j,\n                        levelWidth: width,\n                        levelHeight: height,\n                        levelBuffer: imageBuffer\n                    });\n                }\n\n                imageArray[i] = imageResource;\n            }\n\n            basisFile.close();\n            basisFile.delete();\n\n            return {\n                type: 'transcode',\n                requestID: message.requestID,\n                success: true,\n                basisFormat: !fallbackMode ? basisFormat : basisFallbackFormat,\n                imageArray\n            };\n        }\n    };\n\n    self.onmessage = (e: { data: Partial<IInitializeTranscoderMessage | ITranscodeMessage> }): void =>\n    {\n        const msg = e.data;\n        const response = messageHandlers[msg.type](msg as any);\n\n        if (response)\n        {\n            (self as any).postMessage(response);\n        }\n    };\n}\n","import { Runner } from '@pixi/runner';\nimport { BASIS_FORMATS } from './Basis';\nimport { ITranscodeResponse, TranscoderWorkerWrapper } from './TranscoderWorkerWrapper';\n\n/**\n * Worker class for transcoding *.basis files in background threads.\n *\n * To enable asynchronous transcoding, you need to provide the URL to the basis_universal transcoding\n * library.\n *\n * @memberof PIXI.BasisLoader\n */\nexport class TranscoderWorker\n{\n    // IMPLEMENTATION NOTE: TranscoderWorker tracks transcoding requests with a requestID; the worker can be issued\n    // multiple requests (once it is initialized) and the response contains the requestID of the triggering request. Based on\n    // the response, the transcodeAsync promise is fulfilled or rejected.\n\n    // TODO: Publish our own @pixi/basis package & set default URL to jsdelivr/cdnjs\n    /** URL for the script containing the basis_universal library. */\n    static bindingURL: string;\n    static jsSource: string;\n    static wasmSource: ArrayBuffer;\n\n    public static onTranscoderInitialized = new Runner('onTranscoderInitialized');\n\n    isInit: boolean;\n    load: number;\n    requests: { [id: number]: {\n        resolve: (data: ITranscodeResponse) => void,\n        reject: () => void\n    } } = {};\n\n    private static _workerURL: string;\n    private static _tempID = 0;\n\n    /** Generated URL for the transcoder worker script. */\n    static get workerURL(): string\n    {\n        if (!TranscoderWorker._workerURL)\n        {\n            let workerSource = TranscoderWorkerWrapper.toString();\n\n            const beginIndex = workerSource.indexOf('{');\n            const endIndex = workerSource.lastIndexOf('}');\n\n            workerSource = workerSource.slice(beginIndex + 1, endIndex);\n\n            if (TranscoderWorker.jsSource)\n            {\n                workerSource = `${TranscoderWorker.jsSource}\\n${workerSource}`;\n            }\n\n            TranscoderWorker._workerURL = URL.createObjectURL(new Blob([workerSource]));\n        }\n\n        return TranscoderWorker._workerURL;\n    }\n\n    protected worker: Worker;\n    protected initPromise: Promise<void>;\n    protected onInit: () => void;\n\n    constructor()\n    {\n        this.isInit = false;\n        this.load = 0;\n        this.initPromise = new Promise((resolve) => { this.onInit = resolve; });\n\n        if (!TranscoderWorker.wasmSource)\n        {\n            console.warn('PIXI.resources.BasisResource.TranscoderWorker has not been given the transcoder WASM binary!');\n        }\n\n        this.worker = new Worker(TranscoderWorker.workerURL);\n        this.worker.onmessage = this.onMessage;\n        this.worker.postMessage({\n            type: 'init',\n            jsSource: TranscoderWorker.jsSource,\n            wasmSource: TranscoderWorker.wasmSource\n        });\n    }\n\n    /** @returns a promise that is resolved when the web-worker is initialized */\n    initAsync(): Promise<void>\n    {\n        return this.initPromise;\n    }\n\n    /**\n     * Creates a promise that will resolve when the transcoding of a *.basis file is complete.\n     * @param basisData - *.basis file contents\n     * @param rgbaFormat - transcoding format for RGBA files\n     * @param rgbFormat - transcoding format for RGB files\n     * @returns a promise that is resolved with the transcoding response of the web-worker\n     */\n    async transcodeAsync(\n        basisData: Uint8Array,\n        rgbaFormat: BASIS_FORMATS,\n        rgbFormat: BASIS_FORMATS\n    ): Promise<ITranscodeResponse>\n    {\n        ++this.load;\n\n        const requestID = TranscoderWorker._tempID++;\n        const requestPromise = new Promise((resolve: (data: ITranscodeResponse) => void, reject: () => void) =>\n        {\n            this.requests[requestID] = {\n                resolve,\n                reject\n            };\n        });\n\n        this.worker.postMessage({\n            requestID,\n            basisData,\n            rgbaFormat,\n            rgbFormat,\n            type: 'transcode'\n        });\n\n        return requestPromise;\n    }\n\n    /**\n     * Handles responses from the web-worker\n     *\n     * @param e - a message event containing the transcoded response\n     */\n    protected onMessage = (e: MessageEvent): void =>\n    {\n        const data = e.data as ITranscodeResponse;\n\n        if (data.type === 'init')\n        {\n            if (!data.success)\n            {\n                throw new Error('BasisResource.TranscoderWorker failed to initialize.');\n            }\n\n            this.isInit = true;\n            this.onInit();\n        }\n        else if (data.type === 'transcode')\n        {\n            --this.load;\n\n            const requestID = data.requestID;\n\n            if (data.success)\n            {\n                this.requests[requestID].resolve(data);\n            }\n            else\n            {\n                this.requests[requestID].reject();\n            }\n\n            delete this.requests[requestID];\n        }\n    };\n\n    /**\n     * Loads the transcoder source code\n     *\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     * @returns A promise that resolves when both the js and wasm transcoders have been loaded.\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        const jsPromise = fetch(jsURL)\n            .then((res: Response) => res.text())\n            .then((text: string) => { TranscoderWorker.jsSource = text; });\n        const wasmPromise = fetch(wasmURL)\n            .then((res: Response) => res.arrayBuffer())\n            .then((arrayBuffer: ArrayBuffer) => { TranscoderWorker.wasmSource = arrayBuffer; });\n\n        return Promise.all([jsPromise, wasmPromise]).then((data) =>\n        {\n            TranscoderWorker.onTranscoderInitialized.emit();\n\n            return data;\n        });\n    }\n\n    /**\n     * Set the transcoder source code directly\n     *\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        TranscoderWorker.jsSource = jsSource;\n        TranscoderWorker.wasmSource = wasmSource;\n    }\n}\n","import { TYPES, MIPMAP_MODES, ALPHA_MODES, FORMATS } from '@pixi/constants';\nimport { BaseTexture, BufferResource, Texture } from '@pixi/core';\nimport { CompressedTextureResource, INTERNAL_FORMATS } from '@pixi/compressed-textures';\nimport {\n    BASIS_FORMATS,\n    BASIS_FORMAT_TO_INTERNAL_FORMAT,\n    INTERNAL_FORMAT_TO_BASIS_FORMAT,\n    BASIS_FORMATS_ALPHA,\n    BasisTextureExtensions,\n    BasisBinding,\n    BASIS_FORMAT_TO_TYPE\n} from './Basis';\nimport { TranscoderWorker } from './TranscoderWorker';\nimport { LoaderResource } from '@pixi/loaders';\n\nimport type { IResourceMetadata } from '@pixi/loaders';\nimport type { CompressedLevelBuffer } from '@pixi/compressed-textures';\n\ntype TranscodedResourcesArray = (Array<CompressedTextureResource> | Array<BufferResource>) & {\n    basisFormat: BASIS_FORMATS\n};\n\n/**\n * Result when calling registerCompressedTextures.\n * @ignore\n */\n type BasisTexturesResult = Pick<LoaderResource, 'textures' | 'texture'>;\n\nLoaderResource.setExtensionXhrType('basis', LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\n\n/**\n * Loader plugin for handling BASIS supercompressed texture files.\n *\n * To use this loader, you must bind the basis_universal WebAssembly transcoder. There are two ways of\n * doing this:\n *\n * 1. Adding a &lt;script&gt; tag to your HTML page to the transcoder bundle in this package, and serving\n * the WASM binary from the same location.\n *\n * ```js\n * // Copy ./node_modules/@pixi/basis/assets/basis_.wasm into your assets directory\n * // as well, so it is served from the same folder as the JavaScript!\n * &lt;script src=\"./node_modules/@pixi/basis/assets/basis_transcoder.js\" /&gt;\n * ```\n *\n * NOTE: `basis_transcoder.js` expects the WebAssembly binary to be named `basis_transcoder.wasm`.\n * NOTE-2: This method supports transcoding on the main-thread. Only use this if you have 1 or 2 *.basis\n * files.\n *\n * 2. Loading the transcoder source from a URL.\n *\n * ```js\n * // Use this if you to use the default CDN url for @pixi/basis\n * BasisLoader.loadTranscoder();\n *\n * // Use this if you want to serve the transcoder on your own\n * BasisLoader.loadTranscoder('./basis_transcoder.js', './basis_transcoder.wasm');\n * ```\n *\n * NOTE: This can only be used with web-workers.\n *\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\nexport class BasisLoader\n{\n    private static basisBinding: BasisBinding;\n    private static defaultRGBFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static defaultRGBAFormat: { basisFormat: BASIS_FORMATS, textureFormat: INTERNAL_FORMATS | TYPES };\n    private static fallbackMode = false;\n    private static workerPool: TranscoderWorker[] = [];\n\n    /**\n     * Transcodes the *.basis data when the data is loaded. If the transcoder is not bound yet, it\n     * will hook transcoding to {@link BasisResource#onTranscoderInitialized}.\n     *\n     * @see PIXI.Loader.loaderMiddleware\n     * @param resource - loader resource that is checked to see if it is a basis file\n     * @param next - callback Function to call when done\n     */\n    public static use(resource: LoaderResource, next: (...args: any[]) => void): void\n    {\n        if (resource.extension === 'basis' && resource.data)\n        {\n            if (!!BasisLoader.basisBinding || (!!BasisLoader.TranscoderWorker.wasmSource))\n            {\n                BasisLoader.transcode(resource, next);\n            }\n            else\n            {\n                TranscoderWorker.onTranscoderInitialized.add(() =>\n                {\n                    BasisLoader.transcode(resource, next);\n                });\n            }\n        }\n        else\n        {\n            next();\n        }\n    }\n\n    /**\n     * Runs transcoding and populates {@link imageArray}. It will run the transcoding in a web worker\n     * if they are available.\n     *\n     * @private\n     */\n    private static async transcode(resource: LoaderResource, next: (...args: any[]) => void): Promise<void>\n    {\n        try\n        {\n            const data: ArrayBuffer = resource.data;\n            let resources: TranscodedResourcesArray;\n\n            if (typeof Worker !== 'undefined' && BasisLoader.TranscoderWorker.wasmSource)\n            {\n                resources = await BasisLoader.transcodeAsync(data);\n            }\n            else\n            {\n                resources = BasisLoader.transcodeSync(data);\n            }\n\n            Object.assign(resource, BasisLoader.registerTextures(\n                resource.url,\n                resources,\n                resource.metadata\n            ));\n        }\n        catch (err)\n        {\n            next(err);\n\n            return;\n        }\n\n        next();\n    }\n\n    /**\n     * Creates textures and adds them to the texture cache\n     * @private\n     * @param url - url of the texture to be used as its ID for the texture cache\n     * @param resources - the transcoded resources\n     * @param metadata - resource metadata\n     */\n    private static registerTextures(\n        url: string,\n        resources: TranscodedResourcesArray,\n        metadata: IResourceMetadata\n    ): BasisTexturesResult\n    {\n        const result: BasisTexturesResult = {\n            textures: {},\n            texture: null,\n        };\n\n        if (!resources)\n        {\n            return result;\n        }\n\n        // Should be a valid TYPES, FORMATS for uncompressed basis formats\n        const type: TYPES = BASIS_FORMAT_TO_TYPE[resources.basisFormat];\n        const format: FORMATS = resources.basisFormat !== BASIS_FORMATS.cTFRGBA32 ? FORMATS.RGB : FORMATS.RGBA;\n        const resourceList = resources as Array<CompressedTextureResource | BufferResource>;\n\n        const textures = resourceList.map((resource) =>\n            (\n                new Texture(new BaseTexture(resource, Object.assign({\n                    mipmap: resource instanceof CompressedTextureResource && resource.levels > 1\n                        ? MIPMAP_MODES.ON_MANUAL\n                        : MIPMAP_MODES.OFF,\n                    alphaMode: ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,\n                    type,\n                    format\n                }, metadata)))\n            ));\n\n        textures.forEach((texture: Texture, i: number) =>\n        {\n            const { baseTexture } = texture;\n            const cacheID = `${url}-${i + 1}`;\n\n            BaseTexture.addToCache(baseTexture, cacheID);\n            Texture.addToCache(texture, cacheID);\n\n            if (i === 0)\n            {\n                BaseTexture.addToCache(baseTexture, url);\n                Texture.addToCache(texture, url);\n                result.texture = texture;\n            }\n\n            result.textures[cacheID] = texture;\n        });\n\n        return result;\n    }\n\n    /**\n     * Finds a suitable worker for transcoding and sends a transcoding request\n     *\n     * @private\n     * @async\n     */\n    private static async transcodeAsync(arrayBuffer: ArrayBuffer): Promise<TranscodedResourcesArray>\n    {\n        const workerPool = BasisLoader.workerPool;\n\n        let leastLoad = 0x10000000;\n        let worker = null;\n\n        for (let i = 0, j = workerPool.length; i < j; i++)\n        {\n            if (workerPool[i].load < leastLoad)\n            {\n                worker = workerPool[i];\n                leastLoad = worker.load;\n            }\n        }\n\n        if (!worker)\n        {\n            /* eslint-disable-next-line no-use-before-define */\n            worker = new TranscoderWorker();\n\n            workerPool.push(worker);\n        }\n\n        // Wait until worker is ready\n        await worker.initAsync();\n\n        const response = await worker.transcodeAsync(\n            new Uint8Array(arrayBuffer),\n            BasisLoader.defaultRGBAFormat.basisFormat,\n            BasisLoader.defaultRGBFormat.basisFormat\n        );\n\n        const basisFormat = response.basisFormat;\n        const imageArray = response.imageArray;\n\n        // whether it is an uncompressed format\n        const fallbackMode = basisFormat > 12;\n        let imageResources: TranscodedResourcesArray;\n\n        if (!fallbackMode)\n        {\n            const format = BASIS_FORMAT_TO_INTERNAL_FORMAT[response.basisFormat];\n\n            // HINT: this.imageArray is CompressedTextureResource[]\n            imageResources = new Array<CompressedTextureResource>(imageArray.length) as TranscodedResourcesArray;\n\n            for (let i = 0, j = imageArray.length; i < j; i++)\n            {\n                imageResources[i] = new CompressedTextureResource(null, {\n                    format,\n                    width: imageArray[i].width,\n                    height: imageArray[i].height,\n                    levelBuffers: imageArray[i].levelArray,\n                    levels: imageArray[i].levelArray.length\n                });\n            }\n        }\n        else\n        {\n            // TODO: BufferResource does not support manual mipmapping.\n            imageResources = imageArray.map((image) => new BufferResource(\n                new Uint16Array(image.levelArray[0].levelBuffer.buffer), {\n                    width: image.width,\n                    height: image.height\n                })\n            ) as TranscodedResourcesArray;\n        }\n\n        imageResources.basisFormat = basisFormat;\n\n        return imageResources;\n    }\n\n    /**\n     * Runs transcoding on the main thread.\n     *\n     * @private\n     */\n    private static transcodeSync(arrayBuffer: ArrayBuffer): TranscodedResourcesArray\n    {\n        const BASIS = BasisLoader.basisBinding;\n\n        const data = new Uint8Array(arrayBuffer);\n        const basisFile = new BASIS.BasisFile(data);\n        const imageCount = basisFile.getNumImages();\n        const hasAlpha = basisFile.getHasAlpha();\n\n        const basisFormat = hasAlpha\n            ? BasisLoader.defaultRGBAFormat.basisFormat\n            : BasisLoader.defaultRGBFormat.basisFormat;\n        const basisFallbackFormat = BASIS_FORMATS.cTFRGB565;\n        const imageResources = new Array<CompressedTextureResource | BufferResource>(imageCount);\n\n        let fallbackMode = BasisLoader.fallbackMode;\n\n        if (!basisFile.startTranscoding())\n        {\n            // #if _DEBUG\n            console.error(`Basis failed to start transcoding!`);\n            // #endif\n\n            basisFile.close();\n            basisFile.delete();\n\n            return null;\n        }\n\n        for (let i = 0; i < imageCount; i++)\n        {\n            // Don't transcode all mipmap levels in fallback mode!\n            const levels = !fallbackMode ? basisFile.getNumLevels(i) : 1;\n            const width = basisFile.getImageWidth(i, 0);\n            const height = basisFile.getImageHeight(i, 0);\n            const alignedWidth = (width + 3) & ~3;\n            const alignedHeight = (height + 3) & ~3;\n\n            const imageLevels = new Array<CompressedLevelBuffer>(levels);\n\n            // Transcode mipmap levels into \"imageLevels\"\n            for (let j = 0; j < levels; j++)\n            {\n                const levelWidth = basisFile.getImageWidth(i, j);\n                const levelHeight = basisFile.getImageHeight(i, j);\n                const byteSize = basisFile.getImageTranscodedSizeInBytes(\n                    i, 0, !fallbackMode ? basisFormat : basisFallbackFormat);\n\n                imageLevels[j] = {\n                    levelID: j,\n                    levelBuffer: new Uint8Array(byteSize),\n                    levelWidth,\n                    levelHeight,\n                };\n\n                if (!basisFile.transcodeImage(\n                    imageLevels[j].levelBuffer, i, 0, !fallbackMode ? basisFormat : basisFallbackFormat, false, false))\n                {\n                    if (fallbackMode)\n                    {\n                        // #if _DEBUG\n                        console.error(`Basis failed to transcode image ${i}, level ${0}!`);\n                        // #endif\n                        break;\n                    }\n                    else\n                    {\n                        // Try transcoding to an uncompressed format before giving up!\n                        // NOTE: We must start all over again as all Resources must be in compressed OR uncompressed.\n                        i = -1;\n                        fallbackMode = true;\n\n                        // #if _DEBUG\n                        /* eslint-disable-next-line max-len */\n                        console.warn(`Basis failed to transcode image ${i}, level ${0} to a compressed texture format. Retrying to an uncompressed fallback format!`);\n                        // #endif\n                        continue;\n                    }\n                }\n            }\n\n            let imageResource;\n\n            if (!fallbackMode)\n            {\n                imageResource = new CompressedTextureResource(null, {\n                    format: BASIS_FORMAT_TO_INTERNAL_FORMAT[basisFormat],\n                    width: alignedWidth,\n                    height: alignedHeight,\n                    levelBuffers: imageLevels,\n                    levels\n                });\n            }\n            else\n            {\n                // TODO: BufferResource doesn't support manual mipmap levels\n                imageResource = new BufferResource(\n                    new Uint16Array(imageLevels[0].levelBuffer.buffer), { width, height });\n            }\n\n            imageResources[i] = imageResource;\n        }\n\n        basisFile.close();\n        basisFile.delete();\n\n        const transcodedResources = imageResources as TranscodedResourcesArray;\n\n        transcodedResources.basisFormat = !fallbackMode ? basisFormat : basisFallbackFormat;\n\n        return transcodedResources;\n    }\n\n    /**\n     * Detects the available compressed texture formats on the device.\n     *\n     * @param extensions - extensions provided by a WebGL context\n     * @ignore\n     */\n    static autoDetectFormats(extensions?: Partial<BasisTextureExtensions>): void\n    {\n        // Auto-detect WebGL compressed-texture extensions\n        if (!extensions)\n        {\n            const canvas = document.createElement('canvas');\n            const gl = canvas.getContext('webgl');\n\n            if (!gl)\n            {\n                console.error('WebGL not available for BASIS transcoding. Silently failing.');\n\n                return;\n            }\n\n            extensions = {\n                s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n                s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), /* eslint-disable-line camelcase */\n                etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n                etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n                pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                    || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n                atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n                astc: gl.getExtension('WEBGL_compressed_texture_astc')\n            };\n        }\n\n        // Discover the available texture formats\n        const supportedFormats: { [id: string]: INTERNAL_FORMATS } = {};\n\n        for (const key in extensions)\n        {\n            const extension = (extensions as any)[key];\n\n            if (!extension)\n            {\n                continue;\n            }\n\n            Object.assign(supportedFormats, Object.getPrototypeOf(extension));\n        }\n\n        // Set the default alpha/non-alpha output formats for basisu transcoding\n        for (let i = 0; i < 2; i++)\n        {\n            const detectWithAlpha = !!i;\n            let internalFormat: number;\n            let basisFormat: number;\n\n            for (const id in supportedFormats)\n            {\n                internalFormat = supportedFormats[id];\n                basisFormat = INTERNAL_FORMAT_TO_BASIS_FORMAT[internalFormat];\n\n                if (basisFormat !== undefined)\n                {\n                    if ((detectWithAlpha && BASIS_FORMATS_ALPHA[basisFormat])\n                        || (!detectWithAlpha && !BASIS_FORMATS_ALPHA[basisFormat]))\n                    {\n                        break;\n                    }\n                }\n            }\n\n            if (internalFormat)\n            {\n                BasisLoader[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: internalFormat,\n                    basisFormat,\n                };\n            }\n            else\n            {\n                BasisLoader[detectWithAlpha ? 'defaultRGBAFormat' : 'defaultRGBFormat'] = {\n                    textureFormat: TYPES.UNSIGNED_SHORT_5_6_5,\n                    basisFormat: BASIS_FORMATS.cTFRGB565\n                };\n\n                BasisLoader.fallbackMode = true;\n            }\n        }\n    }\n\n    /**\n     * Binds the basis_universal transcoder to decompress *.basis files. You must initialize the transcoder library yourself.\n     *\n     * ```js\n     * import { BasisLoader } from '@pixi/basis';\n     * import { Loader } from '@pixi/loaders';\n     *\n     * // window.BASIS() returns a Promise-like object\n     * window.BASIS().then((basisLibrary) =>\n     * {\n     *     // Initialize basis-library; otherwise, transcoded results maybe corrupt!\n     *     basisLibrary.initializeBasis();\n     *\n     *     // Bind BasisLoader to the transcoder\n     *     BasisLoader.bindTranscoder(basisLibrary);\n     * });\n     * ```\n     *\n     * @param basisLibrary - the initialized transcoder library\n     * @private\n     */\n    static bindTranscoder(basisLibrary: BasisBinding): void\n    {\n        BasisLoader.basisBinding = basisLibrary;\n    }\n\n    /**\n     * Loads the transcoder source code for use in {@link PIXI.BasisLoader.TranscoderWorker}.\n     *\n     * @private\n     * @param jsURL - URL to the javascript basis transcoder\n     * @param wasmURL - URL to the wasm basis transcoder\n     */\n    static loadTranscoder(jsURL: string, wasmURL: string): Promise<[void, void]>\n    {\n        return BasisLoader.TranscoderWorker.loadTranscoder(jsURL, wasmURL);\n    }\n\n    /**\n     * Set the transcoder source code directly\n     *\n     * @private\n     * @param jsSource - source for the javascript basis transcoder\n     * @param wasmSource - source for the wasm basis transcoder\n     */\n    static setTranscoder(jsSource: string, wasmSource: ArrayBuffer): void\n    {\n        BasisLoader.TranscoderWorker.setTranscoder(jsSource, wasmSource);\n    }\n\n    static TranscoderWorker: typeof TranscoderWorker = TranscoderWorker;\n\n    static get TRANSCODER_WORKER_POOL_LIMIT(): number\n    {\n        return this.workerPool.length || 1;\n    }\n\n    static set TRANSCODER_WORKER_POOL_LIMIT(limit: number)\n    {\n        // TODO: Destroy workers?\n        for (let i = this.workerPool.length; i < limit; i++)\n        {\n            this.workerPool[i] = new TranscoderWorker();\n            this.workerPool[i].initAsync();\n        }\n    }\n}\n\n// Auto-detect compressed texture formats once @pixi/basis is imported!\nBasisLoader.autoDetectFormats();\n","import { Loader } from '@pixi/loaders';\nimport { BasisLoader } from './BasisLoader';\n\nexport * from './Basis';\nexport * from './BasisLoader';\n\n// parse any BASIS supercompressed files into textures\nLoader.registerPlugin(BasisLoader);\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","pop","length","push","BASIS_FORMATS","BASIS_FORMAT_TO_INTERNAL_FORMAT","cTFETC1","INTERNAL_FORMATS","COMPRESSED_RGB_ETC1_WEBGL","_a","cTFBC1","COMPRESSED_RGB_S3TC_DXT1_EXT","cTFBC3","COMPRESSED_RGBA_S3TC_DXT5_EXT","cTFPVRTC1_4_RGB","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","cTFPVRTC1_4_RGBA","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","cTFATC_RGB","COMPRESSED_RGB_ATC_WEBGL","cTFASTC_4x4","COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL","BASIS_FORMAT_TO_TYPE","cTFRGBA32","TYPES","UNSIGNED_BYTE","_b","cTFRGB565","UNSIGNED_SHORT_5_6_5","cTFRGBA4444","UNSIGNED_SHORT_4_4_4_4","INTERNAL_FORMAT_TO_BASIS_FORMAT","Object","keys","map","key","Number","reduce","reverseMap","basisFormat","BASIS_FORMATS_ALPHA","_c","TranscoderWorkerWrapper","basisBinding","messageHandlers","init","message","self","BASIS","wasmBinary","wasmSource","basisLibrary","initializeBasis","postMessage","type","success","console","warn","transcode","data","basisData","basisFile","BasisFile","imageCount","getNumImages","getHasAlpha","rgbaFormat","rgbFormat","imageArray","Array","fallbackMode","startTranscoding","close","delete","requestID","i","levels","getNumLevels","imageResource","imageID","levelArray","width","height","j","format","getImageWidth","getImageHeight","byteSize","getImageTranscodedSizeInBytes","alignedWidth","alignedHeight","imageBuffer","Uint8Array","transcodeImage","error","levelID","levelWidth","levelHeight","levelBuffer","onmessage","msg","response","Error","_this","isInit","onInit","load","requests","initPromise","TranscoderWorker","worker","Worker","workerURL","onMessage","jsSource","_workerURL","workerSource","toString","beginIndex","indexOf","endIndex","lastIndexOf","slice","URL","createObjectURL","Blob","_tempID","requestPromise","jsURL","wasmURL","jsPromise","fetch","res","text","wasmPromise","arrayBuffer","all","onTranscoderInitialized","emit","Runner","LoaderResource","setExtensionXhrType","XHR_RESPONSE_TYPE","BUFFER","BasisLoader","resource","extension","add","resources","transcodeAsync","transcodeSync","assign","registerTextures","url","metadata","err_1","textures","texture","FORMATS","RGB","RGBA","Texture","BaseTexture","mipmap","CompressedTextureResource","MIPMAP_MODES","ON_MANUAL","OFF","alphaMode","ALPHA_MODES","NO_PREMULTIPLIED_ALPHA","forEach","baseTexture","cacheID","addToCache","workerPool","leastLoad","initAsync","defaultRGBAFormat","defaultRGBFormat","imageResources","image","BufferResource","Uint16Array","buffer","levelBuffers","basisFallbackFormat","imageLevels","transcodedResources","extensions","gl","document","createElement","getContext","s3tc","getExtension","s3tc_sRGB","etc","etc1","pvrtc","atc","astc","supportedFormats","getPrototypeOf","detectWithAlpha","internalFormat","id","undefined","textureFormat","loadTranscoder","setTranscoder","limit","autoDetectFormats","Loader","registerPlugin"],"mappings":";;;;;;;yQAiEO,SAASA,UAAUC,EAASC,EAAYC,EAAGC,GAC9C,OAAO,IAAKD,IAAMA,EAAIE,UAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUC,GAAS,IAAMC,EAAKN,EAAUO,KAAKF,IAAW,MAAOG,GAAKL,EAAOK,IACpF,SAASC,EAASJ,GAAS,IAAMC,EAAKN,EAAiB,MAAEK,IAAW,MAAOG,GAAKL,EAAOK,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOT,EAAQQ,EAAOL,OAAS,IAAIN,EAAE,SAAUG,GAAWA,EAAQQ,EAAOL,SAAWO,KAAKR,EAAWK,GACnIH,GAAMN,EAAYA,EAAUa,MAAMhB,EAASC,GAAc,KAAKS,UAI/D,SAASO,YAAYjB,EAASkB,GACjC,IAAsGC,EAAGC,EAAGC,EAAGC,EAA3GC,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAPJ,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,IAAOK,KAAM,GAAIC,IAAK,IAChG,OAAOL,EAAI,CAAEZ,KAAMkB,EAAK,GAAIC,MAASD,EAAK,GAAIE,OAAUF,EAAK,IAAwB,mBAAXG,SAA0BT,EAAES,OAAOC,UAAY,WAAa,OAAOC,OAAUX,EACvJ,SAASM,EAAKM,GAAK,OAAO,SAAUC,GAAK,OACzC,SAAcC,GACV,GAAIjB,EAAG,MAAM,IAAIkB,UAAU,mCAC3B,KAAOd,GAAG,IACN,GAAIJ,EAAI,EAAGC,IAAMC,EAAY,EAARe,EAAG,GAAShB,EAAU,OAAIgB,EAAG,GAAKhB,EAAS,SAAOC,EAAID,EAAU,SAAMC,EAAEiB,KAAKlB,GAAI,GAAKA,EAAEV,SAAWW,EAAIA,EAAEiB,KAAKlB,EAAGgB,EAAG,KAAKtB,KAAM,OAAOO,EAE3J,OADID,EAAI,EAAGC,IAAGe,EAAK,CAAS,EAARA,EAAG,GAAQf,EAAEb,QACzB4B,EAAG,IACP,KAAK,EAAG,KAAK,EAAGf,EAAIe,EAAI,MACxB,KAAK,EAAc,OAAXb,EAAEC,QAAgB,CAAEhB,MAAO4B,EAAG,GAAItB,MAAM,GAChD,KAAK,EAAGS,EAAEC,QAASJ,EAAIgB,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKb,EAAEI,IAAIY,MAAOhB,EAAEG,KAAKa,MAAO,SACxC,QACI,KAAkBlB,GAAZA,EAAIE,EAAEG,MAAYc,OAAS,GAAKnB,EAAEA,EAAEmB,OAAS,MAAkB,IAAVJ,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEb,EAAI,EAAG,SACjG,GAAc,IAAVa,EAAG,MAAcf,GAAMe,EAAG,GAAKf,EAAE,IAAMe,EAAG,GAAKf,EAAE,IAAM,CAAEE,EAAEC,MAAQY,EAAG,GAAI,MAC9E,GAAc,IAAVA,EAAG,IAAYb,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIA,EAAIe,EAAI,MAC7D,GAAIf,GAAKE,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIE,EAAEI,IAAIc,KAAKL,GAAK,MACvDf,EAAE,IAAIE,EAAEI,IAAIY,MAChBhB,EAAEG,KAAKa,MAAO,SAEtBH,EAAKlB,EAAKoB,KAAKtC,EAASuB,GAC1B,MAAOZ,GAAKyB,EAAK,CAAC,EAAGzB,GAAIS,EAAI,UAAeD,EAAIE,EAAI,EACtD,GAAY,EAARe,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAE5B,MAAO4B,EAAG,GAAKA,EAAG,QAAK,EAAQtB,MAAM,GArB9BL,CAAK,CAACyB,EAAGC,OC7E7D,SAWYO,GACRA,yBACAA,yBACAA,uBACAA,uBACAA,uBACAA,uBACAA,uBACAA,yCACAA,2CACAA,kCACAA,gCACAA,wEACAA,8BACAA,8BACAA,8BACAA,kCA3BJ,CAWYA,wBAAAA,+BAyBCC,yCACRD,sBAAcE,SAAUC,oCAAiBC,0BAC1CC,GAACL,sBAAcM,QAASH,oCAAiBI,6BACzCF,GAACL,sBAAcQ,QAASL,oCAAiBM,8BACzCJ,GAACL,sBAAcU,iBAAkBP,oCAAiBQ,gCAClDN,GAACL,sBAAcY,kBAAmBT,oCAAiBU,iCACnDR,GAACL,sBAAcc,YAAaX,oCAAiBY,yBAC7CV,GAACL,sBAAcgB,aAAcb,oCAAiBc,iDAYrCC,8BACRlB,sBAAcmB,WAAYC,gBAAMC,cACjCC,GAACtB,sBAAcuB,WAAYH,gBAAMI,qBACjCF,GAACtB,sBAAcyB,aAAcL,gBAAMM,2BAQ1BC,gCACNC,OAAOC,KAAK5B,iCACV6B,IAAI,SAACC,GAAgB,OAAAC,OAAOD,KAC5BE,OAAO,SAACC,EAAiBC,GAItB,OAFAD,EAAYjC,gCAAwCkC,IAAgBA,EAE7DD,GACR,IAOEE,6BACRpC,sBAAcQ,SAAS,EACxB6B,GAACrC,sBAAcY,mBAAmB,EAClCyB,GAACrC,sBAAcgB,cAAc,MCTjC,SAAgBsB,0BAEZ,IAAIC,EAEEC,EAAkB,CACpBC,KAAM,SAACC,GAEH,OAAKC,KAAKC,OAUVD,KAAKC,MAAM,CAAEC,WAAYH,EAAQI,aAAczE,KAAK,SAAC0E,GAEjDA,EAAaC,kBACbT,EAAeQ,EAEdJ,KAAaM,YAAY,CACtBC,KAAM,OACNC,SAAS,MAIV,OAnBHC,QAAQC,KAAK,+BAEN,CACHH,KAAM,OACNC,SAAS,KAiBrBG,UAAA,SAAUZ,GAEN,IAGMa,EAHYb,EAAQc,UAIpBC,EAAY,IAHJlB,EAGcmB,UAAUH,GAChCI,EAAaF,EAAUG,eAGvBzB,EAFWsB,EAAUI,cAGrBnB,EAAQoB,WACRpB,EAAQqB,UAERC,EAAa,IAAIC,MAAMN,GAEzBO,GAAe,EAEnB,IAAKT,EAAUU,mBAKX,OAHAV,EAAUW,QACVX,EAAUY,SAEH,CACHnB,KAAM,YACNoB,UAAW5B,EAAQ4B,UACnBnB,SAAS,EACTa,WAAY,MAIpB,IAAK,IAAIO,EAAI,EAAGA,EAAIZ,EAAYY,IAChC,CAcI,IAbA,IAAMC,EAASf,EAAUgB,aAAaF,GAChCG,EAAkC,CACpCC,QAASJ,EACTK,WAAY,IAAIX,MAMhBY,MAAO,KACPC,OAAQ,MAGHC,EAAI,EAAGA,EAAIP,EAAQO,IAC5B,CACI,IAAMC,EAAUd,EAnCI,GAmCW/B,EAEzB0C,EAAQpB,EAAUwB,cAAcV,EAAGQ,GACnCD,EAASrB,EAAUyB,eAAeX,EAAGQ,GACrCI,EAAW1B,EAAU2B,8BAA8Bb,EAAGQ,EAAGC,GAEzDK,EAAgBR,EAAQ,GAAK,EAC7BS,EAAiBR,EAAS,GAAK,EAG3B,IAANC,IAEAL,EAAcG,MAAQQ,EACtBX,EAAcI,OAASQ,GAG3B,IAAMC,EAAc,IAAIC,WAAWL,GAEnC,IAAK1B,EAAUgC,eAAeF,EAAahB,EAAGQ,EAAGC,GAAQ,GAAO,GAChE,CACI,GAAId,EAKA,OAFAd,QAAQsC,MAAM,mCAAmCnB,aAAYQ,OAEtD,CAAE7B,KAAM,YAAaoB,UAAW5B,EAAQ4B,UAAWnB,SAAS,GAIvEC,QAAQC,KAAK,mCAAmCkB,aAAYQ,mDAC5DR,GAAK,EACLL,GAAe,EAEf,MAGJQ,EAAcE,WAAW7E,KAAK,CAC1B4F,QAASZ,EACTa,WAAYf,EACZgB,YAAaf,EACbgB,YAAaP,IAIrBvB,EAAWO,GAAKG,EAMpB,OAHAjB,EAAUW,QACVX,EAAUY,SAEH,CACHnB,KAAM,YACNoB,UAAW5B,EAAQ4B,UACnBnB,SAAS,EACThB,YAAc+B,EAzFU,GAyFK/B,EAC7B6B,gBAKZrB,KAAKoD,UAAY,SAAC9H,GAEd,IAAM+H,EAAM/H,EAAEsF,KACR0C,EAAWzD,EAAgBwD,EAAI9C,MAAM8C,GAEvCC,GAECtD,KAAaM,YAAYgD,IChNtC,gCAmDI,aAAA,WAnCA1G,cAGM,GAkGIA,eAAY,SAACtB,GAEnB,IAAMsF,EAAOtF,EAAEsF,KAEf,GAAkB,SAAdA,EAAKL,KACT,CACI,IAAKK,EAAKJ,QAEN,MAAM,IAAI+C,MAAM,wDAGpBC,EAAKC,QAAS,EACdD,EAAKE,cAEJ,GAAkB,cAAd9C,EAAKL,KACd,GACMiD,EAAKG,KAEP,IAAMhC,EAAYf,EAAKe,UAEnBf,EAAKJ,QAELgD,EAAKI,SAASjC,GAAW3G,QAAQ4F,GAIjC4C,EAAKI,SAASjC,GAAW1G,gBAGtBuI,EAAKI,SAASjC,KA7FzB/E,KAAK6G,QAAS,EACd7G,KAAK+G,KAAO,EACZ/G,KAAKiH,YAAc,IAAI9I,QAAQ,SAACC,GAAcwI,EAAKE,OAAS1I,IAEvD8I,EAAiB3D,YAElBM,QAAQC,KAAK,gGAGjB9D,KAAKmH,OAAS,IAAIC,OAAOF,EAAiBG,WAC1CrH,KAAKmH,OAAOX,UAAYxG,KAAKsH,UAC7BtH,KAAKmH,OAAOzD,YAAY,CACpBC,KAAM,OACN4D,SAAUL,EAAiBK,SAC3BhE,WAAY2D,EAAiB3D,aAsHzC,OAhKIlB,sBAAW6E,mBAAX,WAEI,IAAKA,EAAiBM,WACtB,CACI,IAAIC,EAAe1E,wBAAwB2E,WAErCC,EAAaF,EAAaG,QAAQ,KAClCC,EAAWJ,EAAaK,YAAY,KAE1CL,EAAeA,EAAaM,MAAMJ,EAAa,EAAGE,GAE9CX,EAAiBK,WAEjBE,EAAkBP,EAAiBK,cAAaE,GAGpDP,EAAiBM,WAAaQ,IAAIC,gBAAgB,IAAIC,KAAK,CAACT,KAGhE,OAAOP,EAAiBM,4CA4B5BN,sBAAA,WAEI,OAAOlH,KAAKiH,aAUVC,2BAAN,SACIjD,EACAM,EACAC,gCACDrG,sEAqBC,QAnBE6B,KAAK+G,KAEDhC,EAAYmC,EAAiBiB,UAC7BC,EAAiB,IAAIjK,QAAQ,SAACC,EAA6CC,GAE7EuI,EAAKI,SAASjC,GAAa,CACvB3G,UACAC,YAIR2B,KAAKmH,OAAOzD,YAAY,CACpBqB,YACAd,YACAM,aACAC,YACAb,KAAM,iBAGHyE,QAgDJlB,iBAAP,SAAsBmB,EAAeC,GAEjC,IAAMC,EAAYC,MAAMH,GACnBvJ,KAAK,SAAC2J,GAAkB,OAAAA,EAAIC,SAC5B5J,KAAK,SAAC4J,GAAmBxB,EAAiBK,SAAWmB,IACpDC,EAAcH,MAAMF,GACrBxJ,KAAK,SAAC2J,GAAkB,OAAAA,EAAIG,gBAC5B9J,KAAK,SAAC8J,GAA+B1B,EAAiB3D,WAAaqF,IAExE,OAAOzK,QAAQ0K,IAAI,CAACN,EAAWI,IAAc7J,KAAK,SAACkF,GAI/C,OAFAkD,EAAiB4B,wBAAwBC,OAElC/E,KAURkD,gBAAP,SAAqBK,EAAkBhE,GAEnC2D,EAAiBK,SAAWA,EAC5BL,EAAiB3D,WAAaA,GA3KpB2D,0BAA0B,IAAI8B,cAAO,2BAUpC9B,UAAU,OCN7B+B,uBAAeC,oBAAoB,QAASD,uBAAeE,kBAAkBC,QAqC7E,2BAAA,cA0eA,OA1dkBC,MAAd,SAAkBC,EAA0B7K,GAEb,UAAvB6K,EAASC,WAAyBD,EAAStF,KAErCqF,EAAYrG,cAAmBqG,EAAYnC,iBAAiB3D,WAE9D8F,EAAYtF,UAAUuF,EAAU7K,GAIhCyI,iBAAiB4B,wBAAwBU,IAAI,WAEzCH,EAAYtF,UAAUuF,EAAU7K,KAMxCA,KAUa4K,YAArB,SAA+BC,EAA0B7K,gCAAiCN,qHAI5E6F,EAAoBsF,EAAStF,KAC/ByF,SAEkB,oBAAXrC,QAA0BiC,EAAYnC,iBAAiB3D,cAE5C8F,EAAYK,eAAe1F,wBAA7CyF,EAAY3I,sBAIZ2I,EAAYJ,EAAYM,cAAc3F,2BAG1C3B,OAAOuH,OAAON,EAAUD,EAAYQ,iBAChCP,EAASQ,IACTL,EACAH,EAASS,wBAOb,kBAFAtL,EAAKuL,qBAKTvL,cAUW4K,mBAAf,SACIS,EACAL,EACAM,GAGA,IAAMnL,EAA8B,CAChCqL,SAAU,GACVC,QAAS,MAGb,IAAKT,EAED,OAAO7K,EAIX,IAAM+E,EAAchC,qBAAqB8H,EAAU7G,aAC7C6C,EAAkBgE,EAAU7G,cAAgBnC,sBAAcmB,UAAYuI,kBAAQC,IAAMD,kBAAQE,KAiClG,OAhCqBZ,EAESlH,IAAI,SAAC+G,GAC/B,WACQgB,aAAQ,IAAIC,iBAAYjB,EAAUjH,OAAOuH,OAAO,CAChDY,OAAQlB,aAAoBmB,8CAA6BnB,EAASrE,OAAS,EACrEyF,uBAAaC,UACbD,uBAAaE,IACnBC,UAAWC,sBAAYC,uBACvBpH,OACA8B,UACDsE,OAGFiB,QAAQ,SAACd,EAAkBlF,GAExB,IAAAiG,EAAgBf,cAClBgB,EAAapB,OAAO9E,EAAI,GAE9BuF,iBAAYY,WAAWF,EAAaC,GACpCZ,aAAQa,WAAWjB,EAASgB,GAElB,IAANlG,IAEAuF,iBAAYY,WAAWF,EAAanB,GACpCQ,aAAQa,WAAWjB,EAASJ,GAC5BlL,EAAOsL,QAAUA,GAGrBtL,EAAOqL,SAASiB,GAAWhB,IAGxBtL,GASUyK,iBAArB,SAAoCT,gCAA2BzK,sGAO3D,IALMiN,EAAa/B,EAAY+B,WAE3BC,EAAY,UACZlE,EAAS,KAEJnC,EAAI,EAAGQ,EAAI4F,EAAW7K,OAAQyE,EAAIQ,EAAGR,IAEtCoG,EAAWpG,GAAG+B,KAAOsE,IAErBlE,EAASiE,EAAWpG,GACpBqG,EAAYlE,EAAOJ,MAa3B,OATKI,IAGDA,EAAS,IAAID,iBAEbkE,EAAW5K,KAAK2G,OAIdA,EAAOmE,oBAEI,OAFjBxK,YAEuBqG,EAAOuC,eAC1B,IAAIzD,WAAW2C,GACfS,EAAYkC,kBAAkB3I,YAC9ByG,EAAYmC,iBAAiB5I,qBAUjC,GAbM8D,EAAW5F,SAMX8B,EAAc8D,EAAS9D,YACvB6B,EAAaiC,EAASjC,WAGP7B,EAAc,GAwB/B6I,EAAiBhH,EAAWlC,IAAI,SAACmJ,GAAU,OAAA,IAAIC,oBAC3C,IAAIC,YAAYF,EAAMrG,WAAW,GAAGkB,YAAYsF,QAAS,CACrDvG,MAAOoG,EAAMpG,MACbC,OAAQmG,EAAMnG,gBAjBtB,IALME,EAAS/E,gCAAgCgG,EAAS9D,aAGxD6I,EAAiB,IAAI/G,MAAiCD,EAAWlE,QAExDyE,EAAI,EAAGQ,EAAIf,EAAWlE,OAAQyE,EAAIQ,EAAGR,IAE1CyG,EAAezG,GAAK,IAAIyF,6CAA0B,KAAM,CACpDhF,SACAH,MAAOb,EAAWO,GAAGM,MACrBC,OAAQd,EAAWO,GAAGO,OACtBuG,aAAcrH,EAAWO,GAAGK,WAC5BJ,OAAQR,EAAWO,GAAGK,WAAW9E,SAiB7C,OAFAkL,EAAe7I,YAAcA,KAEtB6I,SAQIpC,gBAAf,SAA6BT,GAEzB,IAAMvF,EAAQgG,EAAYrG,aAEpBgB,EAAO,IAAIiC,WAAW2C,GACtB1E,EAAY,IAAIb,EAAMc,UAAUH,GAChCI,EAAaF,EAAUG,eAGvBzB,EAFWsB,EAAUI,cAGrB+E,EAAYkC,kBAAkB3I,YAC9ByG,EAAYmC,iBAAiB5I,YAC7BmJ,EAAsBtL,sBAAcuB,UACpCyJ,EAAiB,IAAI/G,MAAkDN,GAEzEO,EAAe0E,EAAY1E,aAE/B,IAAKT,EAAUU,mBASX,OAHAV,EAAUW,QACVX,EAAUY,SAEH,KAGX,IAAK,IAAIE,EAAI,EAAGA,EAAIZ,EAAYY,IAChC,CAWI,IATA,IAAMC,EAAUN,EAA2C,EAA5BT,EAAUgB,aAAaF,GAChDM,EAAQpB,EAAUwB,cAAcV,EAAG,GACnCO,EAASrB,EAAUyB,eAAeX,EAAG,GACrCc,EAAgBR,EAAQ,GAAK,EAC7BS,EAAiBR,EAAS,GAAK,EAE/ByG,EAAc,IAAItH,MAA6BO,GAG5CO,EAAI,EAAGA,EAAIP,EAAQO,IAC5B,CACI,IAAMa,EAAanC,EAAUwB,cAAcV,EAAGQ,GACxCc,EAAcpC,EAAUyB,eAAeX,EAAGQ,GAC1CI,EAAW1B,EAAU2B,8BACvBb,EAAG,EAAIL,EAA6BoH,EAAdnJ,GAS1B,GAPAoJ,EAAYxG,GAAK,CACbY,QAASZ,EACTe,YAAa,IAAIN,WAAWL,GAC5BS,aACAC,eAGCpC,EAAUgC,eACX8F,EAAYxG,GAAGe,YAAavB,EAAG,EAAIL,EAA6BoH,EAAdnJ,GAAmC,GAAO,QADhG,CAGI,GAAI+B,EAKA,MAMAK,GAAK,EACLL,GAAe,GAW3B,IAAIQ,SAeAA,EAbCR,EAae,IAAIgH,oBAChB,IAAIC,YAAYI,EAAY,GAAGzF,YAAYsF,QAAS,CAAEvG,QAAOC,WAZjD,IAAIkF,6CAA0B,KAAM,CAChDhF,OAAQ/E,gCAAgCkC,GACxC0C,MAAOQ,EACPP,OAAQQ,EACR+F,aAAcE,EACd/G,WAURwG,EAAezG,GAAKG,EAGxBjB,EAAUW,QACVX,EAAUY,SAEV,IAAMmH,EAAsBR,EAI5B,OAFAQ,EAAoBrJ,YAAe+B,EAA6BoH,EAAdnJ,EAE3CqJ,GASJ5C,oBAAP,SAAyB6C,GAGrB,IAAKA,EACL,CACI,IACMC,EADSC,SAASC,cAAc,UACpBC,WAAW,SAE7B,IAAKH,EAID,YAFAtI,QAAQsC,MAAM,gEAKlB+F,EAAa,CACTK,KAAMJ,EAAGK,aAAa,iCACtBC,UAAWN,EAAGK,aAAa,sCAC3BE,IAAKP,EAAGK,aAAa,gCACrBG,KAAMR,EAAGK,aAAa,iCACtBI,MAAOT,EAAGK,aAAa,mCAChBL,EAAGK,aAAa,yCACvBK,IAAKV,EAAGK,aAAa,gCACrBM,KAAMX,EAAGK,aAAa,kCAK9B,IAAMO,EAAuD,GAE7D,IAAK,IAAMvK,KAAO0J,EAClB,CACI,IAAM3C,EAAa2C,EAAmB1J,GAEjC+G,GAKLlH,OAAOuH,OAAOmD,EAAkB1K,OAAO2K,eAAezD,IAI1D,IAAK,IAAIvE,EAAI,EAAGA,EAAI,EAAGA,IACvB,CACI,IAAMiI,IAAoBjI,EACtBkI,SACAtK,SAEJ,IAAK,IAAMuK,KAAMJ,EAKb,QAAoBK,KAFpBxK,EAAcR,gCADd8K,EAAiBH,EAAiBI,OAKzBF,GAAmBpK,oBAAoBD,KACnCqK,IAAoBpK,oBAAoBD,IAE7C,MAKRsK,EAEA7D,EAAY4D,EAAkB,oBAAsB,oBAAsB,CACtEI,cAAeH,EACftK,gBAKJyG,EAAY4D,EAAkB,oBAAsB,oBAAsB,CACtEI,cAAexL,gBAAMI,qBACrBW,YAAanC,sBAAcuB,WAG/BqH,EAAY1E,cAAe,KA0BhC0E,iBAAP,SAAsB7F,GAElB6F,EAAYrG,aAAeQ,GAUxB6F,iBAAP,SAAsBhB,EAAeC,GAEjC,OAAOe,EAAYnC,iBAAiBoG,eAAejF,EAAOC,IAUvDe,gBAAP,SAAqB9B,EAAkBhE,GAEnC8F,EAAYnC,iBAAiBqG,cAAchG,EAAUhE,IAKzDlB,sBAAWgH,sCAAX,WAEI,OAAOrJ,KAAKoL,WAAW7K,QAAU,OAGrC,SAAwCiN,GAGpC,IAAK,IAAIxI,EAAIhF,KAAKoL,WAAW7K,OAAQyE,EAAIwI,EAAOxI,IAE5ChF,KAAKoL,WAAWpG,GAAK,IAAIkC,iBACzBlH,KAAKoL,WAAWpG,GAAGsG,6CAleZjC,gBAAe,EACfA,aAAiC,GAodzCA,mBAA4CnC,sBAmBvDmC,YAAYoE,oBCviBZC,eAAOC,eAAetE"}