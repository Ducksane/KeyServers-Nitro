(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Utils", "tsparticles-engine"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkInstance = void 0;
    const Utils_1 = require("./Utils");
    const tsparticles_engine_1 = require("tsparticles-engine");
    class LinkInstance {
        constructor(container) {
            this.container = container;
        }
        drawParticle(context, particle) {
            const linkParticle = particle, container = this.container, particles = container.particles, pOptions = particle.options;
            if (linkParticle.links.length <= 0) {
                return;
            }
            context.save();
            const p1Links = linkParticle.links.filter((l) => {
                const linkFreq = container.particles.getLinkFrequency(linkParticle, l.destination);
                return linkFreq <= pOptions.links.frequency;
            });
            for (const link of p1Links) {
                const p2 = link.destination;
                if (pOptions.links.triangles.enable) {
                    const links = p1Links.map((l) => l.destination), vertices = p2.links.filter((t) => {
                        const linkFreq = container.particles.getLinkFrequency(p2, t.destination);
                        return linkFreq <= p2.options.links.frequency && links.indexOf(t.destination) >= 0;
                    });
                    if (vertices.length) {
                        for (const vertex of vertices) {
                            const p3 = vertex.destination, triangleFreq = particles.getTriangleFrequency(linkParticle, p2, p3);
                            if (triangleFreq > pOptions.links.triangles.frequency) {
                                continue;
                            }
                            this.drawLinkTriangle(linkParticle, link, vertex);
                        }
                    }
                }
                if (link.opacity > 0 && container.retina.linksWidth > 0) {
                    this.drawLinkLine(linkParticle, link);
                }
            }
            context.restore();
        }
        particleCreated(particle) {
            const linkParticle = particle;
            linkParticle.links = [];
        }
        particleDestroyed(particle) {
            const linkParticle = particle;
            linkParticle.links = [];
        }
        drawLinkLine(p1, link) {
            const container = this.container, options = container.actualOptions, p2 = link.destination, pos1 = p1.getPosition(), pos2 = p2.getPosition();
            let opacity = link.opacity;
            container.canvas.draw((ctx) => {
                var _a, _b, _c;
                let colorLine;
                const twinkle = (_a = p1.options.twinkle) === null || _a === void 0 ? void 0 : _a.lines;
                if (twinkle === null || twinkle === void 0 ? void 0 : twinkle.enable) {
                    const twinkleFreq = twinkle.frequency, twinkleRgb = (0, tsparticles_engine_1.rangeColorToRgb)(twinkle.color), twinkling = Math.random() < twinkleFreq;
                    if (twinkling && twinkleRgb) {
                        colorLine = twinkleRgb;
                        opacity = (0, tsparticles_engine_1.getRangeValue)(twinkle.opacity);
                    }
                }
                if (!colorLine) {
                    const linksOptions = p1.options.links, linkColor = linksOptions.id !== undefined
                        ? container.particles.linksColors.get(linksOptions.id)
                        : container.particles.linksColor;
                    colorLine = (0, tsparticles_engine_1.getLinkColor)(p1, p2, linkColor);
                }
                if (!colorLine) {
                    return;
                }
                const width = (_b = p1.retina.linksWidth) !== null && _b !== void 0 ? _b : container.retina.linksWidth, maxDistance = (_c = p1.retina.linksDistance) !== null && _c !== void 0 ? _c : container.retina.linksDistance;
                (0, Utils_1.drawLinkLine)(ctx, width, pos1, pos2, maxDistance, container.canvas.size, p1.options.links.warp, options.backgroundMask.enable, options.backgroundMask.composite, colorLine, opacity, p1.options.links.shadow);
            });
        }
        drawLinkTriangle(p1, link1, link2) {
            var _a;
            const container = this.container, options = container.actualOptions, p2 = link1.destination, p3 = link2.destination, triangleOptions = p1.options.links.triangles, opacityTriangle = (_a = triangleOptions.opacity) !== null && _a !== void 0 ? _a : (link1.opacity + link2.opacity) / 2;
            if (opacityTriangle <= 0) {
                return;
            }
            container.canvas.draw((ctx) => {
                const pos1 = p1.getPosition();
                const pos2 = p2.getPosition();
                const pos3 = p3.getPosition();
                if ((0, tsparticles_engine_1.getDistance)(pos1, pos2) > container.retina.linksDistance ||
                    (0, tsparticles_engine_1.getDistance)(pos3, pos2) > container.retina.linksDistance ||
                    (0, tsparticles_engine_1.getDistance)(pos3, pos1) > container.retina.linksDistance) {
                    return;
                }
                let colorTriangle = (0, tsparticles_engine_1.rangeColorToRgb)(triangleOptions.color);
                if (!colorTriangle) {
                    const linksOptions = p1.options.links, linkColor = linksOptions.id !== undefined
                        ? container.particles.linksColors.get(linksOptions.id)
                        : container.particles.linksColor;
                    colorTriangle = (0, tsparticles_engine_1.getLinkColor)(p1, p2, linkColor);
                }
                if (!colorTriangle) {
                    return;
                }
                (0, Utils_1.drawLinkTriangle)(ctx, pos1, pos2, pos3, options.backgroundMask.enable, options.backgroundMask.composite, colorTriangle, opacityTriangle);
            });
        }
    }
    exports.LinkInstance = LinkInstance;
});
