{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";/**\n * Just-in-time calculates and caches size and position information for a collection of cells.\n */var CellSizeAndPositionManager=/*#__PURE__*/function(){// Cache of size and position data for cells, mapped by cell index.\n// Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\n// Measurements for cells up to this index can be trusted; cells afterward should be estimated.\n// Used in deferred mode to track which cells have been queued for measurement.\nfunction CellSizeAndPositionManager(_ref){var cellCount=_ref.cellCount,cellSizeGetter=_ref.cellSizeGetter,estimatedCellSize=_ref.estimatedCellSize;_classCallCheck(this,CellSizeAndPositionManager);_defineProperty(this,\"_cellSizeAndPositionData\",{});_defineProperty(this,\"_lastMeasuredIndex\",-1);_defineProperty(this,\"_lastBatchedIndex\",-1);_defineProperty(this,\"_cellCount\",void 0);_defineProperty(this,\"_cellSizeGetter\",void 0);_defineProperty(this,\"_estimatedCellSize\",void 0);this._cellSizeGetter=cellSizeGetter;this._cellCount=cellCount;this._estimatedCellSize=estimatedCellSize;}_createClass(CellSizeAndPositionManager,[{key:\"areOffsetsAdjusted\",value:function areOffsetsAdjusted(){return false;}},{key:\"configure\",value:function configure(_ref2){var cellCount=_ref2.cellCount,estimatedCellSize=_ref2.estimatedCellSize,cellSizeGetter=_ref2.cellSizeGetter;this._cellCount=cellCount;this._estimatedCellSize=estimatedCellSize;this._cellSizeGetter=cellSizeGetter;}},{key:\"getCellCount\",value:function getCellCount(){return this._cellCount;}},{key:\"getEstimatedCellSize\",value:function getEstimatedCellSize(){return this._estimatedCellSize;}},{key:\"getLastMeasuredIndex\",value:function getLastMeasuredIndex(){return this._lastMeasuredIndex;}},{key:\"getOffsetAdjustment\",value:function getOffsetAdjustment(){return 0;}/**\n     * This method returns the size and position for the cell at the specified index.\n     * It just-in-time calculates (or used cached values) for cells leading up to the index.\n     */},{key:\"getSizeAndPositionOfCell\",value:function getSizeAndPositionOfCell(index){if(index<0||index>=this._cellCount){throw Error(\"Requested index \".concat(index,\" is outside of range 0..\").concat(this._cellCount));}if(index>this._lastMeasuredIndex){var lastMeasuredCellSizeAndPosition=this.getSizeAndPositionOfLastMeasuredCell();var offset=lastMeasuredCellSizeAndPosition.offset+lastMeasuredCellSizeAndPosition.size;for(var i=this._lastMeasuredIndex+1;i<=index;i++){var size=this._cellSizeGetter({index:i});// undefined or NaN probably means a logic error in the size getter.\n// null means we're using CellMeasurer and haven't yet measured a given index.\nif(size===undefined||isNaN(size)){throw Error(\"Invalid size returned for cell \".concat(i,\" of value \").concat(size));}else if(size===null){this._cellSizeAndPositionData[i]={offset:offset,size:0};this._lastBatchedIndex=index;}else{this._cellSizeAndPositionData[i]={offset:offset,size:size};offset+=size;this._lastMeasuredIndex=index;}}}return this._cellSizeAndPositionData[index];}},{key:\"getSizeAndPositionOfLastMeasuredCell\",value:function getSizeAndPositionOfLastMeasuredCell(){return this._lastMeasuredIndex>=0?this._cellSizeAndPositionData[this._lastMeasuredIndex]:{offset:0,size:0};}/**\n     * Total size of all cells being measured.\n     * This value will be completely estimated initially.\n     * As cells are measured, the estimate will be updated.\n     */},{key:\"getTotalSize\",value:function getTotalSize(){var lastMeasuredCellSizeAndPosition=this.getSizeAndPositionOfLastMeasuredCell();var totalSizeOfMeasuredCells=lastMeasuredCellSizeAndPosition.offset+lastMeasuredCellSizeAndPosition.size;var numUnmeasuredCells=this._cellCount-this._lastMeasuredIndex-1;var totalSizeOfUnmeasuredCells=numUnmeasuredCells*this._estimatedCellSize;return totalSizeOfMeasuredCells+totalSizeOfUnmeasuredCells;}/**\n     * Determines a new offset that ensures a certain cell is visible, given the current offset.\n     * If the cell is already visible then the current offset will be returned.\n     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\n     *\n     * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @param currentOffset Container's current (x or y) offset\n     * @param totalSize Total size (width or height) of all cells\n     * @return Offset to use to ensure the specified cell is visible\n     */},{key:\"getUpdatedOffsetForIndex\",value:function getUpdatedOffsetForIndex(_ref3){var _ref3$align=_ref3.align,align=_ref3$align===void 0?'auto':_ref3$align,containerSize=_ref3.containerSize,currentOffset=_ref3.currentOffset,targetIndex=_ref3.targetIndex;if(containerSize<=0){return 0;}var datum=this.getSizeAndPositionOfCell(targetIndex);var maxOffset=datum.offset;var minOffset=maxOffset-containerSize+datum.size;var idealOffset;switch(align){case'start':idealOffset=maxOffset;break;case'end':idealOffset=minOffset;break;case'center':idealOffset=maxOffset-(containerSize-datum.size)/2;break;default:idealOffset=Math.max(minOffset,Math.min(maxOffset,currentOffset));break;}var totalSize=this.getTotalSize();return Math.max(0,Math.min(totalSize-containerSize,idealOffset));}},{key:\"getVisibleCellRange\",value:function getVisibleCellRange(params){var containerSize=params.containerSize,offset=params.offset;var totalSize=this.getTotalSize();if(totalSize===0){return{};}var maxOffset=offset+containerSize;var start=this._findNearestCell(offset);var datum=this.getSizeAndPositionOfCell(start);offset=datum.offset+datum.size;var stop=start;while(offset<maxOffset&&stop<this._cellCount-1){stop++;offset+=this.getSizeAndPositionOfCell(stop).size;}return{start:start,stop:stop};}/**\n     * Clear all cached values for cells after the specified index.\n     * This method should be called for any cell that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\n     */},{key:\"resetCell\",value:function resetCell(index){this._lastMeasuredIndex=Math.min(this._lastMeasuredIndex,index-1);}},{key:\"_binarySearch\",value:function _binarySearch(high,low,offset){while(low<=high){var middle=low+Math.floor((high-low)/2);var currentOffset=this.getSizeAndPositionOfCell(middle).offset;if(currentOffset===offset){return middle;}else if(currentOffset<offset){low=middle+1;}else if(currentOffset>offset){high=middle-1;}}if(low>0){return low-1;}else{return 0;}}},{key:\"_exponentialSearch\",value:function _exponentialSearch(index,offset){var interval=1;while(index<this._cellCount&&this.getSizeAndPositionOfCell(index).offset<offset){index+=interval;interval*=2;}return this._binarySearch(Math.min(index,this._cellCount-1),Math.floor(index/2),offset);}/**\n     * Searches for the cell (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest cell index will be returned.\n     * This allows partially visible cells (with offsets just before/above the fold) to be visible.\n     */},{key:\"_findNearestCell\",value:function _findNearestCell(offset){if(isNaN(offset)){throw Error(\"Invalid offset \".concat(offset,\" specified\"));}// Our search algorithms find the nearest match at or below the specified offset.\n// So make sure the offset is at least 0 or no match will be found.\noffset=Math.max(0,offset);var lastMeasuredCellSizeAndPosition=this.getSizeAndPositionOfLastMeasuredCell();var lastMeasuredIndex=Math.max(0,this._lastMeasuredIndex);if(lastMeasuredCellSizeAndPosition.offset>=offset){// If we've already measured cells within this range just use a binary search as it's faster.\nreturn this._binarySearch(lastMeasuredIndex,0,offset);}else{// If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n// The exponential search avoids pre-computing sizes for the full set of cells as a binary search would.\n// The overall complexity for this approach is O(log n).\nreturn this._exponentialSearch(lastMeasuredIndex,offset);}}}]);return CellSizeAndPositionManager;}();export{CellSizeAndPositionManager as default};import{bpfrpt_proptype_Alignment}from\"../types\";import{bpfrpt_proptype_CellSizeGetter}from\"../types\";import{bpfrpt_proptype_VisibleCellRange}from\"../types\";","map":null,"metadata":{},"sourceType":"module"}