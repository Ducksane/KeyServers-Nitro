{"ast":null,"code":"/*!\n * @pixi/loaders - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/loaders is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{Texture}from'@pixi/core';/* jshint -W097 */ /**\n * @memberof PIXI\n */var SignalBinding=/** @class */function(){/**\n     * SignalBinding constructor.\n     * @constructs SignalBinding\n     * @param {Function} fn - Event handler to be called.\n     * @param {Boolean} [once=false] - Should this listener be removed after dispatch\n     * @param {object} [thisArg] - The context of the callback function.\n     * @api private\n     */ // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction SignalBinding(fn,once,thisArg){if(once===void 0){once=false;}this._fn=fn;this._once=once;this._thisArg=thisArg;this._next=this._prev=this._owner=null;}SignalBinding.prototype.detach=function(){if(this._owner===null){return false;}this._owner.detach(this);return true;};return SignalBinding;}();/**\n * @private\n */function _addSignalBinding(self,node){if(!self._head){self._head=node;self._tail=node;}else{self._tail._next=node;node._prev=self._tail;self._tail=node;}node._owner=self;return node;}/**\n * @memberof PIXI\n */var Signal=/** @class */function(){/**\n     * MiniSignal constructor.\n     * @example\n     * let mySignal = new Signal();\n     * let binding = mySignal.add(onSignal);\n     * mySignal.dispatch('foo', 'bar');\n     * mySignal.detach(binding);\n     */function Signal(){this._head=this._tail=undefined;}/**\n     * Return an array of attached SignalBinding.\n     *\n     * @param {Boolean} [exists=false] - We only need to know if there are handlers.\n     * @returns {PIXI.SignalBinding[]|Boolean} Array of attached SignalBinding or Boolean if called with exists = true\n     * @api public\n     */Signal.prototype.handlers=function(exists){if(exists===void 0){exists=false;}var node=this._head;if(exists){return!!node;}var ee=[];while(node){ee.push(node);node=node._next;}return ee;};/**\n     * Return true if node is a SignalBinding attached to this MiniSignal\n     *\n     * @param {PIXI.SignalBinding} node - Node to check.\n     * @returns {Boolean} True if node is attache to mini-signal\n     */Signal.prototype.has=function(node){if(!(node instanceof SignalBinding)){throw new Error('MiniSignal#has(): First arg must be a SignalBinding object.');}return node._owner===this;};/**\n     * Dispaches a signal to all registered listeners.\n     *\n     * @returns {Boolean} Indication if we've emitted an event.\n     */Signal.prototype.dispatch=function(){var arguments$1=arguments;var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments$1[_i];}var node=this._head;if(!node){return false;}while(node){if(node._once){this.detach(node);}node._fn.apply(node._thisArg,args);node=node._next;}return true;};/**\n     * Register a new listener.\n     *\n     * @param {Function} fn - Callback function.\n     * @param {object} [thisArg] - The context of the callback function.\n     * @returns {PIXI.SignalBinding} The SignalBinding node that was added.\n     */Signal.prototype.add=function(fn,thisArg){if(thisArg===void 0){thisArg=null;}if(typeof fn!=='function'){throw new Error('MiniSignal#add(): First arg must be a Function.');}return _addSignalBinding(this,new SignalBinding(fn,false,thisArg));};/**\n     * Register a new listener that will be executed only once.\n     *\n     * @param {Function} fn - Callback function.\n     * @param {object} [thisArg] - The context of the callback function.\n     * @returns {PIXI.SignalBinding} The SignalBinding node that was added.\n     */Signal.prototype.once=function(fn,thisArg){if(thisArg===void 0){thisArg=null;}if(typeof fn!=='function'){throw new Error('MiniSignal#once(): First arg must be a Function.');}return _addSignalBinding(this,new SignalBinding(fn,true,thisArg));};/**\n     * Remove binding object.\n     *\n     * @param {PIXI.SignalBinding} node - The binding node that will be removed.\n     * @returns {Signal} The instance on which this method was called.\n     * @api public */Signal.prototype.detach=function(node){if(!(node instanceof SignalBinding)){throw new Error('MiniSignal#detach(): First arg must be a SignalBinding object.');}if(node._owner!==this){return this;}// todo: or error?\nif(node._prev){node._prev._next=node._next;}if(node._next){node._next._prev=node._prev;}if(node===this._head){// first node\nthis._head=node._next;if(node._next===null){this._tail=null;}}else if(node===this._tail){// last node\nthis._tail=node._prev;this._tail._next=null;}node._owner=null;return this;};/**\n     * Detach all listeners.\n     *\n     * @returns {Signal} The instance on which this method was called.\n     */Signal.prototype.detachAll=function(){var node=this._head;if(!node){return this;}this._head=this._tail=null;while(node){node._owner=null;node=node._next;}return this;};return Signal;}();/**\n * function from npm package `parseUri`, converted to TS to avoid leftpad incident\n * @param {string} str\n * @param [opts] - options\n * @param {boolean} [opts.strictMode] - type of parser\n */function parseUri(str,opts){opts=opts||{};var o={// eslint-disable-next-line max-len\nkey:['source','protocol','authority','userInfo','user','password','host','port','relative','path','directory','file','query','anchor'],q:{name:'queryKey',parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{// eslint-disable-next-line max-len\nstrict:/^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,// eslint-disable-next-line max-len\nloose:/^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/}};var m=o.parser[opts.strictMode?'strict':'loose'].exec(str);var uri={};var i=14;while(i--){uri[o.key[i]]=m[i]||'';}uri[o.q.name]={};uri[o.key[12]].replace(o.q.parser,function(_t0,t1,t2){if(t1){uri[o.q.name][t1]=t2;}});return uri;}// tests if CORS is supported in XHR, if not we need to use XDR\nvar useXdr=!!(globalThis.XDomainRequest&&!('withCredentials'in new XMLHttpRequest()));var tempAnchor=null;// some status constants\nvar STATUS_NONE=0;var STATUS_OK=200;var STATUS_EMPTY=204;var STATUS_IE_BUG_EMPTY=1223;var STATUS_TYPE_OK=2;// noop\nfunction _noop(){}/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param map - The map to set on.\n * @param extname - The extension (or key) to set.\n * @param val - The value to set.\n */function setExtMap(map,extname,val){if(extname&&extname.indexOf('.')===0){extname=extname.substring(1);}if(!extname){return;}map[extname]=val;}/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param xhr - The request to check.\n * @return The type.\n */function reqType(xhr){return xhr.toString().replace('object ','');}/**\n * Manages the state and loading of a resource and all child resources.\n *\n * Can be extended in `GlobalMixins.LoaderResource`.\n *\n * @memberof PIXI\n */var LoaderResource=/** @class */function(){/**\n     * @param {string} name - The name of the resource to load.\n     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n     *      an array of sources.\n     * @param {object} [options] - The options for the load.\n     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @param {PIXI.LoaderResource.LOAD_TYPE} [options.loadType=LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} [options.xhrType=XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @param {PIXI.LoaderResource.IMetadata} [options.metadata] - Extra configuration for middleware\n     *      and the Resource object.\n     */function LoaderResource(name,url,options){/**\n         * The `dequeue` method that will be used a storage place for the async queue dequeue method\n         * used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */this._dequeue=_noop;/**\n         * Used a storage place for the on load binding used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */this._onLoadBinding=null;/**\n         * The timer for element loads to check if they timeout.\n         *\n         * @private\n         */this._elementTimer=0;/**\n         * The `complete` function bound to this resource's context.\n         *\n         * @private\n         * @type {function}\n         */this._boundComplete=null;/**\n         * The `_onError` function bound to this resource's context.\n         *\n         * @private\n         * @type {function}\n         */this._boundOnError=null;/**\n         * The `_onProgress` function bound to this resource's context.\n         *\n         * @private\n         * @type {function}\n         */this._boundOnProgress=null;/**\n         * The `_onTimeout` function bound to this resource's context.\n         *\n         * @private\n         * @type {function}\n         */this._boundOnTimeout=null;this._boundXhrOnError=null;this._boundXhrOnTimeout=null;this._boundXhrOnAbort=null;this._boundXhrOnLoad=null;if(typeof name!=='string'||typeof url!=='string'){throw new Error('Both name and url are required for constructing a resource.');}options=options||{};this._flags=0;// set data url flag, needs to be set early for some _determineX checks to work.\nthis._setFlag(LoaderResource.STATUS_FLAGS.DATA_URL,url.indexOf('data:')===0);this.name=name;this.url=url;this.extension=this._getExtension();this.data=null;this.crossOrigin=options.crossOrigin===true?'anonymous':options.crossOrigin;this.timeout=options.timeout||0;this.loadType=options.loadType||this._determineLoadType();// The type used to load the resource via XHR. If unset, determined automatically.\nthis.xhrType=options.xhrType;// Extra info for middleware, and controlling specifics about how the resource loads.\n// Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n// Meaning it will modify it as it sees fit.\nthis.metadata=options.metadata||{};// The error that occurred while loading (if any).\nthis.error=null;// The XHR object that was used to load this resource. This is only set\n// when `loadType` is `LoaderResource.LOAD_TYPE.XHR`.\nthis.xhr=null;// The child resources this resource owns.\nthis.children=[];// The resource type.\nthis.type=LoaderResource.TYPE.UNKNOWN;// The progress chunk owned by this resource.\nthis.progressChunk=0;// The `dequeue` method that will be used a storage place for the async queue dequeue method\n// used privately by the loader.\nthis._dequeue=_noop;// Used a storage place for the on load binding used privately by the loader.\nthis._onLoadBinding=null;// The timer for element loads to check if they timeout.\nthis._elementTimer=0;this._boundComplete=this.complete.bind(this);this._boundOnError=this._onError.bind(this);this._boundOnProgress=this._onProgress.bind(this);this._boundOnTimeout=this._onTimeout.bind(this);// xhr callbacks\nthis._boundXhrOnError=this._xhrOnError.bind(this);this._boundXhrOnTimeout=this._xhrOnTimeout.bind(this);this._boundXhrOnAbort=this._xhrOnAbort.bind(this);this._boundXhrOnLoad=this._xhrOnLoad.bind(this);// Dispatched when the resource beings to load.\nthis.onStart=new Signal();// Dispatched each time progress of this resource load updates.\n// Not all resources types and loader systems can support this event\n// so sometimes it may not be available. If the resource\n// is being loaded on a modern browser, using XHR, and the remote server\n// properly sets Content-Length headers, then this will be available.\nthis.onProgress=new Signal();// Dispatched once this resource has loaded, if there was an error it will\n// be in the `error` property.\nthis.onComplete=new Signal();// Dispatched after this resource has had all the *after* middleware run on it.\nthis.onAfterMiddleware=new Signal();}/**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {PIXI.LoaderResource.LOAD_TYPE} loadType - The load type to set it to.\n     */LoaderResource.setExtensionLoadType=function(extname,loadType){setExtMap(LoaderResource._loadTypeMap,extname,loadType);};/**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {PIXI.LoaderResource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n     */LoaderResource.setExtensionXhrType=function(extname,xhrType){setExtMap(LoaderResource._xhrTypeMap,extname,xhrType);};Object.defineProperty(LoaderResource.prototype,\"isDataUrl\",{/**\n         * When the resource starts to load.\n         *\n         * @memberof PIXI.LoaderResource\n         * @callback OnStartSignal\n         * @param {Resource} resource - The resource that the event happened on.\n         */ /**\n         * When the resource reports loading progress.\n         *\n         * @memberof PIXI.LoaderResource\n         * @callback OnProgressSignal\n         * @param {Resource} resource - The resource that the event happened on.\n         * @param {number} percentage - The progress of the load in the range [0, 1].\n         */ /**\n         * When the resource finishes loading.\n         *\n         * @memberof PIXI.LoaderResource\n         * @callback OnCompleteSignal\n         * @param {Resource} resource - The resource that the event happened on.\n         */ /**\n         * @memberof PIXI.LoaderResource\n         * @typedef {object} IMetadata\n         * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n         *      element to use for loading, instead of creating one.\n         * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n         *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n         * @property {string|string[]} [mimeType] - The mime type to use for the source element\n         *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n         *      where each index is the mime type to use for the corresponding url index.\n         */ /**\n         * Stores whether or not this url is a data url.\n         *\n         * @readonly\n         * @member {boolean}\n         */get:function get(){return this._hasFlag(LoaderResource.STATUS_FLAGS.DATA_URL);},enumerable:false,configurable:true});Object.defineProperty(LoaderResource.prototype,\"isComplete\",{/**\n         * Describes if this resource has finished loading. Is true when the resource has completely\n         * loaded.\n         *\n         * @readonly\n         * @member {boolean}\n         */get:function get(){return this._hasFlag(LoaderResource.STATUS_FLAGS.COMPLETE);},enumerable:false,configurable:true});Object.defineProperty(LoaderResource.prototype,\"isLoading\",{/**\n         * Describes if this resource is currently loading. Is true when the resource starts loading,\n         * and is false again when complete.\n         *\n         * @readonly\n         * @member {boolean}\n         */get:function get(){return this._hasFlag(LoaderResource.STATUS_FLAGS.LOADING);},enumerable:false,configurable:true});/**\n     * Marks the resource as complete.\n     *\n     */LoaderResource.prototype.complete=function(){this._clearEvents();this._finish();};/**\n     * Aborts the loading of this resource, with an optional message.\n     *\n     * @param {string} message - The message to use for the error\n     */LoaderResource.prototype.abort=function(message){// abort can be called multiple times, ignore subsequent calls.\nif(this.error){return;}// store error\nthis.error=new Error(message);// clear events before calling aborts\nthis._clearEvents();// abort the actual loading\nif(this.xhr){this.xhr.abort();}else if(this.xdr){this.xdr.abort();}else if(this.data){// single source\nif(this.data.src){this.data.src=LoaderResource.EMPTY_GIF;}// multi-source\nelse{while(this.data.firstChild){this.data.removeChild(this.data.firstChild);}}}// done now.\nthis._finish();};/**\n     * Kicks off loading of this resource. This method is asynchronous.\n     *\n     * @param {PIXI.LoaderResource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n     */LoaderResource.prototype.load=function(cb){var _this=this;if(this.isLoading){return;}if(this.isComplete){if(cb){setTimeout(function(){return cb(_this);},1);}return;}else if(cb){this.onComplete.once(cb);}this._setFlag(LoaderResource.STATUS_FLAGS.LOADING,true);this.onStart.dispatch(this);// if unset, determine the value\nif(this.crossOrigin===false||typeof this.crossOrigin!=='string'){this.crossOrigin=this._determineCrossOrigin(this.url);}switch(this.loadType){case LoaderResource.LOAD_TYPE.IMAGE:this.type=LoaderResource.TYPE.IMAGE;this._loadElement('image');break;case LoaderResource.LOAD_TYPE.AUDIO:this.type=LoaderResource.TYPE.AUDIO;this._loadSourceElement('audio');break;case LoaderResource.LOAD_TYPE.VIDEO:this.type=LoaderResource.TYPE.VIDEO;this._loadSourceElement('video');break;case LoaderResource.LOAD_TYPE.XHR:/* falls through */default:if(useXdr&&this.crossOrigin){this._loadXdr();}else{this._loadXhr();}break;}};/**\n     * Checks if the flag is set.\n     *\n     * @param flag - The flag to check.\n     * @return True if the flag is set.\n     */LoaderResource.prototype._hasFlag=function(flag){return(this._flags&flag)!==0;};/**\n     * (Un)Sets the flag.\n     *\n     * @param flag - The flag to (un)set.\n     * @param value - Whether to set or (un)set the flag.\n     */LoaderResource.prototype._setFlag=function(flag,value){this._flags=value?this._flags|flag:this._flags&~flag;};/**\n     * Clears all the events from the underlying loading source.\n     */LoaderResource.prototype._clearEvents=function(){clearTimeout(this._elementTimer);if(this.data&&this.data.removeEventListener){this.data.removeEventListener('error',this._boundOnError,false);this.data.removeEventListener('load',this._boundComplete,false);this.data.removeEventListener('progress',this._boundOnProgress,false);this.data.removeEventListener('canplaythrough',this._boundComplete,false);}if(this.xhr){if(this.xhr.removeEventListener){this.xhr.removeEventListener('error',this._boundXhrOnError,false);this.xhr.removeEventListener('timeout',this._boundXhrOnTimeout,false);this.xhr.removeEventListener('abort',this._boundXhrOnAbort,false);this.xhr.removeEventListener('progress',this._boundOnProgress,false);this.xhr.removeEventListener('load',this._boundXhrOnLoad,false);}else{this.xhr.onerror=null;this.xhr.ontimeout=null;this.xhr.onprogress=null;this.xhr.onload=null;}}};/**\n     * Finalizes the load.\n     */LoaderResource.prototype._finish=function(){if(this.isComplete){throw new Error('Complete called again for an already completed resource.');}this._setFlag(LoaderResource.STATUS_FLAGS.COMPLETE,true);this._setFlag(LoaderResource.STATUS_FLAGS.LOADING,false);this.onComplete.dispatch(this);};/**\n     * Loads this resources using an element that has a single source,\n     * like an HTMLImageElement.\n     * @private\n     * @param type - The type of element to use.\n     */LoaderResource.prototype._loadElement=function(type){if(this.metadata.loadElement){this.data=this.metadata.loadElement;}else if(type==='image'&&typeof globalThis.Image!=='undefined'){this.data=new Image();}else{this.data=document.createElement(type);}if(this.crossOrigin){this.data.crossOrigin=this.crossOrigin;}if(!this.metadata.skipSource){this.data.src=this.url;}this.data.addEventListener('error',this._boundOnError,false);this.data.addEventListener('load',this._boundComplete,false);this.data.addEventListener('progress',this._boundOnProgress,false);if(this.timeout){this._elementTimer=setTimeout(this._boundOnTimeout,this.timeout);}};/**\n     * Loads this resources using an element that has multiple sources,\n     * like an HTMLAudioElement or HTMLVideoElement.\n     * @param type - The type of element to use.\n     */LoaderResource.prototype._loadSourceElement=function(type){if(this.metadata.loadElement){this.data=this.metadata.loadElement;}else if(type==='audio'&&typeof globalThis.Audio!=='undefined'){this.data=new Audio();}else{this.data=document.createElement(type);}if(this.data===null){this.abort(\"Unsupported element: \"+type);return;}if(this.crossOrigin){this.data.crossOrigin=this.crossOrigin;}if(!this.metadata.skipSource){// support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\nif(navigator.isCocoonJS){this.data.src=Array.isArray(this.url)?this.url[0]:this.url;}else if(Array.isArray(this.url)){var mimeTypes=this.metadata.mimeType;for(var i=0;i<this.url.length;++i){this.data.appendChild(this._createSource(type,this.url[i],Array.isArray(mimeTypes)?mimeTypes[i]:mimeTypes));}}else{var mimeTypes=this.metadata.mimeType;this.data.appendChild(this._createSource(type,this.url,Array.isArray(mimeTypes)?mimeTypes[0]:mimeTypes));}}this.data.addEventListener('error',this._boundOnError,false);this.data.addEventListener('load',this._boundComplete,false);this.data.addEventListener('progress',this._boundOnProgress,false);this.data.addEventListener('canplaythrough',this._boundComplete,false);this.data.load();if(this.timeout){this._elementTimer=setTimeout(this._boundOnTimeout,this.timeout);}};/**\n     * Loads this resources using an XMLHttpRequest.\n     */LoaderResource.prototype._loadXhr=function(){// if unset, determine the value\nif(typeof this.xhrType!=='string'){this.xhrType=this._determineXhrType();}var xhr=this.xhr=new XMLHttpRequest();// send credentials when crossOrigin with credentials requested\nif(this.crossOrigin==='use-credentials'){xhr.withCredentials=true;}// set the request type and url\nxhr.open('GET',this.url,true);xhr.timeout=this.timeout;// load json as text and parse it ourselves. We do this because some browsers\n// *cough* safari *cough* can't deal with it.\nif(this.xhrType===LoaderResource.XHR_RESPONSE_TYPE.JSON||this.xhrType===LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT){xhr.responseType=LoaderResource.XHR_RESPONSE_TYPE.TEXT;}else{xhr.responseType=this.xhrType;}xhr.addEventListener('error',this._boundXhrOnError,false);xhr.addEventListener('timeout',this._boundXhrOnTimeout,false);xhr.addEventListener('abort',this._boundXhrOnAbort,false);xhr.addEventListener('progress',this._boundOnProgress,false);xhr.addEventListener('load',this._boundXhrOnLoad,false);xhr.send();};/**\n     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n     */LoaderResource.prototype._loadXdr=function(){// if unset, determine the value\nif(typeof this.xhrType!=='string'){this.xhrType=this._determineXhrType();}var xdr=this.xhr=new globalThis.XDomainRequest();// eslint-disable-line no-undef\n// XDomainRequest has a few quirks. Occasionally it will abort requests\n// A way to avoid this is to make sure ALL callbacks are set even if not used\n// More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\nxdr.timeout=this.timeout||5000;// XDR needs a timeout value or it breaks in IE9\nxdr.onerror=this._boundXhrOnError;xdr.ontimeout=this._boundXhrOnTimeout;xdr.onprogress=this._boundOnProgress;xdr.onload=this._boundXhrOnLoad;xdr.open('GET',this.url,true);// Note: The xdr.send() call is wrapped in a timeout to prevent an\n// issue with the interface where some requests are lost if multiple\n// XDomainRequests are being sent at the same time.\n// Some info here: https://github.com/photonstorm/phaser/issues/1248\nsetTimeout(function(){return xdr.send();},1);};/**\n     * Creates a source used in loading via an element.\n     * @param type - The element type (video or audio).\n     * @param url - The source URL to load from.\n     * @param [mime] - The mime type of the video\n     * @return The source element.\n     */LoaderResource.prototype._createSource=function(type,url,mime){if(!mime){mime=type+\"/\"+this._getExtension(url);}var source=document.createElement('source');source.src=url;source.type=mime;return source;};/**\n     * Called if a load errors out.\n     *\n     * @param event - The error event from the element that emits it.\n     */LoaderResource.prototype._onError=function(event){this.abort(\"Failed to load element using: \"+event.target.nodeName);};/**\n     * Called if a load progress event fires for an element or xhr/xdr.\n     * @param event - Progress event.\n     */LoaderResource.prototype._onProgress=function(event){if(event&&event.lengthComputable){this.onProgress.dispatch(this,event.loaded/event.total);}};/**\n     * Called if a timeout event fires for an element.\n     */LoaderResource.prototype._onTimeout=function(){this.abort(\"Load timed out.\");};/**\n     * Called if an error event fires for xhr/xdr.\n     */LoaderResource.prototype._xhrOnError=function(){var xhr=this.xhr;this.abort(reqType(xhr)+\" Request failed. Status: \"+xhr.status+\", text: \\\"\"+xhr.statusText+\"\\\"\");};/**\n     * Called if an error event fires for xhr/xdr.\n     */LoaderResource.prototype._xhrOnTimeout=function(){var xhr=this.xhr;this.abort(reqType(xhr)+\" Request timed out.\");};/**\n     * Called if an abort event fires for xhr/xdr.\n     */LoaderResource.prototype._xhrOnAbort=function(){var xhr=this.xhr;this.abort(reqType(xhr)+\" Request was aborted by the user.\");};/**\n     * Called when data successfully loads from an xhr/xdr request.\n     */LoaderResource.prototype._xhrOnLoad=function(){var xhr=this.xhr;var text='';var status=typeof xhr.status==='undefined'?STATUS_OK:xhr.status;// XDR has no `.status`, assume 200.\n// responseText is accessible only if responseType is '' or 'text' and on older browsers\nif(xhr.responseType===''||xhr.responseType==='text'||typeof xhr.responseType==='undefined'){text=xhr.responseText;}// status can be 0 when using the `file://` protocol so we also check if a response is set.\n// If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\nif(status===STATUS_NONE&&(text.length>0||xhr.responseType===LoaderResource.XHR_RESPONSE_TYPE.BUFFER)){status=STATUS_OK;}// handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\nelse if(status===STATUS_IE_BUG_EMPTY){status=STATUS_EMPTY;}var statusType=status/100|0;if(statusType===STATUS_TYPE_OK){// if text, just return it\nif(this.xhrType===LoaderResource.XHR_RESPONSE_TYPE.TEXT){this.data=text;this.type=LoaderResource.TYPE.TEXT;}// if json, parse into json object\nelse if(this.xhrType===LoaderResource.XHR_RESPONSE_TYPE.JSON){try{this.data=JSON.parse(text);this.type=LoaderResource.TYPE.JSON;}catch(e){this.abort(\"Error trying to parse loaded json: \"+e);return;}}// if xml, parse into an xml document or div element\nelse if(this.xhrType===LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT){try{if(globalThis.DOMParser){var domparser=new DOMParser();this.data=domparser.parseFromString(text,'text/xml');}else{var div=document.createElement('div');div.innerHTML=text;this.data=div;}this.type=LoaderResource.TYPE.XML;}catch(e$1){this.abort(\"Error trying to parse loaded xml: \"+e$1);return;}}// other types just return the response\nelse{this.data=xhr.response||text;}}else{this.abort(\"[\"+xhr.status+\"] \"+xhr.statusText+\": \"+xhr.responseURL);return;}this.complete();};/**\n     * Sets the `crossOrigin` property for this resource based on if the url\n     * for this resource is cross-origin. If crossOrigin was manually set, this\n     * function does nothing.\n     * @private\n     * @param url - The url to test.\n     * @param [loc=globalThis.location] - The location object to test against.\n     * @return The crossOrigin value to use (or empty string for none).\n     */ // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nLoaderResource.prototype._determineCrossOrigin=function(url,loc){// data: and javascript: urls are considered same-origin\nif(url.indexOf('data:')===0){return'';}// A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n// origin designed not to match globalThis.location.origin, and will always require\n// crossOrigin requests regardless of whether the location matches.\nif(globalThis.origin!==globalThis.location.origin){return'anonymous';}// default is globalThis.location\nloc=loc||globalThis.location;if(!tempAnchor){tempAnchor=document.createElement('a');}// let the browser determine the full href for the url of this resource and then\n// parse with the node url lib, we can't use the properties of the anchor element\n// because they don't work in IE9 :(\ntempAnchor.href=url;var parsedUrl=parseUri(tempAnchor.href,{strictMode:true});var samePort=!parsedUrl.port&&loc.port===''||parsedUrl.port===loc.port;var protocol=parsedUrl.protocol?parsedUrl.protocol+\":\":'';// if cross origin\nif(parsedUrl.host!==loc.hostname||!samePort||protocol!==loc.protocol){return'anonymous';}return'';};/**\n     * Determines the responseType of an XHR request based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {PIXI.LoaderResource.XHR_RESPONSE_TYPE} The responseType to use.\n     */LoaderResource.prototype._determineXhrType=function(){return LoaderResource._xhrTypeMap[this.extension]||LoaderResource.XHR_RESPONSE_TYPE.TEXT;};/**\n     * Determines the loadType of a resource based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {PIXI.LoaderResource.LOAD_TYPE} The loadType to use.\n     */LoaderResource.prototype._determineLoadType=function(){return LoaderResource._loadTypeMap[this.extension]||LoaderResource.LOAD_TYPE.XHR;};/**\n     * Extracts the extension (sans '.') of the file being loaded by the resource.\n     *\n     * @param [url] - url to parse, `this.url` by default.\n     * @return The extension.\n     */LoaderResource.prototype._getExtension=function(url){if(url===void 0){url=this.url;}var ext='';if(this.isDataUrl){var slashIndex=url.indexOf('/');ext=url.substring(slashIndex+1,url.indexOf(';',slashIndex));}else{var queryStart=url.indexOf('?');var hashStart=url.indexOf('#');var index=Math.min(queryStart>-1?queryStart:url.length,hashStart>-1?hashStart:url.length);url=url.substring(0,index);ext=url.substring(url.lastIndexOf('.')+1);}return ext.toLowerCase();};/**\n     * Determines the mime type of an XHR request based on the responseType of\n     * resource being loaded.\n     *\n     * @param type - The type to get a mime type for.\n     * @private\n     * @return The mime type to use.\n     */LoaderResource.prototype._getMimeFromXhrType=function(type){switch(type){case LoaderResource.XHR_RESPONSE_TYPE.BUFFER:return'application/octet-binary';case LoaderResource.XHR_RESPONSE_TYPE.BLOB:return'application/blob';case LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT:return'application/xml';case LoaderResource.XHR_RESPONSE_TYPE.JSON:return'application/json';case LoaderResource.XHR_RESPONSE_TYPE.DEFAULT:case LoaderResource.XHR_RESPONSE_TYPE.TEXT:/* falls through */default:return'text/plain';}};return LoaderResource;}();// eslint-disable-next-line @typescript-eslint/no-namespace\n(function(LoaderResource){/**\n     * The types of resources a resource could represent.\n     *\n     * @static\n     * @readonly\n     * @enum {number}\n     * @memberof PIXI.LoaderResource\n     */var STATUS_FLAGS;(function(STATUS_FLAGS){/** None */STATUS_FLAGS[STATUS_FLAGS[\"NONE\"]=0]=\"NONE\";/** Data URL */STATUS_FLAGS[STATUS_FLAGS[\"DATA_URL\"]=1]=\"DATA_URL\";/** Complete */STATUS_FLAGS[STATUS_FLAGS[\"COMPLETE\"]=2]=\"COMPLETE\";/** Loading */STATUS_FLAGS[STATUS_FLAGS[\"LOADING\"]=4]=\"LOADING\";})(STATUS_FLAGS=LoaderResource.STATUS_FLAGS||(LoaderResource.STATUS_FLAGS={}));/**\n     * The types of resources a resource could represent.\n     *\n     * @static\n     * @readonly\n     * @enum {number}\n     * @memberof PIXI.LoaderResource\n     */var TYPE;(function(TYPE){/** Unknown */TYPE[TYPE[\"UNKNOWN\"]=0]=\"UNKNOWN\";/** JSON */TYPE[TYPE[\"JSON\"]=1]=\"JSON\";/** XML */TYPE[TYPE[\"XML\"]=2]=\"XML\";/** Image */TYPE[TYPE[\"IMAGE\"]=3]=\"IMAGE\";/** Audio */TYPE[TYPE[\"AUDIO\"]=4]=\"AUDIO\";/** Video */TYPE[TYPE[\"VIDEO\"]=5]=\"VIDEO\";/** Plain text */TYPE[TYPE[\"TEXT\"]=6]=\"TEXT\";})(TYPE=LoaderResource.TYPE||(LoaderResource.TYPE={}));/**\n     * The types of loading a resource can use.\n     *\n     * @static\n     * @readonly\n     * @enum {number}\n     * @memberof PIXI.LoaderResource\n     */var LOAD_TYPE;(function(LOAD_TYPE){/** Uses XMLHttpRequest to load the resource. */LOAD_TYPE[LOAD_TYPE[\"XHR\"]=1]=\"XHR\";/** Uses an `Image` object to load the resource. */LOAD_TYPE[LOAD_TYPE[\"IMAGE\"]=2]=\"IMAGE\";/** Uses an `Audio` object to load the resource. */LOAD_TYPE[LOAD_TYPE[\"AUDIO\"]=3]=\"AUDIO\";/** Uses a `Video` object to load the resource. */LOAD_TYPE[LOAD_TYPE[\"VIDEO\"]=4]=\"VIDEO\";})(LOAD_TYPE=LoaderResource.LOAD_TYPE||(LoaderResource.LOAD_TYPE={}));/**\n     * The XHR ready states, used internally.\n     *\n     * @static\n     * @readonly\n     * @enum {string}\n     * @memberof PIXI.LoaderResource\n     */var XHR_RESPONSE_TYPE;(function(XHR_RESPONSE_TYPE){/** string */XHR_RESPONSE_TYPE[\"DEFAULT\"]=\"text\";/** ArrayBuffer */XHR_RESPONSE_TYPE[\"BUFFER\"]=\"arraybuffer\";/** Blob */XHR_RESPONSE_TYPE[\"BLOB\"]=\"blob\";/** Document */XHR_RESPONSE_TYPE[\"DOCUMENT\"]=\"document\";/** Object */XHR_RESPONSE_TYPE[\"JSON\"]=\"json\";/** String */XHR_RESPONSE_TYPE[\"TEXT\"]=\"text\";})(XHR_RESPONSE_TYPE=LoaderResource.XHR_RESPONSE_TYPE||(LoaderResource.XHR_RESPONSE_TYPE={}));LoaderResource._loadTypeMap={// images\ngif:LoaderResource.LOAD_TYPE.IMAGE,png:LoaderResource.LOAD_TYPE.IMAGE,bmp:LoaderResource.LOAD_TYPE.IMAGE,jpg:LoaderResource.LOAD_TYPE.IMAGE,jpeg:LoaderResource.LOAD_TYPE.IMAGE,tif:LoaderResource.LOAD_TYPE.IMAGE,tiff:LoaderResource.LOAD_TYPE.IMAGE,webp:LoaderResource.LOAD_TYPE.IMAGE,tga:LoaderResource.LOAD_TYPE.IMAGE,svg:LoaderResource.LOAD_TYPE.IMAGE,'svg+xml':LoaderResource.LOAD_TYPE.IMAGE,// audio\nmp3:LoaderResource.LOAD_TYPE.AUDIO,ogg:LoaderResource.LOAD_TYPE.AUDIO,wav:LoaderResource.LOAD_TYPE.AUDIO,// videos\nmp4:LoaderResource.LOAD_TYPE.VIDEO,webm:LoaderResource.LOAD_TYPE.VIDEO};LoaderResource._xhrTypeMap={// xml\nxhtml:LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,html:LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,htm:LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,xml:LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,tmx:LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,svg:LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,// This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n// Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n// this should probably be fine.\ntsx:LoaderResource.XHR_RESPONSE_TYPE.DOCUMENT,// images\ngif:LoaderResource.XHR_RESPONSE_TYPE.BLOB,png:LoaderResource.XHR_RESPONSE_TYPE.BLOB,bmp:LoaderResource.XHR_RESPONSE_TYPE.BLOB,jpg:LoaderResource.XHR_RESPONSE_TYPE.BLOB,jpeg:LoaderResource.XHR_RESPONSE_TYPE.BLOB,tif:LoaderResource.XHR_RESPONSE_TYPE.BLOB,tiff:LoaderResource.XHR_RESPONSE_TYPE.BLOB,webp:LoaderResource.XHR_RESPONSE_TYPE.BLOB,tga:LoaderResource.XHR_RESPONSE_TYPE.BLOB,// json\njson:LoaderResource.XHR_RESPONSE_TYPE.JSON,// text\ntext:LoaderResource.XHR_RESPONSE_TYPE.TEXT,txt:LoaderResource.XHR_RESPONSE_TYPE.TEXT,// fonts\nttf:LoaderResource.XHR_RESPONSE_TYPE.BUFFER,otf:LoaderResource.XHR_RESPONSE_TYPE.BUFFER};// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\nLoaderResource.EMPTY_GIF='data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';})(LoaderResource||(LoaderResource={}));/**\n * Smaller version of the async library constructs.\n * @ignore\n */function _noop$1(){}/**\n * Ensures a function is only called once.\n * @ignore\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */function onlyOnce(fn){return function onceWrapper(){var arguments$1=arguments;var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments$1[_i];}if(fn===null){throw new Error('Callback was already called.');}var callFn=fn;fn=null;callFn.apply(this,args);};}/**\n * @private\n * @memberof PIXI\n */var AsyncQueueItem=/** @class */function(){/**\n     * @private\n     */function AsyncQueueItem(data,callback){this.data=data;this.callback=callback;}return AsyncQueueItem;}();/**\n * @private\n * @memberof PIXI\n */var AsyncQueue=/** @class */function(){/**\n     * @private\n     */function AsyncQueue(worker,concurrency){var _this=this;if(concurrency===void 0){concurrency=1;}this.workers=0;this.saturated=_noop$1;this.unsaturated=_noop$1;this.empty=_noop$1;this.drain=_noop$1;this.error=_noop$1;this.started=false;this.paused=false;this._tasks=[];this._insert=function(data,insertAtFront,callback){if(callback&&typeof callback!=='function'){throw new Error('task callback must be a function');}_this.started=true;// eslint-disable-next-line no-eq-null,eqeqeq\nif(data==null&&_this.idle()){// call drain immediately if there are no tasks\nsetTimeout(function(){return _this.drain();},1);return;}var item=new AsyncQueueItem(data,typeof callback==='function'?callback:_noop$1);if(insertAtFront){_this._tasks.unshift(item);}else{_this._tasks.push(item);}setTimeout(_this.process,1);};this.process=function(){while(!_this.paused&&_this.workers<_this.concurrency&&_this._tasks.length){var task=_this._tasks.shift();if(_this._tasks.length===0){_this.empty();}_this.workers+=1;if(_this.workers===_this.concurrency){_this.saturated();}_this._worker(task.data,onlyOnce(_this._next(task)));}};this._worker=worker;if(concurrency===0){throw new Error('Concurrency must not be zero');}this.concurrency=concurrency;this.buffer=concurrency/4.0;}/**\n     * @private\n     */AsyncQueue.prototype._next=function(task){var _this=this;return function(){var arguments$1=arguments;var args=[];for(var _i=0;_i<arguments.length;_i++){args[_i]=arguments$1[_i];}_this.workers-=1;task.callback.apply(task,args);// eslint-disable-next-line no-eq-null,eqeqeq\nif(args[0]!=null){_this.error(args[0],task.data);}if(_this.workers<=_this.concurrency-_this.buffer){_this.unsaturated();}if(_this.idle()){_this.drain();}_this.process();};};// That was in object\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nAsyncQueue.prototype.push=function(data,callback){this._insert(data,false,callback);};AsyncQueue.prototype.kill=function(){this.workers=0;this.drain=_noop$1;this.started=false;this._tasks=[];};// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nAsyncQueue.prototype.unshift=function(data,callback){this._insert(data,true,callback);};AsyncQueue.prototype.length=function(){return this._tasks.length;};AsyncQueue.prototype.running=function(){return this.workers;};AsyncQueue.prototype.idle=function(){return this._tasks.length+this.workers===0;};AsyncQueue.prototype.pause=function(){if(this.paused===true){return;}this.paused=true;};AsyncQueue.prototype.resume=function(){if(this.paused===false){return;}this.paused=false;// Need to call this.process once per concurrent\n// worker to preserve full concurrency after pause\nfor(var w=1;w<=this.concurrency;w++){this.process();}};/**\n     * Iterates an array in series.\n     *\n     * @param {Array.<*>} array - Array to iterate.\n     * @param {function} iterator - Function to call for each element.\n     * @param {function} callback - Function to call when done, or on error.\n     * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n     */AsyncQueue.eachSeries=function(array,iterator,callback,deferNext){var i=0;var len=array.length;function next(err){if(err||i===len){if(callback){callback(err);}return;}if(deferNext){setTimeout(function(){iterator(array[i++],next);},1);}else{iterator(array[i++],next);}}next();};/**\n     * Async queue implementation,\n     *\n     * @param {function} worker - The worker function to call for each task.\n     * @param {number} concurrency - How many workers to run in parrallel.\n     * @return {*} The async queue object.\n     */AsyncQueue.queue=function(worker,concurrency){return new AsyncQueue(worker,concurrency);};return AsyncQueue;}();// some constants\nvar MAX_PROGRESS=100;var rgxExtractUrlHash=/(#[\\w-]+)?$/;/**\n * The new loader, forked from Resource Loader by Chad Engler: https://github.com/englercj/resource-loader\n *\n * ```js\n * const loader = PIXI.Loader.shared; // PixiJS exposes a premade instance for you to use.\n * // or\n * const loader = new PIXI.Loader(); // You can also create your own if you want\n *\n * const sprites = {};\n *\n * // Chainable `add` to enqueue a resource\n * loader.add('bunny', 'data/bunny.png')\n *       .add('spaceship', 'assets/spritesheet.json');\n * loader.add('scoreFont', 'assets/score.fnt');\n *\n * // Chainable `pre` to add a middleware that runs for each resource, *before* loading that resource.\n * // This is useful to implement custom caching modules (using filesystem, indexeddb, memory, etc).\n * loader.pre(cachingMiddleware);\n *\n * // Chainable `use` to add a middleware that runs for each resource, *after* loading that resource.\n * // This is useful to implement custom parsing modules (like spritesheet parsers, spine parser, etc).\n * loader.use(parsingMiddleware);\n *\n * // The `load` method loads the queue of resources, and calls the passed in callback called once all\n * // resources have loaded.\n * loader.load((loader, resources) => {\n *     // resources is an object where the key is the name of the resource loaded and the value is the resource object.\n *     // They have a couple default properties:\n *     // - `url`: The URL that the resource was loaded from\n *     // - `error`: The error that happened when trying to load (if any)\n *     // - `data`: The raw data that was loaded\n *     // also may contain other properties based on the middleware that runs.\n *     sprites.bunny = new PIXI.TilingSprite(resources.bunny.texture);\n *     sprites.spaceship = new PIXI.TilingSprite(resources.spaceship.texture);\n *     sprites.scoreFont = new PIXI.TilingSprite(resources.scoreFont.texture);\n * });\n *\n * // throughout the process multiple signals can be dispatched.\n * loader.onProgress.add(() => {}); // called once per loaded/errored file\n * loader.onError.add(() => {}); // called once per errored file\n * loader.onLoad.add(() => {}); // called once per loaded file\n * loader.onComplete.add(() => {}); // called once when the queued resources all load.\n * ```\n *\n * @memberof PIXI\n */var Loader=/** @class */function(){/**\n     * @param baseUrl - The base url for all resources loaded by this loader.\n     * @param concurrency - The number of resources to load concurrently.\n     */function Loader(baseUrl,concurrency){var _this=this;if(baseUrl===void 0){baseUrl='';}if(concurrency===void 0){concurrency=10;}/**\n         * The progress percent of the loader going through the queue.\n         */this.progress=0;/**\n         * Loading state of the loader, true if it is currently loading resources.\n         */this.loading=false;/**\n         * A querystring to append to every URL added to the loader.\n         *\n         * This should be a valid query string *without* the question-mark (`?`). The loader will\n         * also *not* escape values for you. Make sure to escape your parameters with\n         * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n         *\n         * @example\n         * const loader = new Loader();\n         *\n         * loader.defaultQueryString = 'user=me&password=secret';\n         *\n         * // This will request 'image.png?user=me&password=secret'\n         * loader.add('image.png').load();\n         *\n         * loader.reset();\n         *\n         * // This will request 'image.png?v=1&user=me&password=secret'\n         * loader.add('iamge.png?v=1').load();\n         */this.defaultQueryString='';/**\n         * The middleware to run before loading each resource.\n         */this._beforeMiddleware=[];/**\n         * The middleware to run after loading each resource.\n         */this._afterMiddleware=[];/**\n         * The tracks the resources we are currently completing parsing for.\n         */this._resourcesParsing=[];/**\n         * The `_loadResource` function bound with this object context.\n         *\n         * @param r - The resource to load\n         * @param d - The dequeue function\n         */this._boundLoadResource=function(r,d){return _this._loadResource(r,d);};/**\n         * All the resources for this loader keyed by name.\n         */this.resources={};this.baseUrl=baseUrl;this._beforeMiddleware=[];this._afterMiddleware=[];this._resourcesParsing=[];this._boundLoadResource=function(r,d){return _this._loadResource(r,d);};this._queue=AsyncQueue.queue(this._boundLoadResource,concurrency);this._queue.pause();this.resources={};this.onProgress=new Signal();this.onError=new Signal();this.onLoad=new Signal();this.onStart=new Signal();this.onComplete=new Signal();for(var i=0;i<Loader._plugins.length;++i){var plugin=Loader._plugins[i];var pre=plugin.pre,use=plugin.use;if(pre){this.pre(pre);}if(use){this.use(use);}}this._protected=false;}/**\n     * Same as add, params have strict order\n     *\n     * @private\n     * @param name - The name of the resource to load.\n     * @param url - The url for this resource, relative to the baseUrl of this loader.\n     * @param options - The options for the load.\n     * @param callback - Function to call when this specific resource completes loading.\n     * @return The loader itself.\n     */Loader.prototype._add=function(name,url,options,callback){// if loading already you can only add resources that have a parent.\nif(this.loading&&(!options||!options.parentResource)){throw new Error('Cannot add resources while the loader is running.');}// check if resource already exists.\nif(this.resources[name]){throw new Error(\"Resource named \\\"\"+name+\"\\\" already exists.\");}// add base url if this isn't an absolute url\nurl=this._prepareUrl(url);// create the store the resource\nthis.resources[name]=new LoaderResource(name,url,options);if(typeof callback==='function'){this.resources[name].onAfterMiddleware.once(callback);}// if actively loading, make sure to adjust progress chunks for that parent and its children\nif(this.loading){var parent=options.parentResource;var incompleteChildren=[];for(var i=0;i<parent.children.length;++i){if(!parent.children[i].isComplete){incompleteChildren.push(parent.children[i]);}}var fullChunk=parent.progressChunk*(incompleteChildren.length+1);// +1 for parent\nvar eachChunk=fullChunk/(incompleteChildren.length+2);// +2 for parent & new child\nparent.children.push(this.resources[name]);parent.progressChunk=eachChunk;for(var i=0;i<incompleteChildren.length;++i){incompleteChildren[i].progressChunk=eachChunk;}this.resources[name].progressChunk=eachChunk;}// add the resource to the queue\nthis._queue.push(this.resources[name]);return this;};/* eslint-enable require-jsdoc,valid-jsdoc */ /**\n     * Sets up a middleware function that will run *before* the\n     * resource is loaded.\n     *\n     * @param fn - The middleware function to register.\n     * @return The loader itself.\n     */Loader.prototype.pre=function(fn){this._beforeMiddleware.push(fn);return this;};/**\n     * Sets up a middleware function that will run *after* the\n     * resource is loaded.\n     *\n     * @param fn - The middleware function to register.\n     * @return The loader itself.\n     */Loader.prototype.use=function(fn){this._afterMiddleware.push(fn);return this;};/**\n     * Resets the queue of the loader to prepare for a new load.\n     *\n     * @return The loader itself.\n     */Loader.prototype.reset=function(){this.progress=0;this.loading=false;this._queue.kill();this._queue.pause();// abort all resource loads\nfor(var k in this.resources){var res=this.resources[k];if(res._onLoadBinding){res._onLoadBinding.detach();}if(res.isLoading){res.abort('loader reset');}}this.resources={};return this;};/**\n     * Starts loading the queued resources.\n     * @param cb - Optional callback that will be bound to the `complete` event.\n     * @return The loader itself.\n     */Loader.prototype.load=function(cb){// register complete callback if they pass one\nif(typeof cb==='function'){this.onComplete.once(cb);}// if the queue has already started we are done here\nif(this.loading){return this;}if(this._queue.idle()){this._onStart();this._onComplete();}else{// distribute progress chunks\nvar numTasks=this._queue._tasks.length;var chunk=MAX_PROGRESS/numTasks;for(var i=0;i<this._queue._tasks.length;++i){this._queue._tasks[i].data.progressChunk=chunk;}// notify we are starting\nthis._onStart();// start loading\nthis._queue.resume();}return this;};Object.defineProperty(Loader.prototype,\"concurrency\",{/**\n         * The number of resources to load concurrently.\n         *\n         * @default 10\n         */get:function get(){return this._queue.concurrency;},set:function set(concurrency){this._queue.concurrency=concurrency;},enumerable:false,configurable:true});/**\n     * Prepares a url for usage based on the configuration of this object\n     * @param url - The url to prepare.\n     * @return The prepared url.\n     */Loader.prototype._prepareUrl=function(url){var parsedUrl=parseUri(url,{strictMode:true});var result;// absolute url, just use it as is.\nif(parsedUrl.protocol||!parsedUrl.path||url.indexOf('//')===0){result=url;}// if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\nelse if(this.baseUrl.length&&this.baseUrl.lastIndexOf('/')!==this.baseUrl.length-1&&url.charAt(0)!=='/'){result=this.baseUrl+\"/\"+url;}else{result=this.baseUrl+url;}// if we need to add a default querystring, there is a bit more work\nif(this.defaultQueryString){var hash=rgxExtractUrlHash.exec(result)[0];result=result.slice(0,result.length-hash.length);if(result.indexOf('?')!==-1){result+=\"&\"+this.defaultQueryString;}else{result+=\"?\"+this.defaultQueryString;}result+=hash;}return result;};/**\n     * Loads a single resource.\n     *\n     * @param resource - The resource to load.\n     * @param dequeue - The function to call when we need to dequeue this item.\n     */Loader.prototype._loadResource=function(resource,dequeue){var _this=this;resource._dequeue=dequeue;// run before middleware\nAsyncQueue.eachSeries(this._beforeMiddleware,function(fn,next){fn.call(_this,resource,function(){// if the before middleware marks the resource as complete,\n// break and don't process any more before middleware\nnext(resource.isComplete?{}:null);});},function(){if(resource.isComplete){_this._onLoad(resource);}else{resource._onLoadBinding=resource.onComplete.once(_this._onLoad,_this);resource.load();}},true);};/**\n     * Called once loading has started.\n     */Loader.prototype._onStart=function(){this.progress=0;this.loading=true;this.onStart.dispatch(this);};/**\n     * Called once each resource has loaded.\n     */Loader.prototype._onComplete=function(){this.progress=MAX_PROGRESS;this.loading=false;this.onComplete.dispatch(this,this.resources);};/**\n     * Called each time a resources is loaded.\n     * @param resource - The resource that was loaded\n     */Loader.prototype._onLoad=function(resource){var _this=this;resource._onLoadBinding=null;// remove this resource from the async queue, and add it to our list of resources that are being parsed\nthis._resourcesParsing.push(resource);resource._dequeue();// run all the after middleware for this resource\nAsyncQueue.eachSeries(this._afterMiddleware,function(fn,next){fn.call(_this,resource,next);},function(){resource.onAfterMiddleware.dispatch(resource);_this.progress=Math.min(MAX_PROGRESS,_this.progress+resource.progressChunk);_this.onProgress.dispatch(_this,resource);if(resource.error){_this.onError.dispatch(resource.error,_this,resource);}else{_this.onLoad.dispatch(_this,resource);}_this._resourcesParsing.splice(_this._resourcesParsing.indexOf(resource),1);// do completion check\nif(_this._queue.idle()&&_this._resourcesParsing.length===0){_this._onComplete();}},true);};/**\n     * Destroy the loader, removes references.\n     */Loader.prototype.destroy=function(){if(!this._protected){this.reset();}};Object.defineProperty(Loader,\"shared\",{/**\n         * A premade instance of the loader that can be used to load resources.\n         */get:function get(){var shared=Loader._shared;if(!shared){shared=new Loader();shared._protected=true;Loader._shared=shared;}return shared;},enumerable:false,configurable:true});/**\n     * Adds a Loader plugin for the global shared loader and all\n     * new Loader instances created.\n     *\n     * @param plugin - The plugin to add\n     * @return Reference to PIXI.Loader for chaining\n     */Loader.registerPlugin=function(plugin){Loader._plugins.push(plugin);if(plugin.add){plugin.add();}return Loader;};Loader._plugins=[];return Loader;}();Loader.prototype.add=function add(name,url,options,callback){// special case of an array of objects or urls\nif(Array.isArray(name)){for(var i=0;i<name.length;++i){this.add(name[i]);}return this;}// if an object is passed instead of params\nif(typeof name==='object'){options=name;callback=url||options.callback||options.onComplete;url=options.url;name=options.name||options.key||options.url;}// case where no name is passed shift all args over by one.\nif(typeof url!=='string'){callback=options;options=url;url=name;}// now that we shifted make sure we have a proper url.\nif(typeof url!=='string'){throw new Error('No url passed to add resource to loader.');}// options are optional so people might pass a function and no options\nif(typeof options==='function'){callback=options;options=null;}return this._add(name,url,options,callback);};/**\n * Application plugin for supporting loader option. Installing the LoaderPlugin\n * is not necessary if using **pixi.js** or **pixi.js-legacy**.\n * @example\n * import {AppLoaderPlugin} from '@pixi/loaders';\n * import {Application} from '@pixi/app';\n * Application.registerPlugin(AppLoaderPlugin);\n * @memberof PIXI\n */var AppLoaderPlugin=/** @class */function(){function AppLoaderPlugin(){}/**\n     * Called on application constructor\n     *\n     * @private\n     */AppLoaderPlugin.init=function(options){options=Object.assign({sharedLoader:false},options);this.loader=options.sharedLoader?Loader.shared:new Loader();};/**\n     * Called when application destroyed\n     *\n     * @private\n     */AppLoaderPlugin.destroy=function(){if(this.loader){this.loader.destroy();this.loader=null;}};return AppLoaderPlugin;}();/**\n * Loader plugin for handling Texture resources.\n *\n * @memberof PIXI\n */var TextureLoader=/** @class */function(){function TextureLoader(){}/**\n     * Handle SVG elements a text, render with SVGResource.\n     */TextureLoader.add=function(){LoaderResource.setExtensionLoadType('svg',LoaderResource.LOAD_TYPE.XHR);LoaderResource.setExtensionXhrType('svg',LoaderResource.XHR_RESPONSE_TYPE.TEXT);};/**\n     * Called after a resource is loaded.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param resource\n     * @param {function} next\n     */TextureLoader.use=function(resource,next){// create a new texture if the data is an Image object\nif(resource.data&&(resource.type===LoaderResource.TYPE.IMAGE||resource.extension==='svg')){var data=resource.data,url=resource.url,name=resource.name,metadata=resource.metadata;Texture.fromLoader(data,url,name,metadata).then(function(texture){resource.texture=texture;next();})// TODO: handle errors in Texture.fromLoader\n// so we can pass them to the Loader\n.catch(next);}else{next();}};return TextureLoader;}();var _keyStr='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';/**\n * Encodes binary into base64.\n *\n * @function encodeBinary\n * @param {string} input - The input data to encode.\n * @returns {string} The encoded base64 string\n */function encodeBinary(input){var output='';var inx=0;while(inx<input.length){// Fill byte buffer array\nvar bytebuffer=[0,0,0];var encodedCharIndexes=[0,0,0,0];for(var jnx=0;jnx<bytebuffer.length;++jnx){if(inx<input.length){// throw away high-order byte, as documented at:\n// https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\nbytebuffer[jnx]=input.charCodeAt(inx++)&0xff;}else{bytebuffer[jnx]=0;}}// Get each encoded character, 6 bits at a time\n// index 1: first 6 bits\nencodedCharIndexes[0]=bytebuffer[0]>>2;// index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\nencodedCharIndexes[1]=(bytebuffer[0]&0x3)<<4|bytebuffer[1]>>4;// index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\nencodedCharIndexes[2]=(bytebuffer[1]&0x0f)<<2|bytebuffer[2]>>6;// index 3: forth 6 bits (6 least significant bits from input byte 3)\nencodedCharIndexes[3]=bytebuffer[2]&0x3f;// Determine whether padding happened, and adjust accordingly\nvar paddingBytes=inx-(input.length-1);switch(paddingBytes){case 2:// Set last 2 characters to padding char\nencodedCharIndexes[3]=64;encodedCharIndexes[2]=64;break;case 1:// Set last character to padding char\nencodedCharIndexes[3]=64;break;}// Now we will grab each appropriate character out of our keystring\n// based on our index array and append it to the output string\nfor(var jnx=0;jnx<encodedCharIndexes.length;++jnx){output+=_keyStr.charAt(encodedCharIndexes[jnx]);}}return output;}var Url=self.URL||self.webkitURL;/**\n * A middleware for transforming XHR loaded Blobs into more useful objects\n *\n * @ignore\n * @function parsing\n * @example\n * import { Loader, middleware } from 'resource-loader';\n * const loader = new Loader();\n * loader.use(middleware.parsing);\n * @param resource - Current Resource\n * @param next - Callback when complete\n */function parsing(resource,next){if(!resource.data){next();return;}// if this was an XHR load of a blob\nif(resource.xhr&&resource.xhrType===LoaderResource.XHR_RESPONSE_TYPE.BLOB){// if there is no blob support we probably got a binary string back\nif(!self.Blob||typeof resource.data==='string'){var type=resource.xhr.getResponseHeader('content-type');// this is an image, convert the binary string into a data url\nif(type&&type.indexOf('image')===0){resource.data=new Image();resource.data.src=\"data:\"+type+\";base64,\"+encodeBinary(resource.xhr.responseText);resource.type=LoaderResource.TYPE.IMAGE;// wait until the image loads and then callback\nresource.data.onload=function(){resource.data.onload=null;next();};// next will be called on load\nreturn;}}// if content type says this is an image, then we should transform the blob into an Image object\nelse if(resource.data.type.indexOf('image')===0){var src_1=Url.createObjectURL(resource.data);resource.blob=resource.data;resource.data=new Image();resource.data.src=src_1;resource.type=LoaderResource.TYPE.IMAGE;// cleanup the no longer used blob after the image loads\n// TODO: Is this correct? Will the image be invalid after revoking?\nresource.data.onload=function(){Url.revokeObjectURL(src_1);resource.data.onload=null;next();};// next will be called on load.\nreturn;}}next();}// parse any blob into more usable objects (e.g. Image)\nLoader.registerPlugin({use:parsing});// parse any Image objects into textures\nLoader.registerPlugin(TextureLoader);export{AppLoaderPlugin,Loader,LoaderResource,TextureLoader};","map":null,"metadata":{},"sourceType":"module"}