{"ast":null,"code":"/*!\n * @pixi/mixin-cache-as-bitmap - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{RenderTexture,BaseTexture,Texture}from'@pixi/core';import{Sprite}from'@pixi/sprite';import{DisplayObject}from'@pixi/display';import{Matrix}from'@pixi/math';import{uid}from'@pixi/utils';import{settings}from'@pixi/settings';/*!\n * @pixi/constants - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */ /**\n * Different types of environments for WebGL.\n *\n * @static\n * @memberof PIXI\n * @name ENV\n * @enum {number}\n * @property {number} WEBGL_LEGACY - Used for older v1 WebGL devices. PixiJS will aim to ensure compatibility\n *  with older / less advanced devices. If you experience unexplained flickering prefer this environment.\n * @property {number} WEBGL - Version 1 of WebGL\n * @property {number} WEBGL2 - Version 2 of WebGL\n */var ENV;(function(ENV){ENV[ENV[\"WEBGL_LEGACY\"]=0]=\"WEBGL_LEGACY\";ENV[ENV[\"WEBGL\"]=1]=\"WEBGL\";ENV[ENV[\"WEBGL2\"]=2]=\"WEBGL2\";})(ENV||(ENV={}));/**\n * Constant to identify the Renderer Type.\n *\n * @static\n * @memberof PIXI\n * @name RENDERER_TYPE\n * @enum {number}\n * @property {number} UNKNOWN - Unknown render type.\n * @property {number} WEBGL - WebGL render type.\n * @property {number} CANVAS - Canvas render type.\n */var RENDERER_TYPE;(function(RENDERER_TYPE){RENDERER_TYPE[RENDERER_TYPE[\"UNKNOWN\"]=0]=\"UNKNOWN\";RENDERER_TYPE[RENDERER_TYPE[\"WEBGL\"]=1]=\"WEBGL\";RENDERER_TYPE[RENDERER_TYPE[\"CANVAS\"]=2]=\"CANVAS\";})(RENDERER_TYPE||(RENDERER_TYPE={}));/**\n * Bitwise OR of masks that indicate the buffers to be cleared.\n *\n * @static\n * @memberof PIXI\n * @name BUFFER_BITS\n * @enum {number}\n * @property {number} COLOR - Indicates the buffers currently enabled for color writing.\n * @property {number} DEPTH - Indicates the depth buffer.\n * @property {number} STENCIL - Indicates the stencil buffer.\n */var BUFFER_BITS;(function(BUFFER_BITS){BUFFER_BITS[BUFFER_BITS[\"COLOR\"]=16384]=\"COLOR\";BUFFER_BITS[BUFFER_BITS[\"DEPTH\"]=256]=\"DEPTH\";BUFFER_BITS[BUFFER_BITS[\"STENCIL\"]=1024]=\"STENCIL\";})(BUFFER_BITS||(BUFFER_BITS={}));/**\n * Various blend modes supported by PIXI.\n *\n * IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.\n * Anything else will silently act like NORMAL.\n *\n * @memberof PIXI\n * @name BLEND_MODES\n * @enum {number}\n * @property {number} NORMAL\n * @property {number} ADD\n * @property {number} MULTIPLY\n * @property {number} SCREEN\n * @property {number} OVERLAY\n * @property {number} DARKEN\n * @property {number} LIGHTEN\n * @property {number} COLOR_DODGE\n * @property {number} COLOR_BURN\n * @property {number} HARD_LIGHT\n * @property {number} SOFT_LIGHT\n * @property {number} DIFFERENCE\n * @property {number} EXCLUSION\n * @property {number} HUE\n * @property {number} SATURATION\n * @property {number} COLOR\n * @property {number} LUMINOSITY\n * @property {number} NORMAL_NPM\n * @property {number} ADD_NPM\n * @property {number} SCREEN_NPM\n * @property {number} NONE\n * @property {number} SRC_IN\n * @property {number} SRC_OUT\n * @property {number} SRC_ATOP\n * @property {number} DST_OVER\n * @property {number} DST_IN\n * @property {number} DST_OUT\n * @property {number} DST_ATOP\n * @property {number} SUBTRACT\n * @property {number} SRC_OVER\n * @property {number} ERASE\n * @property {number} XOR\n */var BLEND_MODES;(function(BLEND_MODES){BLEND_MODES[BLEND_MODES[\"NORMAL\"]=0]=\"NORMAL\";BLEND_MODES[BLEND_MODES[\"ADD\"]=1]=\"ADD\";BLEND_MODES[BLEND_MODES[\"MULTIPLY\"]=2]=\"MULTIPLY\";BLEND_MODES[BLEND_MODES[\"SCREEN\"]=3]=\"SCREEN\";BLEND_MODES[BLEND_MODES[\"OVERLAY\"]=4]=\"OVERLAY\";BLEND_MODES[BLEND_MODES[\"DARKEN\"]=5]=\"DARKEN\";BLEND_MODES[BLEND_MODES[\"LIGHTEN\"]=6]=\"LIGHTEN\";BLEND_MODES[BLEND_MODES[\"COLOR_DODGE\"]=7]=\"COLOR_DODGE\";BLEND_MODES[BLEND_MODES[\"COLOR_BURN\"]=8]=\"COLOR_BURN\";BLEND_MODES[BLEND_MODES[\"HARD_LIGHT\"]=9]=\"HARD_LIGHT\";BLEND_MODES[BLEND_MODES[\"SOFT_LIGHT\"]=10]=\"SOFT_LIGHT\";BLEND_MODES[BLEND_MODES[\"DIFFERENCE\"]=11]=\"DIFFERENCE\";BLEND_MODES[BLEND_MODES[\"EXCLUSION\"]=12]=\"EXCLUSION\";BLEND_MODES[BLEND_MODES[\"HUE\"]=13]=\"HUE\";BLEND_MODES[BLEND_MODES[\"SATURATION\"]=14]=\"SATURATION\";BLEND_MODES[BLEND_MODES[\"COLOR\"]=15]=\"COLOR\";BLEND_MODES[BLEND_MODES[\"LUMINOSITY\"]=16]=\"LUMINOSITY\";BLEND_MODES[BLEND_MODES[\"NORMAL_NPM\"]=17]=\"NORMAL_NPM\";BLEND_MODES[BLEND_MODES[\"ADD_NPM\"]=18]=\"ADD_NPM\";BLEND_MODES[BLEND_MODES[\"SCREEN_NPM\"]=19]=\"SCREEN_NPM\";BLEND_MODES[BLEND_MODES[\"NONE\"]=20]=\"NONE\";BLEND_MODES[BLEND_MODES[\"SRC_OVER\"]=0]=\"SRC_OVER\";BLEND_MODES[BLEND_MODES[\"SRC_IN\"]=21]=\"SRC_IN\";BLEND_MODES[BLEND_MODES[\"SRC_OUT\"]=22]=\"SRC_OUT\";BLEND_MODES[BLEND_MODES[\"SRC_ATOP\"]=23]=\"SRC_ATOP\";BLEND_MODES[BLEND_MODES[\"DST_OVER\"]=24]=\"DST_OVER\";BLEND_MODES[BLEND_MODES[\"DST_IN\"]=25]=\"DST_IN\";BLEND_MODES[BLEND_MODES[\"DST_OUT\"]=26]=\"DST_OUT\";BLEND_MODES[BLEND_MODES[\"DST_ATOP\"]=27]=\"DST_ATOP\";BLEND_MODES[BLEND_MODES[\"ERASE\"]=26]=\"ERASE\";BLEND_MODES[BLEND_MODES[\"SUBTRACT\"]=28]=\"SUBTRACT\";BLEND_MODES[BLEND_MODES[\"XOR\"]=29]=\"XOR\";})(BLEND_MODES||(BLEND_MODES={}));/**\n * Various webgl draw modes. These can be used to specify which GL drawMode to use\n * under certain situations and renderers.\n *\n * @memberof PIXI\n * @static\n * @name DRAW_MODES\n * @enum {number}\n * @property {number} POINTS\n * @property {number} LINES\n * @property {number} LINE_LOOP\n * @property {number} LINE_STRIP\n * @property {number} TRIANGLES\n * @property {number} TRIANGLE_STRIP\n * @property {number} TRIANGLE_FAN\n */var DRAW_MODES;(function(DRAW_MODES){DRAW_MODES[DRAW_MODES[\"POINTS\"]=0]=\"POINTS\";DRAW_MODES[DRAW_MODES[\"LINES\"]=1]=\"LINES\";DRAW_MODES[DRAW_MODES[\"LINE_LOOP\"]=2]=\"LINE_LOOP\";DRAW_MODES[DRAW_MODES[\"LINE_STRIP\"]=3]=\"LINE_STRIP\";DRAW_MODES[DRAW_MODES[\"TRIANGLES\"]=4]=\"TRIANGLES\";DRAW_MODES[DRAW_MODES[\"TRIANGLE_STRIP\"]=5]=\"TRIANGLE_STRIP\";DRAW_MODES[DRAW_MODES[\"TRIANGLE_FAN\"]=6]=\"TRIANGLE_FAN\";})(DRAW_MODES||(DRAW_MODES={}));/**\n * Various GL texture/resources formats.\n *\n * @memberof PIXI\n * @static\n * @name FORMATS\n * @enum {number}\n * @property {number} RGBA=6408\n * @property {number} RGB=6407\n * @property {number} RG=33319\n * @property {number} RED=6403\n * @property {number} RGBA_INTEGER=36249\n * @property {number} RGB_INTEGER=36248\n * @property {number} RG_INTEGER=33320\n * @property {number} RED_INTEGER=36244\n * @property {number} ALPHA=6406\n * @property {number} LUMINANCE=6409\n * @property {number} LUMINANCE_ALPHA=6410\n * @property {number} DEPTH_COMPONENT=6402\n * @property {number} DEPTH_STENCIL=34041\n */var FORMATS;(function(FORMATS){FORMATS[FORMATS[\"RGBA\"]=6408]=\"RGBA\";FORMATS[FORMATS[\"RGB\"]=6407]=\"RGB\";FORMATS[FORMATS[\"RG\"]=33319]=\"RG\";FORMATS[FORMATS[\"RED\"]=6403]=\"RED\";FORMATS[FORMATS[\"RGBA_INTEGER\"]=36249]=\"RGBA_INTEGER\";FORMATS[FORMATS[\"RGB_INTEGER\"]=36248]=\"RGB_INTEGER\";FORMATS[FORMATS[\"RG_INTEGER\"]=33320]=\"RG_INTEGER\";FORMATS[FORMATS[\"RED_INTEGER\"]=36244]=\"RED_INTEGER\";FORMATS[FORMATS[\"ALPHA\"]=6406]=\"ALPHA\";FORMATS[FORMATS[\"LUMINANCE\"]=6409]=\"LUMINANCE\";FORMATS[FORMATS[\"LUMINANCE_ALPHA\"]=6410]=\"LUMINANCE_ALPHA\";FORMATS[FORMATS[\"DEPTH_COMPONENT\"]=6402]=\"DEPTH_COMPONENT\";FORMATS[FORMATS[\"DEPTH_STENCIL\"]=34041]=\"DEPTH_STENCIL\";})(FORMATS||(FORMATS={}));/**\n * Various GL target types.\n *\n * @memberof PIXI\n * @static\n * @name TARGETS\n * @enum {number}\n * @property {number} TEXTURE_2D=3553\n * @property {number} TEXTURE_CUBE_MAP=34067\n * @property {number} TEXTURE_2D_ARRAY=35866\n * @property {number} TEXTURE_CUBE_MAP_POSITIVE_X=34069\n * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_X=34070\n * @property {number} TEXTURE_CUBE_MAP_POSITIVE_Y=34071\n * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_Y=34072\n * @property {number} TEXTURE_CUBE_MAP_POSITIVE_Z=34073\n * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_Z=34074\n */var TARGETS;(function(TARGETS){TARGETS[TARGETS[\"TEXTURE_2D\"]=3553]=\"TEXTURE_2D\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP\"]=34067]=\"TEXTURE_CUBE_MAP\";TARGETS[TARGETS[\"TEXTURE_2D_ARRAY\"]=35866]=\"TEXTURE_2D_ARRAY\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_POSITIVE_X\"]=34069]=\"TEXTURE_CUBE_MAP_POSITIVE_X\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"]=34070]=\"TEXTURE_CUBE_MAP_NEGATIVE_X\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"]=34071]=\"TEXTURE_CUBE_MAP_POSITIVE_Y\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"]=34072]=\"TEXTURE_CUBE_MAP_NEGATIVE_Y\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"]=34073]=\"TEXTURE_CUBE_MAP_POSITIVE_Z\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"]=34074]=\"TEXTURE_CUBE_MAP_NEGATIVE_Z\";})(TARGETS||(TARGETS={}));/**\n * Various GL data format types.\n *\n * @memberof PIXI\n * @static\n * @name TYPES\n * @enum {number}\n * @property {number} UNSIGNED_BYTE=5121\n * @property {number} UNSIGNED_SHORT=5123\n * @property {number} UNSIGNED_SHORT_5_6_5=33635\n * @property {number} UNSIGNED_SHORT_4_4_4_4=32819\n * @property {number} UNSIGNED_SHORT_5_5_5_1=32820\n * @property {number} UNSIGNED_INT=5125\n * @property {number} UNSIGNED_INT_10F_11F_11F_REV=35899\n * @property {number} UNSIGNED_INT_2_10_10_10_REV=33640\n * @property {number} UNSIGNED_INT_24_8=34042\n * @property {number} UNSIGNED_INT_5_9_9_9_REV=35902\n * @property {number} BYTE=5120\n * @property {number} SHORT=5122\n * @property {number} INT=5124\n * @property {number} FLOAT=5126\n * @property {number} FLOAT_32_UNSIGNED_INT_24_8_REV=36269\n * @property {number} HALF_FLOAT=36193\n */var TYPES;(function(TYPES){TYPES[TYPES[\"UNSIGNED_BYTE\"]=5121]=\"UNSIGNED_BYTE\";TYPES[TYPES[\"UNSIGNED_SHORT\"]=5123]=\"UNSIGNED_SHORT\";TYPES[TYPES[\"UNSIGNED_SHORT_5_6_5\"]=33635]=\"UNSIGNED_SHORT_5_6_5\";TYPES[TYPES[\"UNSIGNED_SHORT_4_4_4_4\"]=32819]=\"UNSIGNED_SHORT_4_4_4_4\";TYPES[TYPES[\"UNSIGNED_SHORT_5_5_5_1\"]=32820]=\"UNSIGNED_SHORT_5_5_5_1\";TYPES[TYPES[\"UNSIGNED_INT\"]=5125]=\"UNSIGNED_INT\";TYPES[TYPES[\"UNSIGNED_INT_10F_11F_11F_REV\"]=35899]=\"UNSIGNED_INT_10F_11F_11F_REV\";TYPES[TYPES[\"UNSIGNED_INT_2_10_10_10_REV\"]=33640]=\"UNSIGNED_INT_2_10_10_10_REV\";TYPES[TYPES[\"UNSIGNED_INT_24_8\"]=34042]=\"UNSIGNED_INT_24_8\";TYPES[TYPES[\"UNSIGNED_INT_5_9_9_9_REV\"]=35902]=\"UNSIGNED_INT_5_9_9_9_REV\";TYPES[TYPES[\"BYTE\"]=5120]=\"BYTE\";TYPES[TYPES[\"SHORT\"]=5122]=\"SHORT\";TYPES[TYPES[\"INT\"]=5124]=\"INT\";TYPES[TYPES[\"FLOAT\"]=5126]=\"FLOAT\";TYPES[TYPES[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"]=36269]=\"FLOAT_32_UNSIGNED_INT_24_8_REV\";TYPES[TYPES[\"HALF_FLOAT\"]=36193]=\"HALF_FLOAT\";})(TYPES||(TYPES={}));/**\n * Various sampler types. Correspond to `sampler`, `isampler`, `usampler` GLSL types respectively.\n * WebGL1 works only with FLOAT.\n *\n * @memberof PIXI\n * @static\n * @name SAMPLER_TYPES\n * @enum {number}\n * @property {number} FLOAT=0\n * @property {number} INT=1\n * @property {number} UINT=2\n */var SAMPLER_TYPES;(function(SAMPLER_TYPES){SAMPLER_TYPES[SAMPLER_TYPES[\"FLOAT\"]=0]=\"FLOAT\";SAMPLER_TYPES[SAMPLER_TYPES[\"INT\"]=1]=\"INT\";SAMPLER_TYPES[SAMPLER_TYPES[\"UINT\"]=2]=\"UINT\";})(SAMPLER_TYPES||(SAMPLER_TYPES={}));/**\n * The scale modes that are supported by pixi.\n *\n * The {@link PIXI.settings.SCALE_MODE} scale mode affects the default scaling mode of future operations.\n * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.\n *\n * @memberof PIXI\n * @static\n * @name SCALE_MODES\n * @enum {number}\n * @property {number} LINEAR Smooth scaling\n * @property {number} NEAREST Pixelating scaling\n */var SCALE_MODES;(function(SCALE_MODES){SCALE_MODES[SCALE_MODES[\"NEAREST\"]=0]=\"NEAREST\";SCALE_MODES[SCALE_MODES[\"LINEAR\"]=1]=\"LINEAR\";})(SCALE_MODES||(SCALE_MODES={}));/**\n * The wrap modes that are supported by pixi.\n *\n * The {@link PIXI.settings.WRAP_MODE} wrap mode affects the default wrapping mode of future operations.\n * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.\n * If the texture is non power of two then clamp will be used regardless as WebGL can\n * only use REPEAT if the texture is po2.\n *\n * This property only affects WebGL.\n *\n * @name WRAP_MODES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} CLAMP - The textures uvs are clamped\n * @property {number} REPEAT - The texture uvs tile and repeat\n * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring\n */var WRAP_MODES;(function(WRAP_MODES){WRAP_MODES[WRAP_MODES[\"CLAMP\"]=33071]=\"CLAMP\";WRAP_MODES[WRAP_MODES[\"REPEAT\"]=10497]=\"REPEAT\";WRAP_MODES[WRAP_MODES[\"MIRRORED_REPEAT\"]=33648]=\"MIRRORED_REPEAT\";})(WRAP_MODES||(WRAP_MODES={}));/**\n * Mipmap filtering modes that are supported by pixi.\n *\n * The {@link PIXI.settings.MIPMAP_TEXTURES} affects default texture filtering.\n * Mipmaps are generated for a baseTexture if its `mipmap` field is `ON`,\n * or its `POW2` and texture dimensions are powers of 2.\n * Due to platform restriction, `ON` option will work like `POW2` for webgl-1.\n *\n * This property only affects WebGL.\n *\n * @name MIPMAP_MODES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} OFF - No mipmaps\n * @property {number} POW2 - Generate mipmaps if texture dimensions are pow2\n * @property {number} ON - Always generate mipmaps\n * @property {number} ON_MANUAL - Use mipmaps, but do not auto-generate them; this is used with a resource\n *   that supports buffering each level-of-detail.\n */var MIPMAP_MODES;(function(MIPMAP_MODES){MIPMAP_MODES[MIPMAP_MODES[\"OFF\"]=0]=\"OFF\";MIPMAP_MODES[MIPMAP_MODES[\"POW2\"]=1]=\"POW2\";MIPMAP_MODES[MIPMAP_MODES[\"ON\"]=2]=\"ON\";MIPMAP_MODES[MIPMAP_MODES[\"ON_MANUAL\"]=3]=\"ON_MANUAL\";})(MIPMAP_MODES||(MIPMAP_MODES={}));/**\n * How to treat textures with premultiplied alpha\n *\n * @name ALPHA_MODES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} NO_PREMULTIPLIED_ALPHA - Source is not premultiplied, leave it like that.\n *  Option for compressed and data textures that are created from typed arrays.\n * @property {number} PREMULTIPLY_ON_UPLOAD - Source is not premultiplied, premultiply on upload.\n *  Default option, used for all loaded images.\n * @property {number} PREMULTIPLIED_ALPHA - Source is already premultiplied\n *  Example: spine atlases with `_pma` suffix.\n * @property {number} NPM - Alias for NO_PREMULTIPLIED_ALPHA.\n * @property {number} UNPACK - Default option, alias for PREMULTIPLY_ON_UPLOAD.\n * @property {number} PMA - Alias for PREMULTIPLIED_ALPHA.\n */var ALPHA_MODES;(function(ALPHA_MODES){ALPHA_MODES[ALPHA_MODES[\"NPM\"]=0]=\"NPM\";ALPHA_MODES[ALPHA_MODES[\"UNPACK\"]=1]=\"UNPACK\";ALPHA_MODES[ALPHA_MODES[\"PMA\"]=2]=\"PMA\";ALPHA_MODES[ALPHA_MODES[\"NO_PREMULTIPLIED_ALPHA\"]=0]=\"NO_PREMULTIPLIED_ALPHA\";ALPHA_MODES[ALPHA_MODES[\"PREMULTIPLY_ON_UPLOAD\"]=1]=\"PREMULTIPLY_ON_UPLOAD\";ALPHA_MODES[ALPHA_MODES[\"PREMULTIPLY_ALPHA\"]=2]=\"PREMULTIPLY_ALPHA\";ALPHA_MODES[ALPHA_MODES[\"PREMULTIPLIED_ALPHA\"]=2]=\"PREMULTIPLIED_ALPHA\";})(ALPHA_MODES||(ALPHA_MODES={}));/**\n * Configure whether filter textures are cleared after binding.\n *\n * Filter textures need not be cleared if the filter does not use pixel blending. {@link CLEAR_MODES.BLIT} will detect\n * this and skip clearing as an optimization.\n *\n * @name CLEAR_MODES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} BLEND - Do not clear the filter texture. The filter's output will blend on top of the output texture.\n * @property {number} CLEAR - Always clear the filter texture.\n * @property {number} BLIT - Clear only if {@link FilterSystem.forceClear} is set or if the filter uses pixel blending.\n * @property {number} NO - Alias for BLEND, same as `false` in earlier versions\n * @property {number} YES - Alias for CLEAR, same as `true` in earlier versions\n * @property {number} AUTO - Alias for BLIT\n */var CLEAR_MODES;(function(CLEAR_MODES){CLEAR_MODES[CLEAR_MODES[\"NO\"]=0]=\"NO\";CLEAR_MODES[CLEAR_MODES[\"YES\"]=1]=\"YES\";CLEAR_MODES[CLEAR_MODES[\"AUTO\"]=2]=\"AUTO\";CLEAR_MODES[CLEAR_MODES[\"BLEND\"]=0]=\"BLEND\";CLEAR_MODES[CLEAR_MODES[\"CLEAR\"]=1]=\"CLEAR\";CLEAR_MODES[CLEAR_MODES[\"BLIT\"]=2]=\"BLIT\";})(CLEAR_MODES||(CLEAR_MODES={}));/**\n * The gc modes that are supported by pixi.\n *\n * The {@link PIXI.settings.GC_MODE} Garbage Collection mode for PixiJS textures is AUTO\n * If set to GC_MODE, the renderer will occasionally check textures usage. If they are not\n * used for a specified period of time they will be removed from the GPU. They will of course\n * be uploaded again when they are required. This is a silent behind the scenes process that\n * should ensure that the GPU does not  get filled up.\n *\n * Handy for mobile devices!\n * This property only affects WebGL.\n *\n * @name GC_MODES\n * @enum {number}\n * @static\n * @memberof PIXI\n * @property {number} AUTO - Garbage collection will happen periodically automatically\n * @property {number} MANUAL - Garbage collection will need to be called manually\n */var GC_MODES;(function(GC_MODES){GC_MODES[GC_MODES[\"AUTO\"]=0]=\"AUTO\";GC_MODES[GC_MODES[\"MANUAL\"]=1]=\"MANUAL\";})(GC_MODES||(GC_MODES={}));/**\n * Constants that specify float precision in shaders.\n *\n * @name PRECISION\n * @memberof PIXI\n * @constant\n * @static\n * @enum {string}\n * @property {string} LOW='lowp'\n * @property {string} MEDIUM='mediump'\n * @property {string} HIGH='highp'\n */var PRECISION;(function(PRECISION){PRECISION[\"LOW\"]=\"lowp\";PRECISION[\"MEDIUM\"]=\"mediump\";PRECISION[\"HIGH\"]=\"highp\";})(PRECISION||(PRECISION={}));/**\n * Constants for mask implementations.\n * We use `type` suffix because it leads to very different behaviours\n *\n * @name MASK_TYPES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} NONE - Mask is ignored\n * @property {number} SCISSOR - Scissor mask, rectangle on screen, cheap\n * @property {number} STENCIL - Stencil mask, 1-bit, medium, works only if renderer supports stencil\n * @property {number} SPRITE - Mask that uses SpriteMaskFilter, uses temporary RenderTexture\n */var MASK_TYPES;(function(MASK_TYPES){MASK_TYPES[MASK_TYPES[\"NONE\"]=0]=\"NONE\";MASK_TYPES[MASK_TYPES[\"SCISSOR\"]=1]=\"SCISSOR\";MASK_TYPES[MASK_TYPES[\"STENCIL\"]=2]=\"STENCIL\";MASK_TYPES[MASK_TYPES[\"SPRITE\"]=3]=\"SPRITE\";})(MASK_TYPES||(MASK_TYPES={}));/**\n * Constants for multi-sampling antialiasing.\n *\n * @see PIXI.Framebuffer#multisample\n *\n * @name MSAA_QUALITY\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} NONE - No multisampling for this renderTexture\n * @property {number} LOW - Try 2 samples\n * @property {number} MEDIUM - Try 4 samples\n * @property {number} HIGH - Try 8 samples\n */var MSAA_QUALITY;(function(MSAA_QUALITY){MSAA_QUALITY[MSAA_QUALITY[\"NONE\"]=0]=\"NONE\";MSAA_QUALITY[MSAA_QUALITY[\"LOW\"]=2]=\"LOW\";MSAA_QUALITY[MSAA_QUALITY[\"MEDIUM\"]=4]=\"MEDIUM\";MSAA_QUALITY[MSAA_QUALITY[\"HIGH\"]=8]=\"HIGH\";})(MSAA_QUALITY||(MSAA_QUALITY={}));/**\n * Constants for various buffer types in Pixi\n *\n * @see PIXI.BUFFER_TYPE\n *\n * @name BUFFER_TYPE\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} ELEMENT_ARRAY_BUFFER - buffer type for using as an index buffer\n * @property {number} ARRAY_BUFFER - buffer type for using attribute data\n * @property {number} UNIFORM_BUFFER - the buffer type is for uniform buffer objects\n */var BUFFER_TYPE;(function(BUFFER_TYPE){BUFFER_TYPE[BUFFER_TYPE[\"ELEMENT_ARRAY_BUFFER\"]=34963]=\"ELEMENT_ARRAY_BUFFER\";BUFFER_TYPE[BUFFER_TYPE[\"ARRAY_BUFFER\"]=34962]=\"ARRAY_BUFFER\";// NOT YET SUPPORTED\nBUFFER_TYPE[BUFFER_TYPE[\"UNIFORM_BUFFER\"]=35345]=\"UNIFORM_BUFFER\";})(BUFFER_TYPE||(BUFFER_TYPE={}));var _tempMatrix=new Matrix();DisplayObject.prototype._cacheAsBitmap=false;DisplayObject.prototype._cacheData=null;DisplayObject.prototype._cacheAsBitmapResolution=null;DisplayObject.prototype._cacheAsBitmapMultisample=MSAA_QUALITY.NONE;// figured there's no point adding ALL the extra variables to prototype.\n// this model can hold the information needed. This can also be generated on demand as\n// most objects are not cached as bitmaps.\n/**\n * @class\n * @ignore\n * @private\n */var CacheData=/** @class */function(){function CacheData(){this.textureCacheId=null;this.originalRender=null;this.originalRenderCanvas=null;this.originalCalculateBounds=null;this.originalGetLocalBounds=null;this.originalUpdateTransform=null;this.originalDestroy=null;this.originalMask=null;this.originalFilterArea=null;this.originalContainsPoint=null;this.sprite=null;}return CacheData;}();Object.defineProperties(DisplayObject.prototype,{/**\n     * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution\n     * but can be overriden for performance. Lower values will reduce memory usage at the expense\n     * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.\n     * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.\n     *\n     * @member {number} cacheAsBitmapResolution\n     * @memberof PIXI.DisplayObject#\n     * @default null\n     */cacheAsBitmapResolution:{get:function get(){return this._cacheAsBitmapResolution;},set:function set(resolution){if(resolution===this._cacheAsBitmapResolution){return;}this._cacheAsBitmapResolution=resolution;if(this.cacheAsBitmap){// Toggle to re-render at the new resolution\nthis.cacheAsBitmap=false;this.cacheAsBitmap=true;}}},/**\n     * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's\n     * sample count is used.\n     * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.\n     *\n     * @member {number} cacheAsBitmapMultisample\n     * @memberof PIXI.DisplayObject#\n     * @default PIXI.MSAA_QUALITY.NONE\n     */cacheAsBitmapMultisample:{get:function get(){return this._cacheAsBitmapMultisample;},set:function set(multisample){if(multisample===this._cacheAsBitmapMultisample){return;}this._cacheAsBitmapMultisample=multisample;if(this.cacheAsBitmap){// Toggle to re-render with new multisample\nthis.cacheAsBitmap=false;this.cacheAsBitmap=true;}}},/**\n     * Set this to true if you want this display object to be cached as a bitmap.\n     * This basically takes a snap shot of the display object as it is at that moment. It can\n     * provide a performance benefit for complex static displayObjects.\n     * To remove simply set this property to `false`\n     *\n     * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true\n     * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.\n     *\n     * @member {boolean}\n     * @memberof PIXI.DisplayObject#\n     */cacheAsBitmap:{get:function get(){return this._cacheAsBitmap;},set:function set(value){if(this._cacheAsBitmap===value){return;}this._cacheAsBitmap=value;var data;if(value){if(!this._cacheData){this._cacheData=new CacheData();}data=this._cacheData;data.originalRender=this.render;data.originalRenderCanvas=this.renderCanvas;data.originalUpdateTransform=this.updateTransform;data.originalCalculateBounds=this.calculateBounds;data.originalGetLocalBounds=this.getLocalBounds;data.originalDestroy=this.destroy;data.originalContainsPoint=this.containsPoint;data.originalMask=this._mask;data.originalFilterArea=this.filterArea;this.render=this._renderCached;this.renderCanvas=this._renderCachedCanvas;this.destroy=this._cacheAsBitmapDestroy;}else{data=this._cacheData;if(data.sprite){this._destroyCachedDisplayObject();}this.render=data.originalRender;this.renderCanvas=data.originalRenderCanvas;this.calculateBounds=data.originalCalculateBounds;this.getLocalBounds=data.originalGetLocalBounds;this.destroy=data.originalDestroy;this.updateTransform=data.originalUpdateTransform;this.containsPoint=data.originalContainsPoint;this._mask=data.originalMask;this.filterArea=data.originalFilterArea;}}}});/**\n * Renders a cached version of the sprite with WebGL\n *\n * @private\n * @method _renderCached\n * @memberof PIXI.DisplayObject#\n * @param {PIXI.Renderer} renderer - the WebGL renderer\n */DisplayObject.prototype._renderCached=function _renderCached(renderer){if(!this.visible||this.worldAlpha<=0||!this.renderable){return;}this._initCachedDisplayObject(renderer);this._cacheData.sprite.transform._worldID=this.transform._worldID;this._cacheData.sprite.worldAlpha=this.worldAlpha;this._cacheData.sprite._render(renderer);};/**\n * Prepares the WebGL renderer to cache the sprite\n *\n * @private\n * @method _initCachedDisplayObject\n * @memberof PIXI.DisplayObject#\n * @param {PIXI.Renderer} renderer - the WebGL renderer\n */DisplayObject.prototype._initCachedDisplayObject=function _initCachedDisplayObject(renderer){var _a;if(this._cacheData&&this._cacheData.sprite){return;}// make sure alpha is set to 1 otherwise it will get rendered as invisible!\nvar cacheAlpha=this.alpha;this.alpha=1;// first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)\nrenderer.batch.flush();// this.filters= [];\n// next we find the dimensions of the untransformed object\n// this function also calls updatetransform on all its children as part of the measuring.\n// This means we don't need to update the transform again in this function\n// TODO pass an object to clone too? saves having to create a new one each time!\nvar bounds=this.getLocalBounds(null,true).clone();// add some padding!\nif(this.filters&&this.filters.length){var padding=this.filters[0].padding;bounds.pad(padding);}bounds.ceil(settings.RESOLUTION);// for now we cache the current renderTarget that the WebGL renderer is currently using.\n// this could be more elegant..\nvar cachedRenderTexture=renderer.renderTexture.current;var cachedSourceFrame=renderer.renderTexture.sourceFrame.clone();var cachedDestinationFrame=renderer.renderTexture.destinationFrame.clone();var cachedProjectionTransform=renderer.projection.transform;// We also store the filter stack - I will definitely look to change how this works a little later down the line.\n// const stack = renderer.filterManager.filterStack;\n// this renderTexture will be used to store the cached DisplayObject\nvar renderTexture=RenderTexture.create({width:bounds.width,height:bounds.height,resolution:this.cacheAsBitmapResolution||renderer.resolution,multisample:(_a=this.cacheAsBitmapMultisample)!==null&&_a!==void 0?_a:renderer.multisample});var textureCacheId=\"cacheAsBitmap_\"+uid();this._cacheData.textureCacheId=textureCacheId;BaseTexture.addToCache(renderTexture.baseTexture,textureCacheId);Texture.addToCache(renderTexture,textureCacheId);// need to set //\nvar m=this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x,-bounds.y);// set all properties to there original so we can render to a texture\nthis.render=this._cacheData.originalRender;renderer.render(this,{renderTexture:renderTexture,clear:true,transform:m,skipUpdateTransform:false});renderer.framebuffer.blit();// now restore the state be setting the new properties\nrenderer.projection.transform=cachedProjectionTransform;renderer.renderTexture.bind(cachedRenderTexture,cachedSourceFrame,cachedDestinationFrame);// renderer.filterManager.filterStack = stack;\nthis.render=this._renderCached;// the rest is the same as for Canvas\nthis.updateTransform=this.displayObjectUpdateTransform;this.calculateBounds=this._calculateCachedBounds;this.getLocalBounds=this._getCachedLocalBounds;this._mask=null;this.filterArea=null;this.alpha=cacheAlpha;// create our cached sprite\nvar cachedSprite=new Sprite(renderTexture);cachedSprite.transform.worldTransform=this.transform.worldTransform;cachedSprite.anchor.x=-(bounds.x/bounds.width);cachedSprite.anchor.y=-(bounds.y/bounds.height);cachedSprite.alpha=cacheAlpha;cachedSprite._bounds=this._bounds;this._cacheData.sprite=cachedSprite;this.transform._parentID=-1;// restore the transform of the cached sprite to avoid the nasty flicker..\nif(!this.parent){this.enableTempParent();this.updateTransform();this.disableTempParent(null);}else{this.updateTransform();}// map the hit test..\nthis.containsPoint=cachedSprite.containsPoint.bind(cachedSprite);};/**\n * Renders a cached version of the sprite with canvas\n *\n * @private\n * @method _renderCachedCanvas\n * @memberof PIXI.DisplayObject#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer\n */DisplayObject.prototype._renderCachedCanvas=function _renderCachedCanvas(renderer){if(!this.visible||this.worldAlpha<=0||!this.renderable){return;}this._initCachedDisplayObjectCanvas(renderer);this._cacheData.sprite.worldAlpha=this.worldAlpha;this._cacheData.sprite._renderCanvas(renderer);};// TODO this can be the same as the WebGL version.. will need to do a little tweaking first though..\n/**\n * Prepares the Canvas renderer to cache the sprite\n *\n * @private\n * @method _initCachedDisplayObjectCanvas\n * @memberof PIXI.DisplayObject#\n * @param {PIXI.CanvasRenderer} renderer - The canvas renderer\n */DisplayObject.prototype._initCachedDisplayObjectCanvas=function _initCachedDisplayObjectCanvas(renderer){if(this._cacheData&&this._cacheData.sprite){return;}// get bounds actually transforms the object for us already!\nvar bounds=this.getLocalBounds(null,true);var cacheAlpha=this.alpha;this.alpha=1;var cachedRenderTarget=renderer.context;var cachedProjectionTransform=renderer._projTransform;bounds.ceil(settings.RESOLUTION);var renderTexture=RenderTexture.create({width:bounds.width,height:bounds.height});var textureCacheId=\"cacheAsBitmap_\"+uid();this._cacheData.textureCacheId=textureCacheId;BaseTexture.addToCache(renderTexture.baseTexture,textureCacheId);Texture.addToCache(renderTexture,textureCacheId);// need to set //\nvar m=_tempMatrix;this.transform.localTransform.copyTo(m);m.invert();m.tx-=bounds.x;m.ty-=bounds.y;// m.append(this.transform.worldTransform.)\n// set all properties to there original so we can render to a texture\nthis.renderCanvas=this._cacheData.originalRenderCanvas;renderer.render(this,{renderTexture:renderTexture,clear:true,transform:m,skipUpdateTransform:false});// now restore the state be setting the new properties\nrenderer.context=cachedRenderTarget;renderer._projTransform=cachedProjectionTransform;this.renderCanvas=this._renderCachedCanvas;// the rest is the same as for WebGL\nthis.updateTransform=this.displayObjectUpdateTransform;this.calculateBounds=this._calculateCachedBounds;this.getLocalBounds=this._getCachedLocalBounds;this._mask=null;this.filterArea=null;this.alpha=cacheAlpha;// create our cached sprite\nvar cachedSprite=new Sprite(renderTexture);cachedSprite.transform.worldTransform=this.transform.worldTransform;cachedSprite.anchor.x=-(bounds.x/bounds.width);cachedSprite.anchor.y=-(bounds.y/bounds.height);cachedSprite.alpha=cacheAlpha;cachedSprite._bounds=this._bounds;this._cacheData.sprite=cachedSprite;this.transform._parentID=-1;// restore the transform of the cached sprite to avoid the nasty flicker..\nif(!this.parent){this.parent=renderer._tempDisplayObjectParent;this.updateTransform();this.parent=null;}else{this.updateTransform();}// map the hit test..\nthis.containsPoint=cachedSprite.containsPoint.bind(cachedSprite);};/**\n * Calculates the bounds of the cached sprite\n *\n * @private\n * @method\n */DisplayObject.prototype._calculateCachedBounds=function _calculateCachedBounds(){this._bounds.clear();this._cacheData.sprite.transform._worldID=this.transform._worldID;this._cacheData.sprite._calculateBounds();this._bounds.updateID=this._boundsID;};/**\n * Gets the bounds of the cached sprite.\n *\n * @private\n * @method\n * @return {Rectangle} The local bounds.\n */DisplayObject.prototype._getCachedLocalBounds=function _getCachedLocalBounds(){return this._cacheData.sprite.getLocalBounds(null);};/**\n * Destroys the cached sprite.\n *\n * @private\n * @method\n */DisplayObject.prototype._destroyCachedDisplayObject=function _destroyCachedDisplayObject(){this._cacheData.sprite._texture.destroy(true);this._cacheData.sprite=null;BaseTexture.removeFromCache(this._cacheData.textureCacheId);Texture.removeFromCache(this._cacheData.textureCacheId);this._cacheData.textureCacheId=null;};/**\n * Destroys the cached object.\n *\n * @private\n * @method\n * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n *  have been set to that value.\n *  Used when destroying containers, see the Container.destroy method.\n */DisplayObject.prototype._cacheAsBitmapDestroy=function _cacheAsBitmapDestroy(options){this.cacheAsBitmap=false;this.destroy(options);};export{CacheData};","map":null,"metadata":{},"sourceType":"module"}