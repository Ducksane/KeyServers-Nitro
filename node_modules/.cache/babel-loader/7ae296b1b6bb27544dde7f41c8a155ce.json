{"ast":null,"code":"/*!\n * @pixi/sprite-tiling - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{Texture,TextureMatrix,Shader,QuadUv,State,ObjectRenderer}from'@pixi/core';import{Point,Rectangle,Transform,Matrix}from'@pixi/math';import{Sprite}from'@pixi/sprite';import{WRAP_MODES}from'@pixi/constants';import{premultiplyTintToRgba,correctBlendMode}from'@pixi/utils';/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */ /* global Reflect, Promise */var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p)){d[p]=b[p];}}};return _extendStatics(d,b);};function __extends(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());}var tempPoint=new Point();/**\n * A tiling sprite is a fast way of rendering a tiling image.\n *\n * @memberof PIXI\n */var TilingSprite=/** @class */function(_super){__extends(TilingSprite,_super);/**\n     * @param texture - The texture of the tiling sprite.\n     * @param width - The width of the tiling sprite.\n     * @param height - The height of the tiling sprite.\n     */function TilingSprite(texture,width,height){if(width===void 0){width=100;}if(height===void 0){height=100;}var _this=_super.call(this,texture)||this;_this.tileTransform=new Transform();// The width of the tiling sprite\n_this._width=width;// The height of the tiling sprite\n_this._height=height;_this.uvMatrix=_this.texture.uvMatrix||new TextureMatrix(texture);/**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_render' method.\n         *\n         * @default 'tilingSprite'\n         */_this.pluginName='tilingSprite';_this.uvRespectAnchor=false;return _this;}Object.defineProperty(TilingSprite.prototype,\"clampMargin\",{/**\n         * Changes frame clamping in corresponding textureTransform, shortcut\n         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n         *\n         * @default 0.5\n         * @member {number}\n         */get:function get(){return this.uvMatrix.clampMargin;},set:function set(value){this.uvMatrix.clampMargin=value;this.uvMatrix.update(true);},enumerable:false,configurable:true});Object.defineProperty(TilingSprite.prototype,\"tileScale\",{/** The scaling of the image that is being tiled. */get:function get(){return this.tileTransform.scale;},set:function set(value){this.tileTransform.scale.copyFrom(value);},enumerable:false,configurable:true});Object.defineProperty(TilingSprite.prototype,\"tilePosition\",{/** The offset of the image that is being tiled. */get:function get(){return this.tileTransform.position;},set:function set(value){this.tileTransform.position.copyFrom(value);},enumerable:false,configurable:true});/**\n     * @protected\n     */TilingSprite.prototype._onTextureUpdate=function(){if(this.uvMatrix){this.uvMatrix.texture=this._texture;}this._cachedTint=0xFFFFFF;};/**\n     * Renders the object using the WebGL renderer\n     *\n     * @param renderer - The renderer\n     */TilingSprite.prototype._render=function(renderer){// tweak our texture temporarily..\nvar texture=this._texture;if(!texture||!texture.valid){return;}this.tileTransform.updateLocalTransform();this.uvMatrix.update();renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);renderer.plugins[this.pluginName].render(this);};/** Updates the bounds of the tiling sprite. */TilingSprite.prototype._calculateBounds=function(){var minX=this._width*-this._anchor._x;var minY=this._height*-this._anchor._y;var maxX=this._width*(1-this._anchor._x);var maxY=this._height*(1-this._anchor._y);this._bounds.addFrame(this.transform,minX,minY,maxX,maxY);};/**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param rect - Optional output rectangle.\n     * @return The bounds.\n     */TilingSprite.prototype.getLocalBounds=function(rect){// we can do a fast local bounds if the sprite has no children!\nif(this.children.length===0){this._bounds.minX=this._width*-this._anchor._x;this._bounds.minY=this._height*-this._anchor._y;this._bounds.maxX=this._width*(1-this._anchor._x);this._bounds.maxY=this._height*(1-this._anchor._y);if(!rect){if(!this._localBoundsRect){this._localBoundsRect=new Rectangle();}rect=this._localBoundsRect;}return this._bounds.getRectangle(rect);}return _super.prototype.getLocalBounds.call(this,rect);};/**\n     * Checks if a point is inside this tiling sprite.\n     *\n     * @param point - The point to check.\n     * @return Whether or not the sprite contains the point.\n     */TilingSprite.prototype.containsPoint=function(point){this.worldTransform.applyInverse(point,tempPoint);var width=this._width;var height=this._height;var x1=-width*this.anchor._x;if(tempPoint.x>=x1&&tempPoint.x<x1+width){var y1=-height*this.anchor._y;if(tempPoint.y>=y1&&tempPoint.y<y1+height){return true;}}return false;};/**\n     * Destroys this sprite and optionally its texture and children\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */TilingSprite.prototype.destroy=function(options){_super.prototype.destroy.call(this,options);this.tileTransform=null;this.uvMatrix=null;};/**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {Object} options - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @param {number} options.width - required width of the tiling sprite\n     * @param {number} options.height - required height of the tiling sprite\n     * @return {PIXI.TilingSprite} The newly created texture\n     */TilingSprite.from=function(source,options){var texture=source instanceof Texture?source:Texture.from(source,options);return new TilingSprite(texture,options.width,options.height);};Object.defineProperty(TilingSprite.prototype,\"width\",{/** The width of the sprite, setting this will actually modify the scale to achieve the value set. */get:function get(){return this._width;},set:function set(value){this._width=value;},enumerable:false,configurable:true});Object.defineProperty(TilingSprite.prototype,\"height\",{/** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */get:function get(){return this._height;},set:function set(value){this._height=value;},enumerable:false,configurable:true});return TilingSprite;}(Sprite);var fragmentSimpleSrc=\"#version 100\\n#define SHADER_NAME Tiling-Sprite-Simple-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = texSample * uColor;\\n}\\n\";var gl1VertexSrc=\"#version 100\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";var gl1FragmentSrc=\"#version 100\\n#ifdef GL_EXT_shader_texture_lod\\n    #extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    #ifdef GL_EXT_shader_texture_lod\\n        vec4 texSample = unclamped == coord\\n            ? texture2D(uSampler, coord) \\n            : texture2DLodEXT(uSampler, coord, 0);\\n    #else\\n        vec4 texSample = texture2D(uSampler, coord);\\n    #endif\\n\\n    gl_FragColor = texSample * uColor;\\n}\\n\";var gl2VertexSrc=\"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-300\\n\\nprecision lowp float;\\n\\nin vec2 aVertexPosition;\\nin vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nout vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";var gl2FragmentSrc=\"#version 300 es\\n#define SHADER_NAME Tiling-Sprite-100\\n\\nprecision lowp float;\\n\\nin vec2 vTextureCoord;\\n\\nout vec4 fragmentColor;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    vec2 unclamped = coord;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\\n\\n    fragmentColor = texSample * uColor;\\n}\\n\";var tempMat=new Matrix();/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */var TilingSpriteRenderer=/** @class */function(_super){__extends(TilingSpriteRenderer,_super);/**\n     * constructor for renderer\n     *\n     * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n     */function TilingSpriteRenderer(renderer){var _this=_super.call(this,renderer)||this;// WebGL version is not available during initialization!\nrenderer.runners.contextChange.add(_this);_this.quad=new QuadUv();/**\n         * The WebGL state in which this renderer will work.\n         *\n         * @member {PIXI.State}\n         * @readonly\n         */_this.state=State.for2d();return _this;}/**\n     * Creates shaders when context is initialized.\n     */TilingSpriteRenderer.prototype.contextChange=function(){var renderer=this.renderer;var uniforms={globals:renderer.globalUniforms};this.simpleShader=Shader.from(gl1VertexSrc,fragmentSimpleSrc,uniforms);this.shader=renderer.context.webGLVersion>1?Shader.from(gl2VertexSrc,gl2FragmentSrc,uniforms):Shader.from(gl1VertexSrc,gl1FragmentSrc,uniforms);};/**\n     * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n     */TilingSpriteRenderer.prototype.render=function(ts){var renderer=this.renderer;var quad=this.quad;var vertices=quad.vertices;vertices[0]=vertices[6]=ts._width*-ts.anchor.x;vertices[1]=vertices[3]=ts._height*-ts.anchor.y;vertices[2]=vertices[4]=ts._width*(1.0-ts.anchor.x);vertices[5]=vertices[7]=ts._height*(1.0-ts.anchor.y);var anchorX=ts.uvRespectAnchor?ts.anchor.x:0;var anchorY=ts.uvRespectAnchor?ts.anchor.y:0;vertices=quad.uvs;vertices[0]=vertices[6]=-anchorX;vertices[1]=vertices[3]=-anchorY;vertices[2]=vertices[4]=1.0-anchorX;vertices[5]=vertices[7]=1.0-anchorY;quad.invalidate();var tex=ts._texture;var baseTex=tex.baseTexture;var lt=ts.tileTransform.localTransform;var uv=ts.uvMatrix;var isSimple=baseTex.isPowerOfTwo&&tex.frame.width===baseTex.width&&tex.frame.height===baseTex.height;// auto, force repeat wrapMode for big tiling textures\nif(isSimple){if(!baseTex._glTextures[renderer.CONTEXT_UID]){if(baseTex.wrapMode===WRAP_MODES.CLAMP){baseTex.wrapMode=WRAP_MODES.REPEAT;}}else{isSimple=baseTex.wrapMode!==WRAP_MODES.CLAMP;}}var shader=isSimple?this.simpleShader:this.shader;var w=tex.width;var h=tex.height;var W=ts._width;var H=ts._height;tempMat.set(lt.a*w/W,lt.b*w/H,lt.c*h/W,lt.d*h/H,lt.tx/W,lt.ty/H);// that part is the same as above:\n// tempMat.identity();\n// tempMat.scale(tex.width, tex.height);\n// tempMat.prepend(lt);\n// tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\ntempMat.invert();if(isSimple){tempMat.prepend(uv.mapCoord);}else{shader.uniforms.uMapCoord=uv.mapCoord.toArray(true);shader.uniforms.uClampFrame=uv.uClampFrame;shader.uniforms.uClampOffset=uv.uClampOffset;}shader.uniforms.uTransform=tempMat.toArray(true);shader.uniforms.uColor=premultiplyTintToRgba(ts.tint,ts.worldAlpha,shader.uniforms.uColor,baseTex.alphaMode);shader.uniforms.translationMatrix=ts.transform.worldTransform.toArray(true);shader.uniforms.uSampler=tex;renderer.shader.bind(shader);renderer.geometry.bind(quad);this.state.blendMode=correctBlendMode(ts.blendMode,baseTex.alphaMode);renderer.state.set(this.state);renderer.geometry.draw(this.renderer.gl.TRIANGLES,6,0);};return TilingSpriteRenderer;}(ObjectRenderer);export{TilingSprite,TilingSpriteRenderer};","map":null,"metadata":{},"sourceType":"module"}