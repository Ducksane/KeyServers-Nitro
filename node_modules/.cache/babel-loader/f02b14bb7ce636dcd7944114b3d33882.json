{"ast":null,"code":"import _assertThisInitialized from\"C:/Users/Administrator/Desktop/nitro/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";import _get from\"C:/Users/Administrator/Desktop/nitro/node_modules/@babel/runtime/helpers/esm/get.js\";import _getPrototypeOf from\"C:/Users/Administrator/Desktop/nitro/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";import _inherits from\"C:/Users/Administrator/Desktop/nitro/node_modules/@babel/runtime/helpers/esm/inherits.js\";import _createSuper from\"C:/Users/Administrator/Desktop/nitro/node_modules/@babel/runtime/helpers/esm/createSuper.js\";import _classCallCheck from\"C:/Users/Administrator/Desktop/nitro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"C:/Users/Administrator/Desktop/nitro/node_modules/@babel/runtime/helpers/esm/createClass.js\";/* eslint-disable */ /*!\n * @pixi/tilemap - v3.2.2\n * Compiled Fri, 22 Oct 2021 12:27:49 UTC\n *\n * @pixi/tilemap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n * \n * Copyright 2019-2020, Ivan Popelyshev, All Rights Reserved\n */import{Container,Bounds}from'@pixi/display';import{Texture,Resource,Shader,Program,Geometry,Buffer,ObjectRenderer,BaseTexture,Renderer}from'@pixi/core';import{SCALE_MODES,DRAW_MODES,ALPHA_MODES,WRAP_MODES}from'@pixi/constants';import{groupD8,Matrix}from'@pixi/math';import{createIndicesForQuads}from'@pixi/utils';/**\r\n * The renderer plugin for canvas. It isn't registered by default.\r\n *\r\n * ```\r\n * import { CanvasTileRenderer } from '@pixi/tilemap';\r\n * import { CanvasRenderer } from '@pixi/canvas-core';\r\n *\r\n * // You must register this yourself (optional). @pixi/tilemap doesn't do it to\r\n * // prevent a hard dependency on @pixi/canvas-core.\r\n * CanvasRenderer.registerPlugin('tilemap', CanvasTileRenderer);\r\n * ```\r\n */ // TODO: Move to @pixi/tilemap-canvas\nvar CanvasTileRenderer=/*#__PURE__*/function(){/** @param renderer */function CanvasTileRenderer(renderer){_classCallCheck(this,CanvasTileRenderer);CanvasTileRenderer.prototype.__init.call(this);CanvasTileRenderer.prototype.__init2.call(this);this.renderer=renderer;this.tileAnim=[0,0];}// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n_createClass(CanvasTileRenderer,[{key:\"__init\",value:/** The renderer */ /** The global tile animation state */function __init(){this.tileAnim=[0,0];}/** @deprecated */},{key:\"__init2\",value:function __init2(){this.dontUseTransform=false;}}],[{key:\"getInstance\",value:function getInstance(renderer){if(!renderer.plugins.tilemap){renderer.plugins.tilemap=new CanvasTileRenderer(renderer);}return renderer.plugins.tilemap;}}]);return CanvasTileRenderer;}();/**\r\n * These are additional @pixi/tilemap options.\r\n *\r\n * This settings should not be changed after the renderer has initialized; otherwise, the behavior\r\n * is undefined.\r\n */var settings={/** The default number of textures per tilemap in a tilemap composite. */TEXTURES_PER_TILEMAP:16,/**\r\n     * The width/height of each texture tile in a {@link TEXTILE_DIMEN}. This is 1024px by default.\r\n     *\r\n     * This should fit all tile base-textures; otherwise, {@link TextileResource} may fail to correctly\r\n     * upload the textures togther in a tiled fashion.\r\n     */TEXTILE_DIMEN:1024,/**\r\n     * The number of texture tiles per {@link TextileResource}.\r\n     *\r\n     * Texture tiling is disabled by default, and so this is set to `1` by default. If it is set to a\r\n     * higher value, textures will be uploaded together in a tiled fashion.\r\n     *\r\n     * Since {@link TextileResource} is a dual-column format, this should be even for packing\r\n     * efficiency. The optimal value is usually 4.\r\n     */TEXTILE_UNITS:1,/** The scaling mode of the combined texture tiling. */TEXTILE_SCALE_MODE:SCALE_MODES.LINEAR,/** This will enable 32-bit index buffers. It's useful when you have more than 16K tiles. */use32bitIndex:false,/** Flags whether textiles should be cleared when each tile is uploaded. */DO_CLEAR:true,// Backward compatibility\nget maxTextures(){return this.MAX_TEXTURES;},set maxTextures(value){this.MAX_TEXTURES=value;},get boundSize(){return this.TEXTURE_TILE_DIMEN;},set boundSize(value){this.TILE_TEXTURE_DIMEN=value;},get boundCountPerBuffer(){return this.TEXTILE_UNITS;},set boundCountPerBuffer(value){this.TEXTILE_UNITS=value;}};// @deprecated\nvar Constant=settings;function _nullishCoalesce(lhs,rhsFn){if(lhs!=null){return lhs;}else{return rhsFn();}}var POINT_STRUCT;(function(POINT_STRUCT){var U=0;POINT_STRUCT[POINT_STRUCT[\"U\"]=U]=\"U\";var V=U+1;POINT_STRUCT[POINT_STRUCT[\"V\"]=V]=\"V\";var X=V+1;POINT_STRUCT[POINT_STRUCT[\"X\"]=X]=\"X\";var Y=X+1;POINT_STRUCT[POINT_STRUCT[\"Y\"]=Y]=\"Y\";var TILE_WIDTH=Y+1;POINT_STRUCT[POINT_STRUCT[\"TILE_WIDTH\"]=TILE_WIDTH]=\"TILE_WIDTH\";var TILE_HEIGHT=TILE_WIDTH+1;POINT_STRUCT[POINT_STRUCT[\"TILE_HEIGHT\"]=TILE_HEIGHT]=\"TILE_HEIGHT\";var ROTATE=TILE_HEIGHT+1;POINT_STRUCT[POINT_STRUCT[\"ROTATE\"]=ROTATE]=\"ROTATE\";var ANIM_X=ROTATE+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_X\"]=ANIM_X]=\"ANIM_X\";var ANIM_Y=ANIM_X+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_Y\"]=ANIM_Y]=\"ANIM_Y\";var TEXTURE_INDEX=ANIM_Y+1;POINT_STRUCT[POINT_STRUCT[\"TEXTURE_INDEX\"]=TEXTURE_INDEX]=\"TEXTURE_INDEX\";var ANIM_COUNT_X=TEXTURE_INDEX+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_COUNT_X\"]=ANIM_COUNT_X]=\"ANIM_COUNT_X\";var ANIM_COUNT_Y=ANIM_COUNT_X+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_COUNT_Y\"]=ANIM_COUNT_Y]=\"ANIM_COUNT_Y\";var ANIM_DIVISOR=ANIM_COUNT_Y+1;POINT_STRUCT[POINT_STRUCT[\"ANIM_DIVISOR\"]=ANIM_DIVISOR]=\"ANIM_DIVISOR\";var ALPHA=ANIM_DIVISOR+1;POINT_STRUCT[POINT_STRUCT[\"ALPHA\"]=ALPHA]=\"ALPHA\";})(POINT_STRUCT||(POINT_STRUCT={}));var POINT_STRUCT_SIZE=Object.keys(POINT_STRUCT).length/2;/**\r\n * A rectangular tilemap implementation that renders a predefined set of tile textures.\r\n *\r\n * The {@link Tilemap.tileset tileset} of a tilemap defines the list of base-textures that can be painted in the\r\n * tilemap. A texture is identified using its base-texture's index into the this list, i.e. changing the base-texture\r\n * at a given index in the tileset modifies the paint of all tiles pointing to that index.\r\n *\r\n * The size of the tileset is limited by the texture units supported by the client device. The minimum supported\r\n * value is 8, as defined by the WebGL 1 specification. `gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS`) can be used\r\n * to extract this limit. {@link CompositeTilemap} can be used to get around this limit by layering multiple tilemap\r\n * instances.\r\n *\r\n * @example\r\n * import { Tilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Add the spritesheet into your loader!\r\n * Loader.shared.add('atlas', 'assets/atlas.json');\r\n *\r\n * // Make the tilemap once the tileset assets are available.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      // The base-texture is shared between all the tile textures.\r\n *      const tilemap = new Tilemap([Texture.from('grass.png').baseTexture])\r\n *          .tile('grass.png', 0, 0)\r\n *          .tile('grass.png', 100, 100)\r\n *          .tile('brick_wall.png', 0, 100);\r\n * });\r\n */var Tilemap=/*#__PURE__*/function(_Container){_inherits(Tilemap,_Container);var _super=_createSuper(Tilemap);/**\r\n     * @param tileset - The tileset to use for the tilemap. This can be reset later with {@link Tilemap.setTileset}. The\r\n     *      base-textures in this array must not be duplicated.\r\n     */function Tilemap(tileset){var _this;_classCallCheck(this,Tilemap);_this=_super.call(this);Tilemap.prototype.__init.call(_assertThisInitialized(_this));Tilemap.prototype.__init2.call(_assertThisInitialized(_this));Tilemap.prototype.__init3.call(_assertThisInitialized(_this));Tilemap.prototype.__init4.call(_assertThisInitialized(_this));Tilemap.prototype.__init5.call(_assertThisInitialized(_this));Tilemap.prototype.__init6.call(_assertThisInitialized(_this));Tilemap.prototype.__init7.call(_assertThisInitialized(_this));Tilemap.prototype.__init8.call(_assertThisInitialized(_this));Tilemap.prototype.__init9.call(_assertThisInitialized(_this));Tilemap.prototype.__init10.call(_assertThisInitialized(_this));Tilemap.prototype.__init11.call(_assertThisInitialized(_this));Tilemap.prototype.__init12.call(_assertThisInitialized(_this));Tilemap.prototype.__init13.call(_assertThisInitialized(_this));Tilemap.prototype.__init14.call(_assertThisInitialized(_this));Tilemap.prototype.__init15.call(_assertThisInitialized(_this));Tilemap.prototype.__init16.call(_assertThisInitialized(_this));_this.setTileset(tileset);return _this;}/**\r\n     * @returns The tileset of this tilemap.\r\n     */_createClass(Tilemap,[{key:\"__init\",value:function __init(){this.shadowColor=new Float32Array([0.0,0.0,0.0,0.5]);}},{key:\"__init2\",value:function __init2(){this._globalMat=null;}/**\r\n     * The tile animation frame.\r\n     *\r\n     * @see CompositeTilemap.tileAnim\r\n     */},{key:\"__init3\",value:function __init3(){this.tileAnim=null;}/**\r\n     * This is the last uploaded size of the tilemap geometry.\r\n     * @ignore\r\n     */},{key:\"__init4\",value:function __init4(){this.modificationMarker=0;}/** @ignore */},{key:\"__init5\",value:function __init5(){this.offsetX=0;}/** @ignore */},{key:\"__init6\",value:function __init6(){this.offsetY=0;}/** @ignore */},{key:\"__init7\",value:function __init7(){this.compositeParent=false;}/**\r\n     * The list of base-textures being used in the tilemap.\r\n     *\r\n     * This should not be shuffled after tiles have been added into this tilemap. Usually, only tile textures\r\n     * should be added after tiles have been added into the map.\r\n     */ /**\r\n     * The local bounds of the tilemap itself. This does not include DisplayObject children.\r\n     */},{key:\"__init8\",value:function __init8(){this.tilemapBounds=new Bounds();}/** Flags whether any animated tile was added. */},{key:\"__init9\",value:function __init9(){this.hasAnimatedTile=false;}/** The interleaved geometry of the tilemap. */},{key:\"__init10\",value:function __init10(){this.pointsBuf=[];}},{key:\"getTileset\",value:function getTileset(){return this.tileset;}/**\r\n     * Define the tileset used by the tilemap.\r\n     *\r\n     * @param tileset - The list of textures to use in the tilemap. If a base-texture (not array) is passed, it will\r\n     *  be wrapped into an array. This should not contain any duplicates.\r\n     */},{key:\"setTileset\",value:function setTileset(){var tileset=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];if(!Array.isArray(tileset)){tileset=[tileset];}for(var i=0;i<tileset.length;i++){if(tileset[i].baseTexture){tileset[i]=tileset[i].baseTexture;}}this.tileset=tileset;return this;}/**  Clears all the tiles added into this tilemap. */},{key:\"clear\",value:function clear(){this.pointsBuf.length=0;this.modificationMarker=0;this.tilemapBounds.clear();this.hasAnimatedTile=false;return this;}/**\r\n     * Adds a tile that paints the given texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tiling texture to render.\r\n     * @param x - The local x-coordinate of the tile's position.\r\n     * @param y - The local y-coordinate of the tile's position.\r\n     * @param options - Additional tile options.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration of each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */},{key:\"tile\",value:function tile(tileTexture,x,y){var options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};var baseTexture;var textureIndex=-1;if(typeof tileTexture==='number'){textureIndex=tileTexture;baseTexture=this.tileset[textureIndex];}else{var texture;if(typeof tileTexture==='string'){texture=Texture.from(tileTexture);}else{texture=tileTexture;}var textureList=this.tileset;for(var i=0;i<textureList.length;i++){if(textureList[i]===texture.castToBaseTexture()){textureIndex=i;break;}}if('baseTexture'in texture){options.u=_nullishCoalesce(options.u,function(){return texture.frame.x;});options.v=_nullishCoalesce(options.v,function(){return texture.frame.y;});options.tileWidth=_nullishCoalesce(options.tileWidth,function(){return texture.orig.width;});options.tileHeight=_nullishCoalesce(options.tileHeight,function(){return texture.orig.height;});}baseTexture=texture.castToBaseTexture();}if(!baseTexture||textureIndex<0){console.error('The tile texture was not found in the tilemap tileset.');return this;}var _options$u=options.u,u=_options$u===void 0?0:_options$u,_options$v=options.v,v=_options$v===void 0?0:_options$v,_options$tileWidth=options.tileWidth,tileWidth=_options$tileWidth===void 0?baseTexture.realWidth:_options$tileWidth,_options$tileHeight=options.tileHeight,tileHeight=_options$tileHeight===void 0?baseTexture.realHeight:_options$tileHeight,_options$animX=options.animX,animX=_options$animX===void 0?0:_options$animX,_options$animY=options.animY,animY=_options$animY===void 0?0:_options$animY,_options$rotate=options.rotate,rotate=_options$rotate===void 0?0:_options$rotate,_options$animCountX=options.animCountX,animCountX=_options$animCountX===void 0?1024:_options$animCountX,_options$animCountY=options.animCountY,animCountY=_options$animCountY===void 0?1024:_options$animCountY,_options$animDivisor=options.animDivisor,animDivisor=_options$animDivisor===void 0?1:_options$animDivisor,_options$alpha=options.alpha,alpha=_options$alpha===void 0?1:_options$alpha;var pb=this.pointsBuf;this.hasAnimatedTile=this.hasAnimatedTile||animX>0||animY>0;pb.push(u);pb.push(v);pb.push(x);pb.push(y);pb.push(tileWidth);pb.push(tileHeight);pb.push(rotate);pb.push(animX|0);pb.push(animY|0);pb.push(textureIndex);pb.push(animCountX);pb.push(animCountY);pb.push(animDivisor);pb.push(alpha);this.tilemapBounds.addFramePad(x,y,x+tileWidth,y+tileHeight,0,0);return this;}/** Changes the rotation of the last tile. */},{key:\"tileRotate\",value:function tileRotate(rotate){var pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.TEXTURE_INDEX)]=rotate;}/** Changes the `animX`, `animCountX` of the last tile. */},{key:\"tileAnimX\",value:function tileAnimX(offset,count){var pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_X)]=offset;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_COUNT_X)]=count;// pb[pb.length - (POINT_STRUCT_SIZE - POINT_STRUCT.ANIM_DIVISOR)] = duration;\n}/** Changes the `animY`, `animCountY` of the last tile. */},{key:\"tileAnimY\",value:function tileAnimY(offset,count){var pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_Y)]=offset;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_COUNT_Y)]=count;}/** Changes the `animDivisor` value of the last tile. */},{key:\"tileAnimDivisor\",value:function tileAnimDivisor(divisor){var pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ANIM_DIVISOR)]=divisor;}},{key:\"tileAlpha\",value:function tileAlpha(alpha){var pb=this.pointsBuf;pb[pb.length-(POINT_STRUCT_SIZE-POINT_STRUCT.ALPHA)]=alpha;}},{key:\"__init11\",value:function __init11(){var _this2=this;this.renderCanvas=function(renderer){var plugin=CanvasTileRenderer.getInstance(renderer);if(plugin&&!plugin.dontUseTransform){var wt=_this2.worldTransform;renderer.context.setTransform(wt.a,wt.b,wt.c,wt.d,wt.tx*renderer.resolution,wt.ty*renderer.resolution);}_this2.renderCanvasCore(renderer);};}},{key:\"renderCanvasCore\",value:function renderCanvasCore(renderer){if(this.tileset.length===0)return;var points=this.pointsBuf;var tileAnim=this.tileAnim||renderer.plugins.tilemap&&renderer.plugins.tilemap.tileAnim;renderer.context.fillStyle='#000000';for(var i=0,n=points.length;i<n;i+=POINT_STRUCT_SIZE){var x1=points[i+POINT_STRUCT.U];var y1=points[i+POINT_STRUCT.V];var x2=points[i+POINT_STRUCT.X];var y2=points[i+POINT_STRUCT.Y];var w=points[i+POINT_STRUCT.TILE_WIDTH];var h=points[i+POINT_STRUCT.TILE_HEIGHT];x1+=points[i+POINT_STRUCT.ANIM_X]*tileAnim[0];y1+=points[i+POINT_STRUCT.ANIM_Y]*tileAnim[1];var textureIndex=points[i+POINT_STRUCT.TEXTURE_INDEX];var alpha=points[i+POINT_STRUCT.ALPHA];// canvas does not work with rotate yet\nif(textureIndex>=0&&this.tileset[textureIndex]){renderer.context.globalAlpha=alpha;renderer.context.drawImage(this.tileset[textureIndex].getDrawableSource(),x1,y1,w,h,x2,y2,w,h);}else{renderer.context.globalAlpha=0.5;renderer.context.fillRect(x2,y2,w,h);}renderer.context.globalAlpha=1;}}},{key:\"__init12\",value:function __init12(){this.vbId=0;}},{key:\"__init13\",value:function __init13(){this.vb=null;}},{key:\"__init14\",value:function __init14(){this.vbBuffer=null;}},{key:\"__init15\",value:function __init15(){this.vbArray=null;}},{key:\"__init16\",value:function __init16(){this.vbInts=null;}},{key:\"destroyVb\",value:function destroyVb(){if(this.vb){this.vb.destroy();this.vb=null;}}},{key:\"render\",value:function render(renderer){var plugin=renderer.plugins.tilemap;var shader=plugin.getShader();renderer.batch.setObjectRenderer(plugin);this._globalMat=shader.uniforms.projTransMatrix;renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);shader.uniforms.shadowColor=this.shadowColor;shader.uniforms.animationFrame=this.tileAnim||plugin.tileAnim;this.renderWebGLCore(renderer,plugin);}},{key:\"renderWebGLCore\",value:function renderWebGLCore(renderer,plugin){var points=this.pointsBuf;if(points.length===0)return;var rectsCount=points.length/POINT_STRUCT_SIZE;var shader=plugin.getShader();var textures=this.tileset;if(textures.length===0)return;plugin.bindTileTextures(renderer,textures);renderer.shader.bind(shader,false);// lost context! recover!\nvar vb=this.vb;if(!vb){vb=plugin.createVb();this.vb=vb;this.vbId=vb.id;this.vbBuffer=null;this.modificationMarker=0;}plugin.checkIndexBuffer(rectsCount,vb);var boundCountPerBuffer=settings.TEXTILE_UNITS;var vertexBuf=vb.getBuffer('aVertexPosition');// if layer was changed, re-upload vertices\nvar vertices=rectsCount*vb.vertPerQuad;if(vertices===0)return;if(this.modificationMarker!==vertices){this.modificationMarker=vertices;var vs=vb.stride*vertices;if(!this.vbBuffer||this.vbBuffer.byteLength<vs){// !@#$ happens, need resize\nvar bk=vb.stride;while(bk<vs){bk*=2;}this.vbBuffer=new ArrayBuffer(bk);this.vbArray=new Float32Array(this.vbBuffer);this.vbInts=new Uint32Array(this.vbBuffer);vertexBuf.update(this.vbBuffer);}var arr=this.vbArray;// const ints = this.vbInts;\n// upload vertices!\nvar sz=0;// let tint = 0xffffffff;\nvar textureId=0;var shiftU=this.offsetX;var shiftV=this.offsetY;// let tint = 0xffffffff;\n// const tint = -1;\nfor(var i=0;i<points.length;i+=POINT_STRUCT_SIZE){var eps=0.5;if(this.compositeParent){var textureIndex=points[i+POINT_STRUCT.TEXTURE_INDEX];if(boundCountPerBuffer>1){// TODO: what if its more than 4?\ntextureId=textureIndex>>2;shiftU=this.offsetX*(textureIndex&1);shiftV=this.offsetY*(textureIndex>>1&1);}else{textureId=textureIndex;shiftU=0;shiftV=0;}}var x=points[i+POINT_STRUCT.X];var y=points[i+POINT_STRUCT.Y];var w=points[i+POINT_STRUCT.TILE_WIDTH];var h=points[i+POINT_STRUCT.TILE_HEIGHT];var u=points[i+POINT_STRUCT.U]+shiftU;var v=points[i+POINT_STRUCT.V]+shiftV;var rotate=points[i+POINT_STRUCT.ROTATE];var animX=points[i+POINT_STRUCT.ANIM_X];var animY=points[i+POINT_STRUCT.ANIM_Y];var animWidth=points[i+POINT_STRUCT.ANIM_COUNT_X]||1024;var animHeight=points[i+POINT_STRUCT.ANIM_COUNT_Y]||1024;var animXEncoded=animX+animWidth*2048;var animYEncoded=animY+animHeight*2048;var animDivisor=points[i+POINT_STRUCT.ANIM_DIVISOR];var alpha=points[i+POINT_STRUCT.ALPHA];var u0=void 0;var v0=void 0;var u1=void 0;var v1=void 0;var u2=void 0;var v2=void 0;var u3=void 0;var v3=void 0;if(rotate===0){u0=u;v0=v;u1=u+w;v1=v;u2=u+w;v2=v+h;u3=u;v3=v+h;}else{var w2=w/2;var h2=h/2;if(rotate%4!==0){w2=h/2;h2=w/2;}var cX=u+w2;var cY=v+h2;rotate=groupD8.add(rotate,groupD8.NW);u0=cX+w2*groupD8.uX(rotate);v0=cY+h2*groupD8.uY(rotate);rotate=groupD8.add(rotate,2);// rotate 90 degrees clockwise\nu1=cX+w2*groupD8.uX(rotate);v1=cY+h2*groupD8.uY(rotate);rotate=groupD8.add(rotate,2);u2=cX+w2*groupD8.uX(rotate);v2=cY+h2*groupD8.uY(rotate);rotate=groupD8.add(rotate,2);u3=cX+w2*groupD8.uX(rotate);v3=cY+h2*groupD8.uY(rotate);}arr[sz++]=x;arr[sz++]=y;arr[sz++]=u0;arr[sz++]=v0;arr[sz++]=u+eps;arr[sz++]=v+eps;arr[sz++]=u+w-eps;arr[sz++]=v+h-eps;arr[sz++]=animXEncoded;arr[sz++]=animYEncoded;arr[sz++]=textureId;arr[sz++]=animDivisor;arr[sz++]=alpha;arr[sz++]=x+w;arr[sz++]=y;arr[sz++]=u1;arr[sz++]=v1;arr[sz++]=u+eps;arr[sz++]=v+eps;arr[sz++]=u+w-eps;arr[sz++]=v+h-eps;arr[sz++]=animXEncoded;arr[sz++]=animYEncoded;arr[sz++]=textureId;arr[sz++]=animDivisor;arr[sz++]=alpha;arr[sz++]=x+w;arr[sz++]=y+h;arr[sz++]=u2;arr[sz++]=v2;arr[sz++]=u+eps;arr[sz++]=v+eps;arr[sz++]=u+w-eps;arr[sz++]=v+h-eps;arr[sz++]=animXEncoded;arr[sz++]=animYEncoded;arr[sz++]=textureId;arr[sz++]=animDivisor;arr[sz++]=alpha;arr[sz++]=x;arr[sz++]=y+h;arr[sz++]=u3;arr[sz++]=v3;arr[sz++]=u+eps;arr[sz++]=v+eps;arr[sz++]=u+w-eps;arr[sz++]=v+h-eps;arr[sz++]=animXEncoded;arr[sz++]=animYEncoded;arr[sz++]=textureId;arr[sz++]=animDivisor;arr[sz++]=alpha;}vertexBuf.update(arr);}renderer.geometry.bind(vb,shader);renderer.geometry.draw(DRAW_MODES.TRIANGLES,rectsCount*6,0);}/**\r\n     * @internal\r\n     * @ignore\r\n     */},{key:\"isModified\",value:function isModified(anim){if(this.modificationMarker!==this.pointsBuf.length||anim&&this.hasAnimatedTile){return true;}return false;}/**\r\n     * This will pull forward the modification marker.\r\n     *\r\n     * @internal\r\n     * @ignore\r\n     */},{key:\"clearModify\",value:function clearModify(){this.modificationMarker=this.pointsBuf.length;}/** @override */},{key:\"_calculateBounds\",value:function _calculateBounds(){var _this$tilemapBounds=this.tilemapBounds,minX=_this$tilemapBounds.minX,minY=_this$tilemapBounds.minY,maxX=_this$tilemapBounds.maxX,maxY=_this$tilemapBounds.maxY;this._bounds.addFrame(this.transform,minX,minY,maxX,maxY);}/** @override */},{key:\"getLocalBounds\",value:function getLocalBounds(rect){// we can do a fast local bounds if the sprite has no children!\nif(this.children.length===0){return this.tilemapBounds.getRectangle(rect);}return _get(_getPrototypeOf(Tilemap.prototype),\"getLocalBounds\",this).call(this,rect);}/** @override */},{key:\"destroy\",value:function destroy(options){_get(_getPrototypeOf(Tilemap.prototype),\"destroy\",this).call(this,options);this.destroyVb();}/**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */},{key:\"addFrame\",value:function addFrame(texture,x,y,animX,animY){this.tile(texture,x,y,{animX:animX,animY:animY});return true;}/**\r\n     * Deprecated signature for {@link Tilemap.tile tile}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */ // eslint-disable-next-line max-params\n},{key:\"addRect\",value:function addRect(textureIndex,u,v,x,y,tileWidth,tileHeight){var animX=arguments.length>7&&arguments[7]!==undefined?arguments[7]:0;var animY=arguments.length>8&&arguments[8]!==undefined?arguments[8]:0;var rotate=arguments.length>9&&arguments[9]!==undefined?arguments[9]:0;var animCountX=arguments.length>10&&arguments[10]!==undefined?arguments[10]:1024;var animCountY=arguments.length>11&&arguments[11]!==undefined?arguments[11]:1024;var animDivisor=arguments.length>12&&arguments[12]!==undefined?arguments[12]:1;var alpha=arguments.length>13&&arguments[13]!==undefined?arguments[13]:1;return this.tile(textureIndex,x,y,{u:u,v:v,tileWidth:tileWidth,tileHeight:tileHeight,animX:animX,animY:animY,rotate:rotate,animCountX:animCountX,animCountY:animCountY,animDivisor:animDivisor,alpha:alpha});}}]);return Tilemap;}(Container);/**\r\n * A tilemap composite that lazily builds tilesets layered into multiple tilemaps.\r\n *\r\n * The composite tileset is the concatenatation of the individual tilesets used in the tilemaps. You can\r\n * preinitialized it by passing a list of tile textures to the constructor. Otherwise, the composite tilemap\r\n * is lazily built as you add more tiles with newer tile textures. A new tilemap is created once the last\r\n * tilemap has reached its limit (as set by {@link CompositeTilemap.texturesPerTilemap texturesPerTilemap}).\r\n *\r\n * @example\r\n * import { Application } from '@pixi/app';\r\n * import { CompositeTilemap } from '@pixi/tilemap';\r\n * import { Loader } from '@pixi/loaders';\r\n *\r\n * // Setup view & stage.\r\n * const app = new Application();\r\n *\r\n * document.body.appendChild(app.renderer.view);\r\n * app.stage.interactive = true;\r\n *\r\n * // Global reference to the tilemap.\r\n * let globalTilemap: CompositeTilemap;\r\n *\r\n * // Load the tileset spritesheet!\r\n * Loader.shared.load('atlas.json');\r\n *\r\n * // Initialize the tilemap scene when the assets load.\r\n * Loader.shared.load(function onTilesetLoaded()\r\n * {\r\n *      const tilemap = new CompositeTilemap();\r\n *\r\n *      // Setup the game level with grass and dungeons!\r\n *      for (let x = 0; x < 10; x++)\r\n *      {\r\n *          for (let y = 0; y < 10; y++)\r\n *          {\r\n *              tilemap.tile(\r\n *                  x % 2 === 0 && (x === y || x + y === 10) ? 'dungeon.png' : 'grass.png',\r\n *                  x * 100,\r\n *                  y * 100,\r\n *              );\r\n *          }\r\n *      }\r\n *\r\n *      globalTilemap = app.stage.addChild(tilemap);\r\n * });\r\n *\r\n * // Show a bomb at a random location whenever the user clicks!\r\n * app.stage.on('click', function onClick()\r\n * {\r\n *      if (!globalTilemap) return;\r\n *\r\n *      const x = Math.floor(Math.random() * 10);\r\n *      const y = Math.floor(Math.random() * 10);\r\n *\r\n *      globalTilemap.tile('bomb.png', x * 100, y * 100);\r\n * });\r\n */var CompositeTilemap=/*#__PURE__*/function(_Container2){_inherits(CompositeTilemap,_Container2);var _super2=_createSuper(CompositeTilemap);/**\r\n     * @param tileset - A list of tile base-textures that will be used to eagerly initialized the layered\r\n     *  tilemaps. This is only an performance optimization, and using {@link CompositeTilemap.tile tile}\r\n     *  will work equivalently.\r\n     */function CompositeTilemap(tileset){var _this3;_classCallCheck(this,CompositeTilemap);_this3=_super2.call(this);CompositeTilemap.prototype.__init.call(_assertThisInitialized(_this3));CompositeTilemap.prototype.__init2.call(_assertThisInitialized(_this3));CompositeTilemap.prototype.__init3.call(_assertThisInitialized(_this3));CompositeTilemap.prototype.__init4.call(_assertThisInitialized(_this3));CompositeTilemap.prototype.__init5.call(_assertThisInitialized(_this3));CompositeTilemap.prototype.__init6.call(_assertThisInitialized(_this3));_this3.tileset(tileset);_this3.texturesPerTilemap=settings.TEXTURES_PER_TILEMAP;return _this3;}/**\r\n     * This will preinitialize the tilesets of the layered tilemaps.\r\n     *\r\n     * If used after a tilemap has been created (or a tile added), this will overwrite the tile textures of the\r\n     * existing tilemaps. Passing the tileset to the constructor instead is the best practice.\r\n     *\r\n     * @param tileTextures - The list of tile textures that make up the tileset.\r\n     */_createClass(CompositeTilemap,[{key:\"__init\",value:/** The hard limit on the number of tile textures used in each tilemap. */ /**\r\n     * The animation frame vector.\r\n     *\r\n     * Animated tiles have four parameters - `animX`, `animY`, `animCountX`, `animCountY`. The textures\r\n     * of adjacent animation frames are at offset `animX` or `animY` of each other, with `animCountX` per\r\n     * row and `animCountY` per column.\r\n     *\r\n     * The animation frame vector specifies which animation frame texture to use. If the x/y coordinate is\r\n     * larger than the `animCountX` or `animCountY` for a specific tile, the modulus is taken.\r\n     */function __init(){this.tileAnim=null;}/** The last modified tilemap. */},{key:\"__init2\",value:function __init2(){this.lastModifiedTilemap=null;}},{key:\"__init3\",value:function __init3(){this.modificationMarker=0;}},{key:\"__init4\",value:function __init4(){this.shadowColor=new Float32Array([0.0,0.0,0.0,0.5]);}},{key:\"__init5\",value:function __init5(){this._globalMat=null;}},{key:\"tileset\",value:function tileset(tileTextures){if(!tileTextures){tileTextures=[];}var texPerChild=this.texturesPerTilemap;var len1=this.children.length;var len2=Math.ceil(tileTextures.length/texPerChild);for(var i=0;i<Math.min(len1,len2);i++){this.children[i].setTileset(tileTextures.slice(i*texPerChild,(i+1)*texPerChild));}for(var _i=len1;_i<len2;_i++){var tilemap=new Tilemap(tileTextures.slice(_i*texPerChild,(_i+1)*texPerChild));tilemap.compositeParent=true;tilemap.offsetX=settings.TEXTILE_DIMEN;tilemap.offsetY=settings.TEXTILE_DIMEN;// TODO: Don't use children\nthis.addChild(tilemap);}return this;}/** Clears the tilemap composite. */},{key:\"clear\",value:function clear(){for(var i=0;i<this.children.length;i++){this.children[i].clear();}this.modificationMarker=0;return this;}/** Changes the rotation of the last added tile. */},{key:\"tileRotate\",value:function tileRotate(rotate){if(this.lastModifiedTilemap){this.lastModifiedTilemap.tileRotate(rotate);}return this;}/** Changes `animX`, `animCountX` of the last added tile. */},{key:\"tileAnimX\",value:function tileAnimX(offset,count){if(this.lastModifiedTilemap){this.lastModifiedTilemap.tileAnimX(offset,count);}return this;}/** Changes `animY`, `animCountY` of the last added tile. */},{key:\"tileAnimY\",value:function tileAnimY(offset,count){if(this.lastModifiedTilemap){this.lastModifiedTilemap.tileAnimY(offset,count);}return this;}/** Changes `tileAnimDivisor` value of the last added tile. */},{key:\"tileAnimDivisor\",value:function tileAnimDivisor(divisor){if(this.lastModifiedTilemap){this.lastModifiedTilemap.tileAnimDivisor(divisor);}return this;}/**\r\n     * Adds a tile that paints the given tile texture at (x, y).\r\n     *\r\n     * @param tileTexture - The tile texture. You can pass an index into the composite tilemap as well.\r\n     * @param x - The local x-coordinate of the tile's location.\r\n     * @param y - The local y-coordinate of the tile's location.\r\n     * @param options - Additional options to pass to {@link Tilemap.tile}.\r\n     * @param [options.u=texture.frame.x] - The x-coordinate of the texture in its base-texture's space.\r\n     * @param [options.v=texture.frame.y] - The y-coordinate of the texture in its base-texture's space.\r\n     * @param [options.tileWidth=texture.orig.width] - The local width of the tile.\r\n     * @param [options.tileHeight=texture.orig.height] - The local height of the tile.\r\n     * @param [options.animX=0] - For animated tiles, this is the \"offset\" along the x-axis for adjacent\r\n     *      animation frame textures in the base-texture.\r\n     * @param [options.animY=0] - For animated tiles, this is the \"offset\" along the y-axis for adjacent\r\n     *      animation frames textures in the base-texture.\r\n     * @param [options.rotate=0]\r\n     * @param [options.animCountX=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per row.\r\n     * @param [options.animCountY=1024] - For animated tiles, this is the number of animation frame textures\r\n     *      per column.\r\n     * @param [options.animDivisor=1] - For animated tiles, this is the animation duration each frame\r\n     * @param [options.alpha=1] - Tile alpha\r\n     * @return This tilemap, good for chaining.\r\n     */},{key:\"tile\",value:function tile(tileTexture,x,y){var options=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};var tilemap=null;var children=this.children;this.lastModifiedTilemap=null;if(typeof tileTexture==='number'){var childIndex=tileTexture/this.texturesPerTilemap>>0;var tileIndex=0;tilemap=children[childIndex];if(!tilemap){tilemap=children[0];// Silently fail if the tilemap doesn't exist\nif(!tilemap)return this;tileIndex=0;}else{tileIndex=tileTexture%this.texturesPerTilemap;}tilemap.tile(tileIndex,x,y,options);}else{if(typeof tileTexture==='string'){tileTexture=Texture.from(tileTexture);}// Probe all tilemaps to find which tileset contains the base-texture.\nfor(var i=0;i<children.length;i++){var child=children[i];var tex=child.getTileset();for(var j=0;j<tex.length;j++){if(tex[j]===tileTexture.baseTexture){tilemap=child;break;}}if(tilemap){break;}}// If no tileset contains the base-texture, attempt to add it.\nif(!tilemap){// Probe the tilemaps to find one below capacity. If so, add the texture into that tilemap.\nfor(var _i2=children.length-1;_i2>=0;_i2--){var _child=children[_i2];if(_child.getTileset().length<this.texturesPerTilemap){tilemap=_child;_child.getTileset().push(tileTexture.baseTexture);break;}}// Otherwise, create a new tilemap initialized with that tile texture.\nif(!tilemap){tilemap=new Tilemap(tileTexture.baseTexture);tilemap.compositeParent=true;tilemap.offsetX=settings.TEXTILE_DIMEN;tilemap.offsetY=settings.TEXTILE_DIMEN;this.addChild(tilemap);}}tilemap.tile(tileTexture,x,y,options);}this.lastModifiedTilemap=tilemap;return this;}},{key:\"renderCanvas\",value:function renderCanvas(renderer){if(!this.visible||this.worldAlpha<=0||!this.renderable){return;}var tilemapPlugin=CanvasTileRenderer.getInstance(renderer);if(tilemapPlugin&&!tilemapPlugin.dontUseTransform){var wt=this.worldTransform;renderer.context.setTransform(wt.a,wt.b,wt.c,wt.d,wt.tx*renderer.resolution,wt.ty*renderer.resolution);}var layers=this.children;for(var i=0;i<layers.length;i++){var layer=layers[i];layer.tileAnim=this.tileAnim;layer.renderCanvasCore(renderer);}}},{key:\"render\",value:function render(renderer){if(!this.visible||this.worldAlpha<=0||!this.renderable){return;}var plugin=renderer.plugins.tilemap;var shader=plugin.getShader();renderer.batch.setObjectRenderer(plugin);// TODO: dont create new array, please\nthis._globalMat=shader.uniforms.projTransMatrix;renderer.globalUniforms.uniforms.projectionMatrix.copyTo(this._globalMat).append(this.worldTransform);shader.uniforms.shadowColor=this.shadowColor;shader.uniforms.animationFrame=this.tileAnim||plugin.tileAnim;renderer.shader.bind(shader,false);var layers=this.children;for(var i=0;i<layers.length;i++){layers[i].renderWebGLCore(renderer,plugin);}}/**\r\n     * @internal\r\n     * @ignore\r\n     */},{key:\"isModified\",value:function isModified(anim){var layers=this.children;if(this.modificationMarker!==layers.length){return true;}for(var i=0;i<layers.length;i++){if(layers[i].isModified(anim)){return true;}}return false;}/**\r\n     * @internal\r\n     * @ignore\r\n     */},{key:\"clearModify\",value:function clearModify(){var layers=this.children;this.modificationMarker=layers.length;for(var i=0;i<layers.length;i++){layers[i].clearModify();}}/**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @see CompositeTilemap.tile\r\n     */},{key:\"addFrame\",value:function addFrame(texture,x,y,animX,animY,animWidth,animHeight,animDivisor,alpha){return this.tile(texture,x,y,{animX:animX,animY:animY,animCountX:animWidth,animCountY:animHeight,animDivisor:animDivisor,alpha:alpha});}/**\r\n     * @deprecated @pixi/tilemap 3\r\n     * @see CompositeTilemap.tile\r\n     */ // eslint-disable-next-line max-params\n},{key:\"addRect\",value:function addRect(textureIndex,u,v,x,y,tileWidth,tileHeight,animX,animY,rotate,animWidth,animHeight){var childIndex=textureIndex/this.texturesPerTilemap>>0;var textureId=textureIndex%this.texturesPerTilemap;if(this.children[childIndex]&&this.children[childIndex].getTileset()){this.lastModifiedTilemap=this.children[childIndex];this.lastModifiedTilemap.addRect(textureId,u,v,x,y,tileWidth,tileHeight,animX,animY,rotate,animWidth,animHeight);}else{this.lastModifiedTilemap=null;}return this;}/**\r\n     * Alias for {@link CompositeTilemap.tileset tileset}.\r\n     *\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     */},{key:\"__init6\",value:function __init6(){this.setBitmaps=this.tileset;}/**\r\n     * @deprecated Since @pixi/tilemap 3.\r\n     * @readonly\r\n     * @see CompositeTilemap.texturesPerTilemap\r\n     */},{key:\"texPerChild\",get:function get(){return this.texturesPerTilemap;}}]);return CompositeTilemap;}(Container);// For some reason ESLint goes mad with indendation in this file ^&^\n/* eslint-disable indent */ /**\r\n * This texture tiling resource can be used to upload multiple base-textures together.\r\n *\r\n * This resource combines multiple base-textures into a \"textile\". They're laid out in\r\n * a dual column format, placed in row-order order. The size of each tile is predefined,\r\n * and defaults to {@link settings.TEXTILE_DIMEN}. This means that each input base-texture\r\n * must is smaller than that along both its width and height.\r\n *\r\n * @see settings.TEXTILE_UNITS\r\n */var TextileResource=/*#__PURE__*/function(_Resource){_inherits(TextileResource,_Resource);var _super3=_createSuper(TextileResource);/**\r\n\t * @param options - This will default to the \"settings\" exported by @pixi/tilemap.\r\n\t * @param options.TEXTILE_DIMEN - The dimensions of each tile.\r\n\t * @param options.TEXTILE_UNITS - The number of texture tiles.\r\n\t */function TextileResource(){var _this4;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:settings;_classCallCheck(this,TextileResource);_this4=_super3.call(this,options.TEXTILE_DIMEN*2,options.TEXTILE_DIMEN*Math.ceil(options.TEXTILE_UNITS/2));TextileResource.prototype.__init.call(_assertThisInitialized(_this4));TextileResource.prototype.__init2.call(_assertThisInitialized(_this4));var tiles=_this4.tiles=new Array(options.TEXTILE_UNITS);_this4.doClear=!!options.DO_CLEAR;_this4.tileDimen=options.TEXTILE_DIMEN;for(var j=0;j<options.TEXTILE_UNITS;j++){tiles[j]={dirtyId:0,x:options.TEXTILE_DIMEN*(j&1),y:options.TEXTILE_DIMEN*(j>>1),baseTexture:Texture.WHITE.baseTexture};}return _this4;}/**\r\n\t * Sets the texture to be uploaded for the given tile.\r\n\t *\r\n\t * @param index - The index of the tile being set.\r\n\t * @param texture - The texture with the base-texture to upload.\r\n\t */_createClass(TextileResource,[{key:\"__init\",value:/** The base-texture that contains all the texture tiles. */function __init(){this.baseTexture=null;}},{key:\"__init2\",value:function __init2(){this._clearBuffer=null;}},{key:\"tile\",value:function tile(index,texture){var tile=this.tiles[index];if(tile.baseTexture===texture){return;}tile.baseTexture=texture;this.baseTexture.update();this.tiles[index].dirtyId=this.baseTexture.dirtyId;}/** @override */},{key:\"bind\",value:function bind(baseTexture){if(this.baseTexture){throw new Error('Only one baseTexture is allowed for this resource!');}this.baseTexture=baseTexture;_get(_getPrototypeOf(TextileResource.prototype),\"bind\",this).call(this,baseTexture);}/** @override */},{key:\"upload\",value:function upload(renderer,texture,glTexture){var gl=renderer.gl;var width=this.width,height=this.height;gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.alphaMode===undefined||texture.alphaMode===ALPHA_MODES.UNPACK);if(glTexture.dirtyId<0){glTexture.width=width;glTexture.height=height;gl.texImage2D(texture.target,0,texture.format,width,height,0,texture.format,texture.type,null);}var doClear=this.doClear;var tiles=this.tiles;if(doClear&&!this._clearBuffer){this._clearBuffer=new Uint8Array(settings.TEXTILE_DIMEN*settings.TEXTILE_DIMEN*4);}for(var i=0;i<tiles.length;i++){var spr=tiles[i];var tex=spr.baseTexture;if(glTexture.dirtyId>=this.tiles[i].dirtyId){continue;}var res=tex.resource;if(!tex.valid||!res||!res.source){continue;}if(doClear&&(tex.width<this.tileDimen||tex.height<this.tileDimen)){gl.texSubImage2D(texture.target,0,spr.x,spr.y,this.tileDimen,this.tileDimen,texture.format,texture.type,this._clearBuffer);}gl.texSubImage2D(texture.target,0,spr.x,spr.y,texture.format,texture.type,res.source);}return true;}}]);return TextileResource;}(Resource);/**\r\n * This will generate fragment shader code that samples the correct texture into the \"color\" variable.\r\n *\r\n * @internal\r\n * @ignore\r\n * @param maxTextures - The texture array length in the shader's uniforms.\r\n */function generateSampleSrc(maxTextures){var src='';src+='\\n';src+='\\n';src+='if(vTextureId <= -1.0) {';src+='\\n\\tcolor = shadowColor;';src+='\\n}';for(var i=0;i<maxTextures;i++){src+='\\nelse ';if(i<maxTextures-1){src+=\"if(textureId == \".concat(i,\".0)\");}src+='\\n{';src+=\"\\n\\tcolor = texture2D(uSamplers[\".concat(i,\"], textureCoord * uSamplerSize[\").concat(i,\"]);\");src+='\\n}';}src+='\\n';src+='\\n';return src;}/**\r\n * @internal\r\n * @ignore\r\n * @param shader\r\n * @param maxTextures\r\n */function fillSamplers(shader,maxTextures){var sampleValues=[];for(var i=0;i<maxTextures;i++){sampleValues[i]=i;}shader.uniforms.uSamplers=sampleValues;var samplerSize=[];for(var _i3=0;_i3<maxTextures;_i3++){// These are overwritten by TileRenderer when textures actually bound.\nsamplerSize.push(1.0/2048);samplerSize.push(1.0/2048);}shader.uniforms.uSamplerSize=samplerSize;}/**\r\n * @internal\r\n * @ignore\r\n * @param maxTextures\r\n * @param fragmentSrc\r\n * @returns\r\n */function generateFragmentSrc(maxTextures,fragmentSrc){return fragmentSrc.replace(/%count%/gi,\"\".concat(maxTextures)).replace(/%forloop%/gi,generateSampleSrc(maxTextures));}// eslint-disable-next-line @typescript-eslint/triple-slash-reference, spaced-comment\nvar tilemapVertexTemplateSrc=\"#version 100\\nprecision highp float;\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\nattribute vec4 aFrame;\\nattribute vec2 aAnim;\\nattribute float aAnimDivisor;\\nattribute float aTextureId;\\nattribute float aAlpha;\\n\\nuniform mat3 projTransMatrix;\\nuniform vec2 animationFrame;\\n\\nvarying vec2 vTextureCoord;\\nvarying float vTextureId;\\nvarying vec4 vFrame;\\nvarying float vAlpha;\\n\\nvoid main(void)\\n{\\n   gl_Position = vec4((projTransMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n   vec2 animCount = floor((aAnim + 0.5) / 2048.0);\\n   vec2 animFrameOffset = aAnim - animCount * 2048.0;\\n   vec2 currentFrame = floor(animationFrame / aAnimDivisor);\\n   vec2 animOffset = animFrameOffset * floor(mod(currentFrame + 0.5, animCount));\\n\\n   vTextureCoord = aTextureCoord + animOffset;\\n   vFrame = aFrame + vec4(animOffset, animOffset);\\n   vTextureId = aTextureId;\\n   vAlpha = aAlpha;\\n}\\n\";var tilemapFragmentTemplateSrc=\"#version 100\\n#ifdef GL_FRAGMENT_PRECISION_HIGH\\nprecision highp float;\\n#else\\nprecision mediump float;\\n#endif\\nvarying vec2 vTextureCoord;\\nvarying vec4 vFrame;\\nvarying float vTextureId;\\nvarying float vAlpha;\\nuniform vec4 shadowColor;\\nuniform sampler2D uSamplers[%count%];\\nuniform vec2 uSamplerSize[%count%];\\n\\nvoid main(void)\\n{\\n   vec2 textureCoord = clamp(vTextureCoord, vFrame.xy, vFrame.zw);\\n   float textureId = floor(vTextureId + 0.5);\\n\\n   vec4 color;\\n   %forloop%\\n   gl_FragColor = color * vAlpha;\\n}\\n\";// For some reason ESLint goes mad with indendation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */var TilemapShader=/*#__PURE__*/function(_Shader){_inherits(TilemapShader,_Shader);var _super4=_createSuper(TilemapShader);function TilemapShader(maxTextures){var _this5;_classCallCheck(this,TilemapShader);_this5=_super4.call(this,new Program(tilemapVertexTemplateSrc,generateFragmentSrc(maxTextures,tilemapFragmentTemplateSrc)),{animationFrame:new Float32Array(2),uSamplers:[],uSamplerSize:[],projTransMatrix:new Matrix()});TilemapShader.prototype.__init.call(_assertThisInitialized(_this5));_this5.maxTextures=maxTextures;fillSamplers(_assertThisInitialized(_this5),_this5.maxTextures);return _this5;}_createClass(TilemapShader,[{key:\"__init\",value:function __init(){this.maxTextures=0;}}]);return TilemapShader;}(Shader);var TilemapGeometry=/*#__PURE__*/function(_Geometry){_inherits(TilemapGeometry,_Geometry);var _super5=_createSuper(TilemapGeometry);function TilemapGeometry(){var _this6;_classCallCheck(this,TilemapGeometry);_this6=_super5.call(this);TilemapGeometry.prototype.__init2.call(_assertThisInitialized(_this6));TilemapGeometry.prototype.__init3.call(_assertThisInitialized(_this6));TilemapGeometry.prototype.__init4.call(_assertThisInitialized(_this6));TilemapGeometry.prototype.__init5.call(_assertThisInitialized(_this6));var buf=_this6.buf=new Buffer(new Float32Array(2),true,false);_this6.addAttribute('aVertexPosition',buf,0,false,0,_this6.stride,0).addAttribute('aTextureCoord',buf,0,false,0,_this6.stride,2*4).addAttribute('aFrame',buf,0,false,0,_this6.stride,4*4).addAttribute('aAnim',buf,0,false,0,_this6.stride,8*4).addAttribute('aTextureId',buf,0,false,0,_this6.stride,10*4).addAttribute('aAnimDivisor',buf,0,false,0,_this6.stride,11*4).addAttribute('aAlpha',buf,0,false,0,_this6.stride,12*4);return _this6;}_createClass(TilemapGeometry,[{key:\"__init2\",value:function __init2(){this.vertSize=13;}},{key:\"__init3\",value:function __init3(){this.vertPerQuad=4;}},{key:\"__init4\",value:function __init4(){this.stride=this.vertSize*4;}},{key:\"__init5\",value:function __init5(){this.lastTimeAccess=0;}}]);return TilemapGeometry;}(Geometry);// For some reason ESLint goes mad with indendation in this file ^&^\n/* eslint-disable no-mixed-spaces-and-tabs, indent */ /**\r\n * Rendering helper pipeline for tilemaps. This plugin is registered automatically.\r\n */var TileRenderer=/*#__PURE__*/function(_ObjectRenderer){_inherits(TileRenderer,_ObjectRenderer);var _super6=_createSuper(TileRenderer);/** @param renderer - The managing renderer */function TileRenderer(renderer){var _this7;_classCallCheck(this,TileRenderer);_this7=_super6.call(this,renderer);TileRenderer.prototype.__init.call(_assertThisInitialized(_this7));TileRenderer.prototype.__init2.call(_assertThisInitialized(_this7));TileRenderer.prototype.__init3.call(_assertThisInitialized(_this7));TileRenderer.prototype.__init4.call(_assertThisInitialized(_this7));_this7.shader=new TilemapShader(settings.TEXTURES_PER_TILEMAP);_this7.indexBuffer=new Buffer(undefined,true,true);_this7.checkIndexBuffer(2000);_this7.makeTextiles();return _this7;}/**\r\n\t * Binds the tile textures to the renderer, and updates the tilemap shader's `uSamplerSize` uniform.\r\n\t *\r\n\t * If {@link settings.TEXTILE_UNITS}\r\n\t *\r\n\t * @param renderer - The renderer to which the textures are to be bound.\r\n\t * @param textures - The tile textures being bound.\r\n\t */_createClass(TileRenderer,[{key:\"__init\",value:/** The managing renderer */ /** The tile animation frame */function __init(){this.tileAnim=[0,0];}},{key:\"__init2\",value:function __init2(){this.ibLen=0;}// index buffer length\n/** The index buffer for the tilemaps to share. */},{key:\"__init3\",value:function __init3(){this.indexBuffer=null;}/** The shader used to render tilemaps. */ /**\r\n\t * {@link TextileResource} instances used to upload textures batched in tiled groups. This is\r\n\t * used only if {@link settings.TEXTURES_PER_TILEMAP} is greater than 1.\r\n\t */},{key:\"__init4\",value:function __init4(){this.textiles=[];}},{key:\"bindTileTextures\",value:function bindTileTextures(renderer,textures){var len=textures.length;var shader=this.shader;var maxTextures=settings.TEXTURES_PER_TILEMAP;var samplerSize=shader.uniforms.uSamplerSize;if(len>settings.TEXTILE_UNITS*maxTextures){// TODO: Show error message instead of silently failing!\nreturn;}if(settings.TEXTILE_UNITS<=1){// Bind each texture directly & update samplerSize.\nfor(var i=0;i<textures.length;i++){var texture=textures[i];if(!texture||!texture.valid){return;}renderer.texture.bind(textures[i],i);samplerSize[i*2]=1.0/textures[i].realWidth;samplerSize[i*2+1]=1.0/textures[i].realHeight;}}else{// Ensure we have enough textiles, in case settings.TEXTILE_UNITS was modified.\nthis.makeTextiles();var usedTextiles=Math.ceil(len/settings.TEXTILE_UNITS);// First ensure each textile has all tiles point to the right textures.\nfor(var _i4=0;_i4<len;_i4++){var _texture=textures[_i4];if(_texture&&_texture.valid){var resourceIndex=Math.floor(_i4/settings.TEXTILE_UNITS);var tileIndex=_i4%settings.TEXTILE_UNITS;this.textiles[resourceIndex].tile(tileIndex,_texture);}}// Then bind the textiles + update samplerSize.\nfor(var _i5=0;_i5<usedTextiles;_i5++){renderer.texture.bind(this.textiles[_i5].baseTexture,_i5);samplerSize[_i5*2]=1.0/this.textiles[_i5].width;samplerSize[_i5*2+1]=1.0/this.textiles[_i5].baseTexture.height;}}shader.uniforms.uSamplerSize=samplerSize;}},{key:\"start\",value:function start(){// sorry, nothing\n}/**\r\n\t * @internal\r\n\t * @ignore\r\n\t */},{key:\"createVb\",value:function createVb(){var geom=new TilemapGeometry();geom.addIndex(this.indexBuffer);geom.lastTimeAccess=Date.now();return geom;}/** @return The {@link TilemapShader} shader that this rendering pipeline is using. */},{key:\"getShader\",value:function getShader(){return this.shader;}},{key:\"destroy\",value:function destroy(){_get(_getPrototypeOf(TileRenderer.prototype),\"destroy\",this).call(this);// this.rectShader.destroy();\nthis.shader=null;}},{key:\"checkIndexBuffer\",value:function checkIndexBuffer(size){var _vb=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var totalIndices=size*6;if(totalIndices<=this.ibLen){return;}this.ibLen=totalIndices;this.indexBuffer.update(createIndicesForQuads(size,settings.use32bitIndex?new Uint32Array(size*6):undefined));// \tTODO: create new index buffer instead?\n// if (vb) {\n// \tconst curIndex = vb.getIndex();\n// \tif (curIndex !== this.indexBuffer && (curIndex.data as any).length < totalIndices) {\n// \t\tthis.swapIndex(vb, this.indexBuffer);\n// \t}\n// }\n}/** Makes textile resources and initializes {@link TileRenderer.textiles}. */},{key:\"makeTextiles\",value:function makeTextiles(){if(settings.TEXTILE_UNITS<=1){return;}for(var i=0;i<settings.TEXTILE_UNITS;i++){if(this.textiles[i])continue;var resource=new TextileResource();var baseTex=new BaseTexture(resource);baseTex.scaleMode=settings.TEXTILE_SCALE_MODE;baseTex.wrapMode=WRAP_MODES.CLAMP;this.textiles[i]=resource;}}}]);return TileRenderer;}(ObjectRenderer);// eslint-disable-next-line camelcase\nvar pixi_tilemap={CanvasTileRenderer:CanvasTileRenderer,CompositeRectTileLayer:CompositeTilemap,CompositeTilemap:CompositeTilemap,Constant:Constant,TextileResource:TextileResource,MultiTextureResource:TextileResource,RectTileLayer:Tilemap,Tilemap:Tilemap,TilemapShader:TilemapShader,TilemapGeometry:TilemapGeometry,RectTileShader:TilemapShader,RectTileGeom:TilemapGeometry,TileRenderer:TileRenderer};Renderer.registerPlugin('tilemap',TileRenderer);export{CanvasTileRenderer,CompositeTilemap as CompositeRectTileLayer,CompositeTilemap,Constant,POINT_STRUCT_SIZE,Tilemap as RectTileLayer,TextileResource,TileRenderer,Tilemap,TilemapGeometry,TilemapShader,fillSamplers,generateFragmentSrc,pixi_tilemap,settings};","map":null,"metadata":{},"sourceType":"module"}