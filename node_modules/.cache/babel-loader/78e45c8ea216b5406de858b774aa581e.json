{"ast":null,"code":"/*!\n * @pixi/display - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/display is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{settings}from'@pixi/settings';import{Rectangle,RAD_TO_DEG,DEG_TO_RAD,Transform}from'@pixi/math';import{EventEmitter,removeItems}from'@pixi/utils';/**\n * Sets the default value for the container property 'sortableChildren'.\n * If set to true, the container will sort its children by zIndex value\n * when updateTransform() is called, or manually if sortChildren() is called.\n *\n * This actually changes the order of elements in the array, so should be treated\n * as a basic solution that is not performant compared to other solutions,\n * such as @link https://github.com/pixijs/pixi-display\n *\n * Also be aware of that this may not work nicely with the addChildAt() function,\n * as the zIndex sorting may cause the child to automatically sorted to another position.\n *\n * @static\n * @constant\n * @name SORTABLE_CHILDREN\n * @memberof PIXI.settings\n * @type {boolean}\n * @default false\n */settings.SORTABLE_CHILDREN=false;/**\n * 'Builder' pattern for bounds rectangles.\n *\n * This could be called an Axis-Aligned Bounding Box.\n * It is not an actual shape. It is a mutable thing; no 'EMPTY' or those kind of problems.\n *\n * @memberof PIXI\n */var Bounds=/** @class */function(){function Bounds(){this.minX=Infinity;this.minY=Infinity;this.maxX=-Infinity;this.maxY=-Infinity;this.rect=null;this.updateID=-1;}/**\n     * Checks if bounds are empty.\n     *\n     * @return - True if empty.\n     */Bounds.prototype.isEmpty=function(){return this.minX>this.maxX||this.minY>this.maxY;};/** Clears the bounds and resets. */Bounds.prototype.clear=function(){this.minX=Infinity;this.minY=Infinity;this.maxX=-Infinity;this.maxY=-Infinity;};/**\n     * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle\n     * It is not guaranteed that it will return tempRect\n     *\n     * @param rect - Temporary object will be used if AABB is not empty\n     * @returns - A rectangle of the bounds\n     */Bounds.prototype.getRectangle=function(rect){if(this.minX>this.maxX||this.minY>this.maxY){return Rectangle.EMPTY;}rect=rect||new Rectangle(0,0,1,1);rect.x=this.minX;rect.y=this.minY;rect.width=this.maxX-this.minX;rect.height=this.maxY-this.minY;return rect;};/**\n     * This function should be inlined when its possible.\n     *\n     * @param point - The point to add.\n     */Bounds.prototype.addPoint=function(point){this.minX=Math.min(this.minX,point.x);this.maxX=Math.max(this.maxX,point.x);this.minY=Math.min(this.minY,point.y);this.maxY=Math.max(this.maxY,point.y);};/** Adds a point, after transformed. This should be inlined when its possible. */Bounds.prototype.addPointMatrix=function(matrix,point){var a=matrix.a,b=matrix.b,c=matrix.c,d=matrix.d,tx=matrix.tx,ty=matrix.ty;var x=a*point.x+c*point.y+tx;var y=b*point.x+d*point.y+ty;this.minX=Math.min(this.minX,x);this.maxX=Math.max(this.maxX,x);this.minY=Math.min(this.minY,y);this.maxY=Math.max(this.maxY,y);};/**\n     * Adds a quad, not transformed\n     *\n     * @param vertices - The verts to add.\n     */Bounds.prototype.addQuad=function(vertices){var minX=this.minX;var minY=this.minY;var maxX=this.maxX;var maxY=this.maxY;var x=vertices[0];var y=vertices[1];minX=x<minX?x:minX;minY=y<minY?y:minY;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;x=vertices[2];y=vertices[3];minX=x<minX?x:minX;minY=y<minY?y:minY;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;x=vertices[4];y=vertices[5];minX=x<minX?x:minX;minY=y<minY?y:minY;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;x=vertices[6];y=vertices[7];minX=x<minX?x:minX;minY=y<minY?y:minY;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;this.minX=minX;this.minY=minY;this.maxX=maxX;this.maxY=maxY;};/**\n     * Adds sprite frame, transformed.\n     *\n     * @param transform - transform to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */Bounds.prototype.addFrame=function(transform,x0,y0,x1,y1){this.addFrameMatrix(transform.worldTransform,x0,y0,x1,y1);};/**\n     * Adds sprite frame, multiplied by matrix\n     *\n     * @param matrix - matrix to apply\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */Bounds.prototype.addFrameMatrix=function(matrix,x0,y0,x1,y1){var a=matrix.a;var b=matrix.b;var c=matrix.c;var d=matrix.d;var tx=matrix.tx;var ty=matrix.ty;var minX=this.minX;var minY=this.minY;var maxX=this.maxX;var maxY=this.maxY;var x=a*x0+c*y0+tx;var y=b*x0+d*y0+ty;minX=x<minX?x:minX;minY=y<minY?y:minY;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;x=a*x1+c*y0+tx;y=b*x1+d*y0+ty;minX=x<minX?x:minX;minY=y<minY?y:minY;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;x=a*x0+c*y1+tx;y=b*x0+d*y1+ty;minX=x<minX?x:minX;minY=y<minY?y:minY;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;x=a*x1+c*y1+tx;y=b*x1+d*y1+ty;minX=x<minX?x:minX;minY=y<minY?y:minY;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;this.minX=minX;this.minY=minY;this.maxX=maxX;this.maxY=maxY;};/**\n     * Adds screen vertices from array\n     *\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */Bounds.prototype.addVertexData=function(vertexData,beginOffset,endOffset){var minX=this.minX;var minY=this.minY;var maxX=this.maxX;var maxY=this.maxY;for(var i=beginOffset;i<endOffset;i+=2){var x=vertexData[i];var y=vertexData[i+1];minX=x<minX?x:minX;minY=y<minY?y:minY;maxX=x>maxX?x:maxX;maxY=y>maxY?y:maxY;}this.minX=minX;this.minY=minY;this.maxX=maxX;this.maxY=maxY;};/**\n     * Add an array of mesh vertices\n     *\n     * @param transform - mesh transform\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     */Bounds.prototype.addVertices=function(transform,vertices,beginOffset,endOffset){this.addVerticesMatrix(transform.worldTransform,vertices,beginOffset,endOffset);};/**\n     * Add an array of mesh vertices.\n     *\n     * @param matrix - mesh matrix\n     * @param vertices - mesh coordinates in array\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param padX - x padding\n     * @param padY - y padding\n     */Bounds.prototype.addVerticesMatrix=function(matrix,vertices,beginOffset,endOffset,padX,padY){if(padX===void 0){padX=0;}if(padY===void 0){padY=padX;}var a=matrix.a;var b=matrix.b;var c=matrix.c;var d=matrix.d;var tx=matrix.tx;var ty=matrix.ty;var minX=this.minX;var minY=this.minY;var maxX=this.maxX;var maxY=this.maxY;for(var i=beginOffset;i<endOffset;i+=2){var rawX=vertices[i];var rawY=vertices[i+1];var x=a*rawX+c*rawY+tx;var y=d*rawY+b*rawX+ty;minX=Math.min(minX,x-padX);maxX=Math.max(maxX,x+padX);minY=Math.min(minY,y-padY);maxY=Math.max(maxY,y+padY);}this.minX=minX;this.minY=minY;this.maxX=maxX;this.maxY=maxY;};/**\n     * Adds other {@link Bounds}.\n     *\n     * @param bounds - The Bounds to be added\n     */Bounds.prototype.addBounds=function(bounds){var minX=this.minX;var minY=this.minY;var maxX=this.maxX;var maxY=this.maxY;this.minX=bounds.minX<minX?bounds.minX:minX;this.minY=bounds.minY<minY?bounds.minY:minY;this.maxX=bounds.maxX>maxX?bounds.maxX:maxX;this.maxY=bounds.maxY>maxY?bounds.maxY:maxY;};/**\n     * Adds other Bounds, masked with Bounds.\n     *\n     * @param bounds - The Bounds to be added.\n     * @param mask - TODO\n     */Bounds.prototype.addBoundsMask=function(bounds,mask){var _minX=bounds.minX>mask.minX?bounds.minX:mask.minX;var _minY=bounds.minY>mask.minY?bounds.minY:mask.minY;var _maxX=bounds.maxX<mask.maxX?bounds.maxX:mask.maxX;var _maxY=bounds.maxY<mask.maxY?bounds.maxY:mask.maxY;if(_minX<=_maxX&&_minY<=_maxY){var minX=this.minX;var minY=this.minY;var maxX=this.maxX;var maxY=this.maxY;this.minX=_minX<minX?_minX:minX;this.minY=_minY<minY?_minY:minY;this.maxX=_maxX>maxX?_maxX:maxX;this.maxY=_maxY>maxY?_maxY:maxY;}};/**\n     * Adds other Bounds, multiplied by matrix. Bounds shouldn't be empty.\n     *\n     * @param bounds - other bounds\n     * @param matrix - multiplicator\n     */Bounds.prototype.addBoundsMatrix=function(bounds,matrix){this.addFrameMatrix(matrix,bounds.minX,bounds.minY,bounds.maxX,bounds.maxY);};/**\n     * Adds other Bounds, masked with Rectangle.\n     *\n     * @param bounds - TODO\n     * @param area - TODO\n     */Bounds.prototype.addBoundsArea=function(bounds,area){var _minX=bounds.minX>area.x?bounds.minX:area.x;var _minY=bounds.minY>area.y?bounds.minY:area.y;var _maxX=bounds.maxX<area.x+area.width?bounds.maxX:area.x+area.width;var _maxY=bounds.maxY<area.y+area.height?bounds.maxY:area.y+area.height;if(_minX<=_maxX&&_minY<=_maxY){var minX=this.minX;var minY=this.minY;var maxX=this.maxX;var maxY=this.maxY;this.minX=_minX<minX?_minX:minX;this.minY=_minY<minY?_minY:minY;this.maxX=_maxX>maxX?_maxX:maxX;this.maxY=_maxY>maxY?_maxY:maxY;}};/**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     *\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */Bounds.prototype.pad=function(paddingX,paddingY){if(paddingX===void 0){paddingX=0;}if(paddingY===void 0){paddingY=paddingX;}if(!this.isEmpty()){this.minX-=paddingX;this.maxX+=paddingX;this.minY-=paddingY;this.maxY+=paddingY;}};/**\n     * Adds padded frame. (x0, y0) should be strictly less than (x1, y1)\n     *\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param padX - padding X\n     * @param padY - padding Y\n     */Bounds.prototype.addFramePad=function(x0,y0,x1,y1,padX,padY){x0-=padX;y0-=padY;x1+=padX;y1+=padY;this.minX=this.minX<x0?this.minX:x0;this.maxX=this.maxX>x1?this.maxX:x1;this.minY=this.minY<y0?this.minY:y0;this.maxY=this.maxY>y1?this.maxY:y1;};return Bounds;}();/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */ /* global Reflect, Promise */var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p)){d[p]=b[p];}}};return _extendStatics(d,b);};function __extends(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());}/**\n * The base class for all objects that are rendered on the screen.\n *\n * This is an abstract class and can not be used on its own; rather it should be extended.\n *\n * ## Display objects implemented in PixiJS\n *\n * | Display Object                  | Description                                                           |\n * | ------------------------------- | --------------------------------------------------------------------- |\n * | {@link PIXI.Container}          | Adds support for `children` to DisplayObject                          |\n * | {@link PIXI.Graphics}           | Shape-drawing display object similar to the Canvas API                |\n * | {@link PIXI.Sprite}             | Draws textures (i.e. images)                                          |\n * | {@link PIXI.Text}               | Draws text using the Canvas API internally                            |\n * | {@link PIXI.BitmapText}         | More scaleable solution for text rendering, reusing glyph textures    |\n * | {@link PIXI.TilingSprite}       | Draws textures/images in a tiled fashion                              |\n * | {@link PIXI.AnimatedSprite}     | Draws an animation of multiple images                                 |\n * | {@link PIXI.Mesh}               | Provides a lower-level API for drawing meshes with custom data        |\n * | {@link PIXI.NineSlicePlane}     | Mesh-related                                                          |\n * | {@link PIXI.SimpleMesh}         | v4-compatible mesh                                                    |\n * | {@link PIXI.SimplePlane}        | Mesh-related                                                          |\n * | {@link PIXI.SimpleRope}         | Mesh-related                                                          |\n *\n * ## Transforms\n *\n * The [transform]{@link DisplayObject#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link PIXI.DisplayObject#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link PIXI.DisplayObject#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link PIXI.DisplayObject#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link PIXI.DisplayObject#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link PIXI.DisplayObject#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link PIXI.DisplayObject#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link PIXI.DisplayObject#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are communtative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>angle</td>\n *       <td>Rotation. This is an alias for [rotation]{@link PIXI.DisplayObject#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>x</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>y</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>width</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>height</td>\n *       <td>\n *         Implemented in [Container]{@link PIXI.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n *\n * ## Bounds\n *\n * The bounds of a display object is defined by the minimum axis-aligned rectangle in world space that can fit\n * around it. The abstract `calculateBounds` method is responsible for providing it (and it should use the\n * `worldTransform` to calculate in world space).\n *\n * There are a few additional types of bounding boxes:\n *\n * | Bounds                | Description                                                                              |\n * | --------------------- | ---------------------------------------------------------------------------------------- |\n * | World Bounds          | This is synonymous is the regular bounds described above. See `getBounds()`.             |\n * | Local Bounds          | This the axis-aligned bounding box in the parent's local space. See `getLocalBounds()`.  |\n * | Render Bounds         | The bounds, but including extra rendering effects like filter padding.                   |\n * | Projected Bounds      | The bounds of the projected display object onto the screen. Usually equals world bounds. |\n * | Relative Bounds       | The bounds of a display object when projected onto a ancestor's (or parent's) space.     |\n * | Natural Bounds        | The bounds of an object in its own local space (not parent's space, like in local bounds)|\n * | Content Bounds        | The natural bounds when excluding all children of a `Container`.                         |\n *\n * ### calculateBounds\n *\n * [Container]{@link Container} already implements `calculateBounds` in a manner that includes children.\n *\n * But for a non-Container display object, the `calculateBounds` method must be overridden in order for `getBounds` and\n * `getLocalBounds` to work. This method must write the bounds into `this._bounds`.\n *\n * Generally, the following technique works for most simple cases: take the list of points\n * forming the \"hull\" of the object (i.e. outline of the object's shape), and then add them\n * using {@link PIXI.Bounds#addPointMatrix}.\n *\n * ```js\n * calculateBounds(): void\n * {\n *     const points = [...];\n *\n *     for (let i = 0, j = points.length; i < j; i++)\n *     {\n *         this._bounds.addPointMatrix(this.worldTransform, points[i]);\n *     }\n * }\n * ```\n *\n * You can optimize this for a large number of points by using {@link PIXI.Bounds#addVerticesMatrix} to pass them\n * in one array together.\n *\n * ## Alpha\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n *\n * The alpha with which the display object will be rendered is called the [worldAlpha]{@link PIXI.DisplayObject#worldAlpha}.\n *\n * ## Renderable vs Visible\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n *\n * It is recommended that applications use the `renderable` property for culling. See\n * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} or\n * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull} for more details.\n *\n * Otherwise, to prevent an object from rendering in the general-purpose sense - `visible` is the property to use. This\n * one is also better in terms of performance.\n *\n * @memberof PIXI\n */var DisplayObject=/** @class */function(_super){__extends(DisplayObject,_super);function DisplayObject(){var _this=_super.call(this)||this;_this.tempDisplayObjectParent=null;// TODO: need to create Transform from factory\n_this.transform=new Transform();_this.alpha=1;_this.visible=true;_this.renderable=true;_this.cullable=false;_this.cullArea=null;_this.parent=null;_this.worldAlpha=1;_this._lastSortedIndex=0;_this._zIndex=0;_this.filterArea=null;_this.filters=null;_this._enabledFilters=null;_this._bounds=new Bounds();_this._localBounds=null;_this._boundsID=0;_this._boundsRect=null;_this._localBoundsRect=null;_this._mask=null;_this._maskRefCount=0;_this._destroyed=false;_this.isSprite=false;_this.isMask=false;return _this;}/**\n     * Mixes all enumerable properties and methods from a source object to DisplayObject.\n     *\n     * @param source - The source of properties and methods to mix in.\n     */DisplayObject.mixin=function(source){// in ES8/ES2017, this would be really easy:\n// Object.defineProperties(DisplayObject.prototype, Object.getOwnPropertyDescriptors(source));\n// get all the enumerable property keys\nvar keys=Object.keys(source);// loop through properties\nfor(var i=0;i<keys.length;++i){var propertyName=keys[i];// Set the property using the property descriptor - this works for accessors and normal value properties\nObject.defineProperty(DisplayObject.prototype,propertyName,Object.getOwnPropertyDescriptor(source,propertyName));}};Object.defineProperty(DisplayObject.prototype,\"destroyed\",{/**\n         * Fired when this DisplayObject is added to a Container.\n         *\n         * @instance\n         * @event added\n         * @param {PIXI.Container} container - The container added to.\n         */ /**\n         * Fired when this DisplayObject is removed from a Container.\n         *\n         * @instance\n         * @event removed\n         * @param {PIXI.Container} container - The container removed from.\n         */ /**\n         * Fired when this DisplayObject is destroyed.\n         *\n         * @instance\n         * @event destroyed\n         */ /** Readonly flag for destroyed display objects. */get:function get(){return this._destroyed;},enumerable:false,configurable:true});/**\n     * Recursively updates transform of all objects from the root to this one\n     * internal function for toLocal()\n     */DisplayObject.prototype._recursivePostUpdateTransform=function(){if(this.parent){this.parent._recursivePostUpdateTransform();this.transform.updateTransform(this.parent.transform);}else{this.transform.updateTransform(this._tempDisplayObjectParent.transform);}};/**\n     * Updates the object transform for rendering.\n     *\n     * TODO - Optimization pass!\n     */DisplayObject.prototype.updateTransform=function(){this._boundsID++;this.transform.updateTransform(this.parent.transform);// multiply the alphas..\nthis.worldAlpha=this.alpha*this.parent.worldAlpha;};/**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link PIXI.Rectangle}.\n     *\n     * This method is expensive on containers with a large subtree (like the stage). This is because the bounds\n     * of a container depend on its children's bounds, which recursively causes all bounds in the subtree to\n     * be recalculated. The upside, however, is that calling `getBounds` once on a container will indeed update\n     * the bounds of all children (the whole subtree, in fact). This side effect should be exploited by using\n     * `displayObject._bounds.getRectangle()` when traversing through all the bounds in a scene graph. Otherwise,\n     * calling `getBounds` on each object in a subtree will cause the total cost to increase quadratically as\n     * its height increases.\n     *\n     * * The transforms of all objects in a container's **subtree** and of all **ancestors** are updated.\n     * * The world bounds of all display objects in a container's **subtree** will also be recalculated.\n     *\n     * The `_bounds` object stores the last calculation of the bounds. You can use to entirely skip bounds\n     * calculation if needed.\n     *\n     * ```js\n     * const lastCalculatedBounds = displayObject._bounds.getRectangle(optionalRect);\n     * ```\n     *\n     * Do know that usage of `getLocalBounds` can corrupt the `_bounds` of children (the whole subtree, actually). This\n     * is a known issue that has not been solved. See [getLocalBounds]{@link PIXI.DisplayObject#getLocalBounds} for more\n     * details.\n     *\n     * `getBounds` should be called with `skipUpdate` equal to `true` in a render() call. This is because the transforms\n     * are guaranteed to be update-to-date. In fact, recalculating inside a render() call may cause corruption in certain\n     * cases.\n     *\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @return - The minimum axis-aligned rectangle in world space that fits around this object.\n     */DisplayObject.prototype.getBounds=function(skipUpdate,rect){if(!skipUpdate){if(!this.parent){this.parent=this._tempDisplayObjectParent;this.updateTransform();this.parent=null;}else{this._recursivePostUpdateTransform();this.updateTransform();}}if(this._bounds.updateID!==this._boundsID){this.calculateBounds();this._bounds.updateID=this._boundsID;}if(!rect){if(!this._boundsRect){this._boundsRect=new Rectangle();}rect=this._boundsRect;}return this._bounds.getRectangle(rect);};/**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     *\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @return - The rectangular bounding area.\n     */DisplayObject.prototype.getLocalBounds=function(rect){if(!rect){if(!this._localBoundsRect){this._localBoundsRect=new Rectangle();}rect=this._localBoundsRect;}if(!this._localBounds){this._localBounds=new Bounds();}var transformRef=this.transform;var parentRef=this.parent;this.parent=null;this.transform=this._tempDisplayObjectParent.transform;var worldBounds=this._bounds;var worldBoundsID=this._boundsID;this._bounds=this._localBounds;var bounds=this.getBounds(false,rect);this.parent=parentRef;this.transform=transformRef;this._bounds=worldBounds;this._bounds.updateID+=this._boundsID-worldBoundsID;// reflect side-effects\nreturn bounds;};/**\n     * Calculates the global position of the display object.\n     *\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @return - A point object representing the position of this object.\n     */DisplayObject.prototype.toGlobal=function(position,point,skipUpdate){if(skipUpdate===void 0){skipUpdate=false;}if(!skipUpdate){this._recursivePostUpdateTransform();// this parent check is for just in case the item is a root object.\n// If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n// this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\nif(!this.parent){this.parent=this._tempDisplayObjectParent;this.displayObjectUpdateTransform();this.parent=null;}else{this.displayObjectUpdateTransform();}}// don't need to update the lot\nreturn this.worldTransform.apply(position,point);};/**\n     * Calculates the local position of the display object relative to another point.\n     *\n     * @param position - The world origin to calculate from.\n     * @param from - The DisplayObject to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @return - A point object representing the position of this object\n     */DisplayObject.prototype.toLocal=function(position,from,point,skipUpdate){if(from){position=from.toGlobal(position,point,skipUpdate);}if(!skipUpdate){this._recursivePostUpdateTransform();// this parent check is for just in case the item is a root object.\n// If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n// this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\nif(!this.parent){this.parent=this._tempDisplayObjectParent;this.displayObjectUpdateTransform();this.parent=null;}else{this.displayObjectUpdateTransform();}}// simply apply the matrix..\nreturn this.worldTransform.applyInverse(position,point);};/**\n     * Set the parent Container of this DisplayObject.\n     *\n     * @param container - The Container to add this DisplayObject to.\n     * @return - The Container that this DisplayObject was added to.\n     */DisplayObject.prototype.setParent=function(container){if(!container||!container.addChild){throw new Error('setParent: Argument must be a Container');}container.addChild(this);return container;};/**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     *\n     * @param x - The X position\n     * @param y - The Y position\n     * @param scaleX - The X scale value\n     * @param scaleY - The Y scale value\n     * @param rotation - The rotation\n     * @param skewX - The X skew value\n     * @param skewY - The Y skew value\n     * @param pivotX - The X pivot value\n     * @param pivotY - The Y pivot value\n     * @return - The DisplayObject instance\n     */DisplayObject.prototype.setTransform=function(x,y,scaleX,scaleY,rotation,skewX,skewY,pivotX,pivotY){if(x===void 0){x=0;}if(y===void 0){y=0;}if(scaleX===void 0){scaleX=1;}if(scaleY===void 0){scaleY=1;}if(rotation===void 0){rotation=0;}if(skewX===void 0){skewX=0;}if(skewY===void 0){skewY=0;}if(pivotX===void 0){pivotX=0;}if(pivotY===void 0){pivotY=0;}this.position.x=x;this.position.y=y;this.scale.x=!scaleX?1:scaleX;this.scale.y=!scaleY?1:scaleY;this.rotation=rotation;this.skew.x=skewX;this.skew.y=skewY;this.pivot.x=pivotX;this.pivot.y=pivotY;return this;};/**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy()`.\n     */DisplayObject.prototype.destroy=function(_options){if(this.parent){this.parent.removeChild(this);}this.emit('destroyed');this.removeAllListeners();this.transform=null;this.parent=null;this._bounds=null;this.mask=null;this.cullArea=null;this.filters=null;this.filterArea=null;this.hitArea=null;this.interactive=false;this.interactiveChildren=false;this._destroyed=true;};Object.defineProperty(DisplayObject.prototype,\"_tempDisplayObjectParent\",{/**\n         * @protected\n         * @member {PIXI.Container}\n         */get:function get(){if(this.tempDisplayObjectParent===null){// eslint-disable-next-line @typescript-eslint/no-use-before-define\nthis.tempDisplayObjectParent=new TemporaryDisplayObject();}return this.tempDisplayObjectParent;},enumerable:false,configurable:true});/**\n     * Used in Renderer, cacheAsBitmap and other places where you call an `updateTransform` on root\n     *\n     * ```\n     * const cacheParent = elem.enableTempParent();\n     * elem.updateTransform();\n     * elem.disableTempParent(cacheParent);\n     * ```\n     *\n     * @returns - current parent\n     */DisplayObject.prototype.enableTempParent=function(){var myParent=this.parent;this.parent=this._tempDisplayObjectParent;return myParent;};/**\n     * Pair method for `enableTempParent`\n     *\n     * @param cacheParent - Actual parent of element\n     */DisplayObject.prototype.disableTempParent=function(cacheParent){this.parent=cacheParent;};Object.defineProperty(DisplayObject.prototype,\"x\",{/**\n         * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n         * An alias to position.x\n         */get:function get(){return this.position.x;},set:function set(value){this.transform.position.x=value;},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"y\",{/**\n         * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n         * An alias to position.y\n         */get:function get(){return this.position.y;},set:function set(value){this.transform.position.y=value;},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"worldTransform\",{/**\n         * Current transform of the object based on world (parent) factors.\n         *\n         * @readonly\n         */get:function get(){return this.transform.worldTransform;},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"localTransform\",{/**\n         * Current transform of the object based on local factors: position, scale, other stuff.\n         *\n         * @readonly\n         */get:function get(){return this.transform.localTransform;},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"position\",{/**\n         * The coordinate of the object relative to the local coordinates of the parent.\n         *\n         * @since PixiJS 4\n         */get:function get(){return this.transform.position;},set:function set(value){this.transform.position.copyFrom(value);},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"scale\",{/**\n         * The scale factors of this object along the local coordinate axes.\n         *\n         * The default scale is (1, 1).\n         *\n         * @since PixiJS 4\n         */get:function get(){return this.transform.scale;},set:function set(value){this.transform.scale.copyFrom(value);},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"pivot\",{/**\n         * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n         * is the projection of `pivot` in the parent's local space.\n         *\n         * By default, the pivot is the origin (0, 0).\n         *\n         * @since PixiJS 4\n         */get:function get(){return this.transform.pivot;},set:function set(value){this.transform.pivot.copyFrom(value);},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"skew\",{/**\n         * The skew factor for the object in radians.\n         *\n         * @since PixiJS 4\n         */get:function get(){return this.transform.skew;},set:function set(value){this.transform.skew.copyFrom(value);},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"rotation\",{/**\n         * The rotation of the object in radians.\n         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n         */get:function get(){return this.transform.rotation;},set:function set(value){this.transform.rotation=value;},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"angle\",{/**\n         * The angle of the object in degrees.\n         * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n         */get:function get(){return this.transform.rotation*RAD_TO_DEG;},set:function set(value){this.transform.rotation=value*DEG_TO_RAD;},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"zIndex\",{/**\n         * The zIndex of the displayObject.\n         *\n         * If a container has the sortableChildren property set to true, children will be automatically\n         * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n         * and thus rendered on top of other display objects within the same container.\n         *\n         * @see PIXI.Container#sortableChildren\n         */get:function get(){return this._zIndex;},set:function set(value){this._zIndex=value;if(this.parent){this.parent.sortDirty=true;}},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"worldVisible\",{/**\n         * Indicates if the object is globally visible.\n         *\n         * @readonly\n         */get:function get(){var item=this;do{if(!item.visible){return false;}item=item.parent;}while(item);return true;},enumerable:false,configurable:true});Object.defineProperty(DisplayObject.prototype,\"mask\",{/**\n         * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n         * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n         * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n         * utilities shape clipping. To remove a mask, set this property to `null`.\n         *\n         * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n         *\n         * @example\n         * const graphics = new PIXI.Graphics();\n         * graphics.beginFill(0xFF3300);\n         * graphics.drawRect(50, 250, 100, 100);\n         * graphics.endFill();\n         *\n         * const sprite = new PIXI.Sprite(texture);\n         * sprite.mask = graphics;\n         *\n         * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n         */get:function get(){return this._mask;},set:function set(value){if(this._mask===value){return;}if(this._mask){var maskObject=this._mask.maskObject||this._mask;maskObject._maskRefCount--;if(maskObject._maskRefCount===0){maskObject.renderable=true;maskObject.isMask=false;}}this._mask=value;if(this._mask){var maskObject=this._mask.maskObject||this._mask;if(maskObject._maskRefCount===0){maskObject.renderable=false;maskObject.isMask=true;}maskObject._maskRefCount++;}},enumerable:false,configurable:true});return DisplayObject;}(EventEmitter);/**\n * @private\n */var TemporaryDisplayObject=/** @class */function(_super){__extends(TemporaryDisplayObject,_super);function TemporaryDisplayObject(){var _this=_super!==null&&_super.apply(this,arguments)||this;_this.sortDirty=null;return _this;}return TemporaryDisplayObject;}(DisplayObject);/**\n * DisplayObject default updateTransform, does not update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.DisplayObject#\n * @method displayObjectUpdateTransform\n */DisplayObject.prototype.displayObjectUpdateTransform=DisplayObject.prototype.updateTransform;/*!\n * @pixi/constants - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */ /**\n * Different types of environments for WebGL.\n *\n * @static\n * @memberof PIXI\n * @name ENV\n * @enum {number}\n * @property {number} WEBGL_LEGACY - Used for older v1 WebGL devices. PixiJS will aim to ensure compatibility\n *  with older / less advanced devices. If you experience unexplained flickering prefer this environment.\n * @property {number} WEBGL - Version 1 of WebGL\n * @property {number} WEBGL2 - Version 2 of WebGL\n */var ENV;(function(ENV){ENV[ENV[\"WEBGL_LEGACY\"]=0]=\"WEBGL_LEGACY\";ENV[ENV[\"WEBGL\"]=1]=\"WEBGL\";ENV[ENV[\"WEBGL2\"]=2]=\"WEBGL2\";})(ENV||(ENV={}));/**\n * Constant to identify the Renderer Type.\n *\n * @static\n * @memberof PIXI\n * @name RENDERER_TYPE\n * @enum {number}\n * @property {number} UNKNOWN - Unknown render type.\n * @property {number} WEBGL - WebGL render type.\n * @property {number} CANVAS - Canvas render type.\n */var RENDERER_TYPE;(function(RENDERER_TYPE){RENDERER_TYPE[RENDERER_TYPE[\"UNKNOWN\"]=0]=\"UNKNOWN\";RENDERER_TYPE[RENDERER_TYPE[\"WEBGL\"]=1]=\"WEBGL\";RENDERER_TYPE[RENDERER_TYPE[\"CANVAS\"]=2]=\"CANVAS\";})(RENDERER_TYPE||(RENDERER_TYPE={}));/**\n * Bitwise OR of masks that indicate the buffers to be cleared.\n *\n * @static\n * @memberof PIXI\n * @name BUFFER_BITS\n * @enum {number}\n * @property {number} COLOR - Indicates the buffers currently enabled for color writing.\n * @property {number} DEPTH - Indicates the depth buffer.\n * @property {number} STENCIL - Indicates the stencil buffer.\n */var BUFFER_BITS;(function(BUFFER_BITS){BUFFER_BITS[BUFFER_BITS[\"COLOR\"]=16384]=\"COLOR\";BUFFER_BITS[BUFFER_BITS[\"DEPTH\"]=256]=\"DEPTH\";BUFFER_BITS[BUFFER_BITS[\"STENCIL\"]=1024]=\"STENCIL\";})(BUFFER_BITS||(BUFFER_BITS={}));/**\n * Various blend modes supported by PIXI.\n *\n * IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.\n * Anything else will silently act like NORMAL.\n *\n * @memberof PIXI\n * @name BLEND_MODES\n * @enum {number}\n * @property {number} NORMAL\n * @property {number} ADD\n * @property {number} MULTIPLY\n * @property {number} SCREEN\n * @property {number} OVERLAY\n * @property {number} DARKEN\n * @property {number} LIGHTEN\n * @property {number} COLOR_DODGE\n * @property {number} COLOR_BURN\n * @property {number} HARD_LIGHT\n * @property {number} SOFT_LIGHT\n * @property {number} DIFFERENCE\n * @property {number} EXCLUSION\n * @property {number} HUE\n * @property {number} SATURATION\n * @property {number} COLOR\n * @property {number} LUMINOSITY\n * @property {number} NORMAL_NPM\n * @property {number} ADD_NPM\n * @property {number} SCREEN_NPM\n * @property {number} NONE\n * @property {number} SRC_IN\n * @property {number} SRC_OUT\n * @property {number} SRC_ATOP\n * @property {number} DST_OVER\n * @property {number} DST_IN\n * @property {number} DST_OUT\n * @property {number} DST_ATOP\n * @property {number} SUBTRACT\n * @property {number} SRC_OVER\n * @property {number} ERASE\n * @property {number} XOR\n */var BLEND_MODES;(function(BLEND_MODES){BLEND_MODES[BLEND_MODES[\"NORMAL\"]=0]=\"NORMAL\";BLEND_MODES[BLEND_MODES[\"ADD\"]=1]=\"ADD\";BLEND_MODES[BLEND_MODES[\"MULTIPLY\"]=2]=\"MULTIPLY\";BLEND_MODES[BLEND_MODES[\"SCREEN\"]=3]=\"SCREEN\";BLEND_MODES[BLEND_MODES[\"OVERLAY\"]=4]=\"OVERLAY\";BLEND_MODES[BLEND_MODES[\"DARKEN\"]=5]=\"DARKEN\";BLEND_MODES[BLEND_MODES[\"LIGHTEN\"]=6]=\"LIGHTEN\";BLEND_MODES[BLEND_MODES[\"COLOR_DODGE\"]=7]=\"COLOR_DODGE\";BLEND_MODES[BLEND_MODES[\"COLOR_BURN\"]=8]=\"COLOR_BURN\";BLEND_MODES[BLEND_MODES[\"HARD_LIGHT\"]=9]=\"HARD_LIGHT\";BLEND_MODES[BLEND_MODES[\"SOFT_LIGHT\"]=10]=\"SOFT_LIGHT\";BLEND_MODES[BLEND_MODES[\"DIFFERENCE\"]=11]=\"DIFFERENCE\";BLEND_MODES[BLEND_MODES[\"EXCLUSION\"]=12]=\"EXCLUSION\";BLEND_MODES[BLEND_MODES[\"HUE\"]=13]=\"HUE\";BLEND_MODES[BLEND_MODES[\"SATURATION\"]=14]=\"SATURATION\";BLEND_MODES[BLEND_MODES[\"COLOR\"]=15]=\"COLOR\";BLEND_MODES[BLEND_MODES[\"LUMINOSITY\"]=16]=\"LUMINOSITY\";BLEND_MODES[BLEND_MODES[\"NORMAL_NPM\"]=17]=\"NORMAL_NPM\";BLEND_MODES[BLEND_MODES[\"ADD_NPM\"]=18]=\"ADD_NPM\";BLEND_MODES[BLEND_MODES[\"SCREEN_NPM\"]=19]=\"SCREEN_NPM\";BLEND_MODES[BLEND_MODES[\"NONE\"]=20]=\"NONE\";BLEND_MODES[BLEND_MODES[\"SRC_OVER\"]=0]=\"SRC_OVER\";BLEND_MODES[BLEND_MODES[\"SRC_IN\"]=21]=\"SRC_IN\";BLEND_MODES[BLEND_MODES[\"SRC_OUT\"]=22]=\"SRC_OUT\";BLEND_MODES[BLEND_MODES[\"SRC_ATOP\"]=23]=\"SRC_ATOP\";BLEND_MODES[BLEND_MODES[\"DST_OVER\"]=24]=\"DST_OVER\";BLEND_MODES[BLEND_MODES[\"DST_IN\"]=25]=\"DST_IN\";BLEND_MODES[BLEND_MODES[\"DST_OUT\"]=26]=\"DST_OUT\";BLEND_MODES[BLEND_MODES[\"DST_ATOP\"]=27]=\"DST_ATOP\";BLEND_MODES[BLEND_MODES[\"ERASE\"]=26]=\"ERASE\";BLEND_MODES[BLEND_MODES[\"SUBTRACT\"]=28]=\"SUBTRACT\";BLEND_MODES[BLEND_MODES[\"XOR\"]=29]=\"XOR\";})(BLEND_MODES||(BLEND_MODES={}));/**\n * Various webgl draw modes. These can be used to specify which GL drawMode to use\n * under certain situations and renderers.\n *\n * @memberof PIXI\n * @static\n * @name DRAW_MODES\n * @enum {number}\n * @property {number} POINTS\n * @property {number} LINES\n * @property {number} LINE_LOOP\n * @property {number} LINE_STRIP\n * @property {number} TRIANGLES\n * @property {number} TRIANGLE_STRIP\n * @property {number} TRIANGLE_FAN\n */var DRAW_MODES;(function(DRAW_MODES){DRAW_MODES[DRAW_MODES[\"POINTS\"]=0]=\"POINTS\";DRAW_MODES[DRAW_MODES[\"LINES\"]=1]=\"LINES\";DRAW_MODES[DRAW_MODES[\"LINE_LOOP\"]=2]=\"LINE_LOOP\";DRAW_MODES[DRAW_MODES[\"LINE_STRIP\"]=3]=\"LINE_STRIP\";DRAW_MODES[DRAW_MODES[\"TRIANGLES\"]=4]=\"TRIANGLES\";DRAW_MODES[DRAW_MODES[\"TRIANGLE_STRIP\"]=5]=\"TRIANGLE_STRIP\";DRAW_MODES[DRAW_MODES[\"TRIANGLE_FAN\"]=6]=\"TRIANGLE_FAN\";})(DRAW_MODES||(DRAW_MODES={}));/**\n * Various GL texture/resources formats.\n *\n * @memberof PIXI\n * @static\n * @name FORMATS\n * @enum {number}\n * @property {number} RGBA=6408\n * @property {number} RGB=6407\n * @property {number} RG=33319\n * @property {number} RED=6403\n * @property {number} RGBA_INTEGER=36249\n * @property {number} RGB_INTEGER=36248\n * @property {number} RG_INTEGER=33320\n * @property {number} RED_INTEGER=36244\n * @property {number} ALPHA=6406\n * @property {number} LUMINANCE=6409\n * @property {number} LUMINANCE_ALPHA=6410\n * @property {number} DEPTH_COMPONENT=6402\n * @property {number} DEPTH_STENCIL=34041\n */var FORMATS;(function(FORMATS){FORMATS[FORMATS[\"RGBA\"]=6408]=\"RGBA\";FORMATS[FORMATS[\"RGB\"]=6407]=\"RGB\";FORMATS[FORMATS[\"RG\"]=33319]=\"RG\";FORMATS[FORMATS[\"RED\"]=6403]=\"RED\";FORMATS[FORMATS[\"RGBA_INTEGER\"]=36249]=\"RGBA_INTEGER\";FORMATS[FORMATS[\"RGB_INTEGER\"]=36248]=\"RGB_INTEGER\";FORMATS[FORMATS[\"RG_INTEGER\"]=33320]=\"RG_INTEGER\";FORMATS[FORMATS[\"RED_INTEGER\"]=36244]=\"RED_INTEGER\";FORMATS[FORMATS[\"ALPHA\"]=6406]=\"ALPHA\";FORMATS[FORMATS[\"LUMINANCE\"]=6409]=\"LUMINANCE\";FORMATS[FORMATS[\"LUMINANCE_ALPHA\"]=6410]=\"LUMINANCE_ALPHA\";FORMATS[FORMATS[\"DEPTH_COMPONENT\"]=6402]=\"DEPTH_COMPONENT\";FORMATS[FORMATS[\"DEPTH_STENCIL\"]=34041]=\"DEPTH_STENCIL\";})(FORMATS||(FORMATS={}));/**\n * Various GL target types.\n *\n * @memberof PIXI\n * @static\n * @name TARGETS\n * @enum {number}\n * @property {number} TEXTURE_2D=3553\n * @property {number} TEXTURE_CUBE_MAP=34067\n * @property {number} TEXTURE_2D_ARRAY=35866\n * @property {number} TEXTURE_CUBE_MAP_POSITIVE_X=34069\n * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_X=34070\n * @property {number} TEXTURE_CUBE_MAP_POSITIVE_Y=34071\n * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_Y=34072\n * @property {number} TEXTURE_CUBE_MAP_POSITIVE_Z=34073\n * @property {number} TEXTURE_CUBE_MAP_NEGATIVE_Z=34074\n */var TARGETS;(function(TARGETS){TARGETS[TARGETS[\"TEXTURE_2D\"]=3553]=\"TEXTURE_2D\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP\"]=34067]=\"TEXTURE_CUBE_MAP\";TARGETS[TARGETS[\"TEXTURE_2D_ARRAY\"]=35866]=\"TEXTURE_2D_ARRAY\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_POSITIVE_X\"]=34069]=\"TEXTURE_CUBE_MAP_POSITIVE_X\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_NEGATIVE_X\"]=34070]=\"TEXTURE_CUBE_MAP_NEGATIVE_X\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_POSITIVE_Y\"]=34071]=\"TEXTURE_CUBE_MAP_POSITIVE_Y\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_NEGATIVE_Y\"]=34072]=\"TEXTURE_CUBE_MAP_NEGATIVE_Y\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_POSITIVE_Z\"]=34073]=\"TEXTURE_CUBE_MAP_POSITIVE_Z\";TARGETS[TARGETS[\"TEXTURE_CUBE_MAP_NEGATIVE_Z\"]=34074]=\"TEXTURE_CUBE_MAP_NEGATIVE_Z\";})(TARGETS||(TARGETS={}));/**\n * Various GL data format types.\n *\n * @memberof PIXI\n * @static\n * @name TYPES\n * @enum {number}\n * @property {number} UNSIGNED_BYTE=5121\n * @property {number} UNSIGNED_SHORT=5123\n * @property {number} UNSIGNED_SHORT_5_6_5=33635\n * @property {number} UNSIGNED_SHORT_4_4_4_4=32819\n * @property {number} UNSIGNED_SHORT_5_5_5_1=32820\n * @property {number} UNSIGNED_INT=5125\n * @property {number} UNSIGNED_INT_10F_11F_11F_REV=35899\n * @property {number} UNSIGNED_INT_2_10_10_10_REV=33640\n * @property {number} UNSIGNED_INT_24_8=34042\n * @property {number} UNSIGNED_INT_5_9_9_9_REV=35902\n * @property {number} BYTE=5120\n * @property {number} SHORT=5122\n * @property {number} INT=5124\n * @property {number} FLOAT=5126\n * @property {number} FLOAT_32_UNSIGNED_INT_24_8_REV=36269\n * @property {number} HALF_FLOAT=36193\n */var TYPES;(function(TYPES){TYPES[TYPES[\"UNSIGNED_BYTE\"]=5121]=\"UNSIGNED_BYTE\";TYPES[TYPES[\"UNSIGNED_SHORT\"]=5123]=\"UNSIGNED_SHORT\";TYPES[TYPES[\"UNSIGNED_SHORT_5_6_5\"]=33635]=\"UNSIGNED_SHORT_5_6_5\";TYPES[TYPES[\"UNSIGNED_SHORT_4_4_4_4\"]=32819]=\"UNSIGNED_SHORT_4_4_4_4\";TYPES[TYPES[\"UNSIGNED_SHORT_5_5_5_1\"]=32820]=\"UNSIGNED_SHORT_5_5_5_1\";TYPES[TYPES[\"UNSIGNED_INT\"]=5125]=\"UNSIGNED_INT\";TYPES[TYPES[\"UNSIGNED_INT_10F_11F_11F_REV\"]=35899]=\"UNSIGNED_INT_10F_11F_11F_REV\";TYPES[TYPES[\"UNSIGNED_INT_2_10_10_10_REV\"]=33640]=\"UNSIGNED_INT_2_10_10_10_REV\";TYPES[TYPES[\"UNSIGNED_INT_24_8\"]=34042]=\"UNSIGNED_INT_24_8\";TYPES[TYPES[\"UNSIGNED_INT_5_9_9_9_REV\"]=35902]=\"UNSIGNED_INT_5_9_9_9_REV\";TYPES[TYPES[\"BYTE\"]=5120]=\"BYTE\";TYPES[TYPES[\"SHORT\"]=5122]=\"SHORT\";TYPES[TYPES[\"INT\"]=5124]=\"INT\";TYPES[TYPES[\"FLOAT\"]=5126]=\"FLOAT\";TYPES[TYPES[\"FLOAT_32_UNSIGNED_INT_24_8_REV\"]=36269]=\"FLOAT_32_UNSIGNED_INT_24_8_REV\";TYPES[TYPES[\"HALF_FLOAT\"]=36193]=\"HALF_FLOAT\";})(TYPES||(TYPES={}));/**\n * Various sampler types. Correspond to `sampler`, `isampler`, `usampler` GLSL types respectively.\n * WebGL1 works only with FLOAT.\n *\n * @memberof PIXI\n * @static\n * @name SAMPLER_TYPES\n * @enum {number}\n * @property {number} FLOAT=0\n * @property {number} INT=1\n * @property {number} UINT=2\n */var SAMPLER_TYPES;(function(SAMPLER_TYPES){SAMPLER_TYPES[SAMPLER_TYPES[\"FLOAT\"]=0]=\"FLOAT\";SAMPLER_TYPES[SAMPLER_TYPES[\"INT\"]=1]=\"INT\";SAMPLER_TYPES[SAMPLER_TYPES[\"UINT\"]=2]=\"UINT\";})(SAMPLER_TYPES||(SAMPLER_TYPES={}));/**\n * The scale modes that are supported by pixi.\n *\n * The {@link PIXI.settings.SCALE_MODE} scale mode affects the default scaling mode of future operations.\n * It can be re-assigned to either LINEAR or NEAREST, depending upon suitability.\n *\n * @memberof PIXI\n * @static\n * @name SCALE_MODES\n * @enum {number}\n * @property {number} LINEAR Smooth scaling\n * @property {number} NEAREST Pixelating scaling\n */var SCALE_MODES;(function(SCALE_MODES){SCALE_MODES[SCALE_MODES[\"NEAREST\"]=0]=\"NEAREST\";SCALE_MODES[SCALE_MODES[\"LINEAR\"]=1]=\"LINEAR\";})(SCALE_MODES||(SCALE_MODES={}));/**\n * The wrap modes that are supported by pixi.\n *\n * The {@link PIXI.settings.WRAP_MODE} wrap mode affects the default wrapping mode of future operations.\n * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.\n * If the texture is non power of two then clamp will be used regardless as WebGL can\n * only use REPEAT if the texture is po2.\n *\n * This property only affects WebGL.\n *\n * @name WRAP_MODES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} CLAMP - The textures uvs are clamped\n * @property {number} REPEAT - The texture uvs tile and repeat\n * @property {number} MIRRORED_REPEAT - The texture uvs tile and repeat with mirroring\n */var WRAP_MODES;(function(WRAP_MODES){WRAP_MODES[WRAP_MODES[\"CLAMP\"]=33071]=\"CLAMP\";WRAP_MODES[WRAP_MODES[\"REPEAT\"]=10497]=\"REPEAT\";WRAP_MODES[WRAP_MODES[\"MIRRORED_REPEAT\"]=33648]=\"MIRRORED_REPEAT\";})(WRAP_MODES||(WRAP_MODES={}));/**\n * Mipmap filtering modes that are supported by pixi.\n *\n * The {@link PIXI.settings.MIPMAP_TEXTURES} affects default texture filtering.\n * Mipmaps are generated for a baseTexture if its `mipmap` field is `ON`,\n * or its `POW2` and texture dimensions are powers of 2.\n * Due to platform restriction, `ON` option will work like `POW2` for webgl-1.\n *\n * This property only affects WebGL.\n *\n * @name MIPMAP_MODES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} OFF - No mipmaps\n * @property {number} POW2 - Generate mipmaps if texture dimensions are pow2\n * @property {number} ON - Always generate mipmaps\n * @property {number} ON_MANUAL - Use mipmaps, but do not auto-generate them; this is used with a resource\n *   that supports buffering each level-of-detail.\n */var MIPMAP_MODES;(function(MIPMAP_MODES){MIPMAP_MODES[MIPMAP_MODES[\"OFF\"]=0]=\"OFF\";MIPMAP_MODES[MIPMAP_MODES[\"POW2\"]=1]=\"POW2\";MIPMAP_MODES[MIPMAP_MODES[\"ON\"]=2]=\"ON\";MIPMAP_MODES[MIPMAP_MODES[\"ON_MANUAL\"]=3]=\"ON_MANUAL\";})(MIPMAP_MODES||(MIPMAP_MODES={}));/**\n * How to treat textures with premultiplied alpha\n *\n * @name ALPHA_MODES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} NO_PREMULTIPLIED_ALPHA - Source is not premultiplied, leave it like that.\n *  Option for compressed and data textures that are created from typed arrays.\n * @property {number} PREMULTIPLY_ON_UPLOAD - Source is not premultiplied, premultiply on upload.\n *  Default option, used for all loaded images.\n * @property {number} PREMULTIPLIED_ALPHA - Source is already premultiplied\n *  Example: spine atlases with `_pma` suffix.\n * @property {number} NPM - Alias for NO_PREMULTIPLIED_ALPHA.\n * @property {number} UNPACK - Default option, alias for PREMULTIPLY_ON_UPLOAD.\n * @property {number} PMA - Alias for PREMULTIPLIED_ALPHA.\n */var ALPHA_MODES;(function(ALPHA_MODES){ALPHA_MODES[ALPHA_MODES[\"NPM\"]=0]=\"NPM\";ALPHA_MODES[ALPHA_MODES[\"UNPACK\"]=1]=\"UNPACK\";ALPHA_MODES[ALPHA_MODES[\"PMA\"]=2]=\"PMA\";ALPHA_MODES[ALPHA_MODES[\"NO_PREMULTIPLIED_ALPHA\"]=0]=\"NO_PREMULTIPLIED_ALPHA\";ALPHA_MODES[ALPHA_MODES[\"PREMULTIPLY_ON_UPLOAD\"]=1]=\"PREMULTIPLY_ON_UPLOAD\";ALPHA_MODES[ALPHA_MODES[\"PREMULTIPLY_ALPHA\"]=2]=\"PREMULTIPLY_ALPHA\";ALPHA_MODES[ALPHA_MODES[\"PREMULTIPLIED_ALPHA\"]=2]=\"PREMULTIPLIED_ALPHA\";})(ALPHA_MODES||(ALPHA_MODES={}));/**\n * Configure whether filter textures are cleared after binding.\n *\n * Filter textures need not be cleared if the filter does not use pixel blending. {@link CLEAR_MODES.BLIT} will detect\n * this and skip clearing as an optimization.\n *\n * @name CLEAR_MODES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} BLEND - Do not clear the filter texture. The filter's output will blend on top of the output texture.\n * @property {number} CLEAR - Always clear the filter texture.\n * @property {number} BLIT - Clear only if {@link FilterSystem.forceClear} is set or if the filter uses pixel blending.\n * @property {number} NO - Alias for BLEND, same as `false` in earlier versions\n * @property {number} YES - Alias for CLEAR, same as `true` in earlier versions\n * @property {number} AUTO - Alias for BLIT\n */var CLEAR_MODES;(function(CLEAR_MODES){CLEAR_MODES[CLEAR_MODES[\"NO\"]=0]=\"NO\";CLEAR_MODES[CLEAR_MODES[\"YES\"]=1]=\"YES\";CLEAR_MODES[CLEAR_MODES[\"AUTO\"]=2]=\"AUTO\";CLEAR_MODES[CLEAR_MODES[\"BLEND\"]=0]=\"BLEND\";CLEAR_MODES[CLEAR_MODES[\"CLEAR\"]=1]=\"CLEAR\";CLEAR_MODES[CLEAR_MODES[\"BLIT\"]=2]=\"BLIT\";})(CLEAR_MODES||(CLEAR_MODES={}));/**\n * The gc modes that are supported by pixi.\n *\n * The {@link PIXI.settings.GC_MODE} Garbage Collection mode for PixiJS textures is AUTO\n * If set to GC_MODE, the renderer will occasionally check textures usage. If they are not\n * used for a specified period of time they will be removed from the GPU. They will of course\n * be uploaded again when they are required. This is a silent behind the scenes process that\n * should ensure that the GPU does not  get filled up.\n *\n * Handy for mobile devices!\n * This property only affects WebGL.\n *\n * @name GC_MODES\n * @enum {number}\n * @static\n * @memberof PIXI\n * @property {number} AUTO - Garbage collection will happen periodically automatically\n * @property {number} MANUAL - Garbage collection will need to be called manually\n */var GC_MODES;(function(GC_MODES){GC_MODES[GC_MODES[\"AUTO\"]=0]=\"AUTO\";GC_MODES[GC_MODES[\"MANUAL\"]=1]=\"MANUAL\";})(GC_MODES||(GC_MODES={}));/**\n * Constants that specify float precision in shaders.\n *\n * @name PRECISION\n * @memberof PIXI\n * @constant\n * @static\n * @enum {string}\n * @property {string} LOW='lowp'\n * @property {string} MEDIUM='mediump'\n * @property {string} HIGH='highp'\n */var PRECISION;(function(PRECISION){PRECISION[\"LOW\"]=\"lowp\";PRECISION[\"MEDIUM\"]=\"mediump\";PRECISION[\"HIGH\"]=\"highp\";})(PRECISION||(PRECISION={}));/**\n * Constants for mask implementations.\n * We use `type` suffix because it leads to very different behaviours\n *\n * @name MASK_TYPES\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} NONE - Mask is ignored\n * @property {number} SCISSOR - Scissor mask, rectangle on screen, cheap\n * @property {number} STENCIL - Stencil mask, 1-bit, medium, works only if renderer supports stencil\n * @property {number} SPRITE - Mask that uses SpriteMaskFilter, uses temporary RenderTexture\n */var MASK_TYPES;(function(MASK_TYPES){MASK_TYPES[MASK_TYPES[\"NONE\"]=0]=\"NONE\";MASK_TYPES[MASK_TYPES[\"SCISSOR\"]=1]=\"SCISSOR\";MASK_TYPES[MASK_TYPES[\"STENCIL\"]=2]=\"STENCIL\";MASK_TYPES[MASK_TYPES[\"SPRITE\"]=3]=\"SPRITE\";})(MASK_TYPES||(MASK_TYPES={}));/**\n * Constants for multi-sampling antialiasing.\n *\n * @see PIXI.Framebuffer#multisample\n *\n * @name MSAA_QUALITY\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} NONE - No multisampling for this renderTexture\n * @property {number} LOW - Try 2 samples\n * @property {number} MEDIUM - Try 4 samples\n * @property {number} HIGH - Try 8 samples\n */var MSAA_QUALITY;(function(MSAA_QUALITY){MSAA_QUALITY[MSAA_QUALITY[\"NONE\"]=0]=\"NONE\";MSAA_QUALITY[MSAA_QUALITY[\"LOW\"]=2]=\"LOW\";MSAA_QUALITY[MSAA_QUALITY[\"MEDIUM\"]=4]=\"MEDIUM\";MSAA_QUALITY[MSAA_QUALITY[\"HIGH\"]=8]=\"HIGH\";})(MSAA_QUALITY||(MSAA_QUALITY={}));/**\n * Constants for various buffer types in Pixi\n *\n * @see PIXI.BUFFER_TYPE\n *\n * @name BUFFER_TYPE\n * @memberof PIXI\n * @static\n * @enum {number}\n * @property {number} ELEMENT_ARRAY_BUFFER - buffer type for using as an index buffer\n * @property {number} ARRAY_BUFFER - buffer type for using attribute data\n * @property {number} UNIFORM_BUFFER - the buffer type is for uniform buffer objects\n */var BUFFER_TYPE;(function(BUFFER_TYPE){BUFFER_TYPE[BUFFER_TYPE[\"ELEMENT_ARRAY_BUFFER\"]=34963]=\"ELEMENT_ARRAY_BUFFER\";BUFFER_TYPE[BUFFER_TYPE[\"ARRAY_BUFFER\"]=34962]=\"ARRAY_BUFFER\";// NOT YET SUPPORTED\nBUFFER_TYPE[BUFFER_TYPE[\"UNIFORM_BUFFER\"]=35345]=\"UNIFORM_BUFFER\";})(BUFFER_TYPE||(BUFFER_TYPE={}));function sortChildren(a,b){if(a.zIndex===b.zIndex){return a._lastSortedIndex-b._lastSortedIndex;}return a.zIndex-b.zIndex;}/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * ```js\n * import { BlurFilter } from '@pixi/filter-blur';\n * import { Container } from '@pixi/display';\n * import { Graphics } from '@pixi/graphics';\n * import { Sprite } from '@pixi/sprite';\n *\n * let container = new Container();\n * let sprite = Sprite.from(\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png\");\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *  .beginFill(0xffffff)\n *  .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *  .endFill();\n * ```\n *\n * @memberof PIXI\n */var Container=/** @class */function(_super){__extends(Container,_super);function Container(){var _this=_super.call(this)||this;_this.children=[];_this.sortableChildren=settings.SORTABLE_CHILDREN;_this.sortDirty=false;return _this;/**\n         * Fired when a DisplayObject is added to this Container.\n         *\n         * @event PIXI.Container#childAdded\n         * @param {PIXI.DisplayObject} child - The child added to the Container.\n         * @param {PIXI.Container} container - The container that added the child.\n         * @param {number} index - The children's index of the added child.\n         */ /**\n         * Fired when a DisplayObject is removed from this Container.\n         *\n         * @event PIXI.DisplayObject#removedFrom\n         * @param {PIXI.DisplayObject} child - The child removed from the Container.\n         * @param {PIXI.Container} container - The container that removed removed the child.\n         * @param {number} index - The former children's index of the removed child\n         */}/** Overridable method that can be used by Container subclasses whenever the children array is modified. */Container.prototype.onChildrenChange=function(_length){/* empty */};/**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     *\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to add to the container\n     * @return {PIXI.DisplayObject} - The first child that was added.\n     */Container.prototype.addChild=function(){var arguments$1=arguments;var children=[];for(var _i=0;_i<arguments.length;_i++){children[_i]=arguments$1[_i];}// if there is only one argument we can bypass looping through the them\nif(children.length>1){// loop through the array and add all children\nfor(var i=0;i<children.length;i++){// eslint-disable-next-line prefer-rest-params\nthis.addChild(children[i]);}}else{var child=children[0];// if the child has a parent then lets remove it as PixiJS objects can only exist in one place\nif(child.parent){child.parent.removeChild(child);}child.parent=this;this.sortDirty=true;// ensure child transform will be recalculated\nchild.transform._parentID=-1;this.children.push(child);// ensure bounds will be recalculated\nthis._boundsID++;// TODO - lets either do all callbacks or all events.. not both!\nthis.onChildrenChange(this.children.length-1);this.emit('childAdded',child,this,this.children.length-1);child.emit('added',this);}return children[0];};/**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n     *\n     * @param {PIXI.DisplayObject} child - The child to add\n     * @param {number} index - The index to place the child in\n     * @return {PIXI.DisplayObject} The child that was added.\n     */Container.prototype.addChildAt=function(child,index){if(index<0||index>this.children.length){throw new Error(child+\"addChildAt: The index \"+index+\" supplied is out of bounds \"+this.children.length);}if(child.parent){child.parent.removeChild(child);}child.parent=this;this.sortDirty=true;// ensure child transform will be recalculated\nchild.transform._parentID=-1;this.children.splice(index,0,child);// ensure bounds will be recalculated\nthis._boundsID++;// TODO - lets either do all callbacks or all events.. not both!\nthis.onChildrenChange(index);child.emit('added',this);this.emit('childAdded',child,this,index);return child;};/**\n     * Swaps the position of 2 Display Objects within this container.\n     *\n     * @param child - First display object to swap\n     * @param child2 - Second display object to swap\n     */Container.prototype.swapChildren=function(child,child2){if(child===child2){return;}var index1=this.getChildIndex(child);var index2=this.getChildIndex(child2);this.children[index1]=child2;this.children[index2]=child;this.onChildrenChange(index1<index2?index1:index2);};/**\n     * Returns the index position of a child DisplayObject instance\n     *\n     * @param child - The DisplayObject instance to identify\n     * @return - The index position of the child display object to identify\n     */Container.prototype.getChildIndex=function(child){var index=this.children.indexOf(child);if(index===-1){throw new Error('The supplied DisplayObject must be a child of the caller');}return index;};/**\n     * Changes the position of an existing child in the display object container\n     *\n     * @param child - The child DisplayObject instance for which you want to change the index number\n     * @param index - The resulting index number for the child display object\n     */Container.prototype.setChildIndex=function(child,index){if(index<0||index>=this.children.length){throw new Error(\"The index \"+index+\" supplied is out of bounds \"+this.children.length);}var currentIndex=this.getChildIndex(child);removeItems(this.children,currentIndex,1);// remove from old position\nthis.children.splice(index,0,child);// add at new position\nthis.onChildrenChange(index);};/**\n     * Returns the child at the specified index\n     *\n     * @param index - The index to get the child at\n     * @return - The child at the given index, if any.\n     */Container.prototype.getChildAt=function(index){if(index<0||index>=this.children.length){throw new Error(\"getChildAt: Index (\"+index+\") does not exist.\");}return this.children[index];};/**\n     * Removes one or more children from the container.\n     *\n     * @param {...PIXI.DisplayObject} children - The DisplayObject(s) to remove\n     * @return {PIXI.DisplayObject} The first child that was removed.\n     */Container.prototype.removeChild=function(){var arguments$1=arguments;var children=[];for(var _i=0;_i<arguments.length;_i++){children[_i]=arguments$1[_i];}// if there is only one argument we can bypass looping through the them\nif(children.length>1){// loop through the arguments property and remove all children\nfor(var i=0;i<children.length;i++){this.removeChild(children[i]);}}else{var child=children[0];var index=this.children.indexOf(child);if(index===-1){return null;}child.parent=null;// ensure child transform will be recalculated\nchild.transform._parentID=-1;removeItems(this.children,index,1);// ensure bounds will be recalculated\nthis._boundsID++;// TODO - lets either do all callbacks or all events.. not both!\nthis.onChildrenChange(index);child.emit('removed',this);this.emit('childRemoved',child,this,index);}return children[0];};/**\n     * Removes a child from the specified index position.\n     *\n     * @param index - The index to get the child from\n     * @return The child that was removed.\n     */Container.prototype.removeChildAt=function(index){var child=this.getChildAt(index);// ensure child transform will be recalculated..\nchild.parent=null;child.transform._parentID=-1;removeItems(this.children,index,1);// ensure bounds will be recalculated\nthis._boundsID++;// TODO - lets either do all callbacks or all events.. not both!\nthis.onChildrenChange(index);child.emit('removed',this);this.emit('childRemoved',child,this,index);return child;};/**\n     * Removes all children from this container that are within the begin and end indexes.\n     *\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed children\n     */Container.prototype.removeChildren=function(beginIndex,endIndex){if(beginIndex===void 0){beginIndex=0;}if(endIndex===void 0){endIndex=this.children.length;}var begin=beginIndex;var end=endIndex;var range=end-begin;var removed;if(range>0&&range<=end){removed=this.children.splice(begin,range);for(var i=0;i<removed.length;++i){removed[i].parent=null;if(removed[i].transform){removed[i].transform._parentID=-1;}}this._boundsID++;this.onChildrenChange(beginIndex);for(var i=0;i<removed.length;++i){removed[i].emit('removed',this);this.emit('childRemoved',removed[i],this,i);}return removed;}else if(range===0&&this.children.length===0){return[];}throw new RangeError('removeChildren: numeric values are outside the acceptable range.');};/** Sorts children by zIndex. Previous order is maintained for 2 children with the same zIndex. */Container.prototype.sortChildren=function(){var sortRequired=false;for(var i=0,j=this.children.length;i<j;++i){var child=this.children[i];child._lastSortedIndex=i;if(!sortRequired&&child.zIndex!==0){sortRequired=true;}}if(sortRequired&&this.children.length>1){this.children.sort(sortChildren);}this.sortDirty=false;};/** Updates the transform on all children of this container for rendering. */Container.prototype.updateTransform=function(){if(this.sortableChildren&&this.sortDirty){this.sortChildren();}this._boundsID++;this.transform.updateTransform(this.parent.transform);// TODO: check render flags, how to process stuff here\nthis.worldAlpha=this.alpha*this.parent.worldAlpha;for(var i=0,j=this.children.length;i<j;++i){var child=this.children[i];if(child.visible){child.updateTransform();}}};/**\n     * Recalculates the bounds of the container.\n     *\n     * This implementation will automatically fit the children's bounds into the calculation. Each child's bounds\n     * is limited to its mask's bounds or filterArea, if any is applied.\n     */Container.prototype.calculateBounds=function(){this._bounds.clear();this._calculateBounds();for(var i=0;i<this.children.length;i++){var child=this.children[i];if(!child.visible||!child.renderable){continue;}child.calculateBounds();// TODO: filter+mask, need to mask both somehow\nif(child._mask){var maskObject=child._mask.maskObject||child._mask;maskObject.calculateBounds();this._bounds.addBoundsMask(child._bounds,maskObject._bounds);}else if(child.filterArea){this._bounds.addBoundsArea(child._bounds,child.filterArea);}else{this._bounds.addBounds(child._bounds);}}this._bounds.updateID=this._boundsID;};/**\n     * Retrieves the local bounds of the displayObject as a rectangle object.\n     *\n     * Calling `getLocalBounds` may invalidate the `_bounds` of the whole subtree below. If using it inside a render()\n     * call, it is advised to call `getBounds()` immediately after to recalculate the world bounds of the subtree.\n     *\n     * @param rect - Optional rectangle to store the result of the bounds calculation.\n     * @param skipChildrenUpdate - Setting to `true` will stop re-calculation of children transforms,\n     *  it was default behaviour of pixi 4.0-5.2 and caused many problems to users.\n     * @return - The rectangular bounding area.\n     */Container.prototype.getLocalBounds=function(rect,skipChildrenUpdate){if(skipChildrenUpdate===void 0){skipChildrenUpdate=false;}var result=_super.prototype.getLocalBounds.call(this,rect);if(!skipChildrenUpdate){for(var i=0,j=this.children.length;i<j;++i){var child=this.children[i];if(child.visible){child.updateTransform();}}}return result;};/**\n     * Recalculates the content bounds of this object. This should be overriden to\n     * calculate the bounds of this specific object (not including children).\n     *\n     * @protected\n     */Container.prototype._calculateBounds=function(){// FILL IN//\n};/**\n     * Renders this object and its children with culling.\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */Container.prototype._renderWithCulling=function(renderer){var sourceFrame=renderer.renderTexture.sourceFrame;// If the source frame is empty, stop rendering.\nif(!(sourceFrame.width>0&&sourceFrame.height>0)){return;}// Render the content of the container only if its bounds intersect with the source frame.\n// All filters are on the stack at this point, and the filter source frame is bound:\n// therefore, even if the bounds to non intersect the filter frame, the filter\n// is still applied and any filter padding that is in the frame is rendered correctly.\nvar bounds;var transform;// If cullArea is set, we use this rectangle instead of the bounds of the object. The cullArea\n// rectangle must completely contain the container and its children including filter padding.\nif(this.cullArea){bounds=this.cullArea;transform=this.worldTransform;}// If the container doesn't override _render, we can skip the bounds calculation and intersection test.\nelse if(this._render!==Container.prototype._render){bounds=this.getBounds(true);}// Render the container if the source frame intersects the bounds.\nif(bounds&&sourceFrame.intersects(bounds,transform)){this._render(renderer);}// If the bounds are defined by cullArea and do not intersect with the source frame, stop rendering.\nelse if(this.cullArea){return;}// Unless cullArea is set, we cannot skip the children if the bounds of the container do not intersect\n// the source frame, because the children might have filters with nonzero padding, which may intersect\n// with the source frame while the bounds do not: filter padding is not included in the bounds.\n// If cullArea is not set, render the children with culling temporarily enabled so that they are not rendered\n// if they are out of frame; otherwise, render the children normally.\nfor(var i=0,j=this.children.length;i<j;++i){var child=this.children[i];var childCullable=child.cullable;child.cullable=childCullable||!this.cullArea;child.render(renderer);child.cullable=childCullable;}};/**\n     * Renders the object using the WebGL renderer.\n     *\n     * The [_render]{@link PIXI.Container#_render} method is be overriden for rendering the contents of the\n     * container itself. This `render` method will invoke it, and also invoke the `render` methods of all\n     * children afterward.\n     *\n     * If `renderable` or `visible` is false or if `worldAlpha` is not positive or if `cullable` is true and\n     * the bounds of this object are out of frame, this implementation will entirely skip rendering.\n     * See {@link PIXI.DisplayObject} for choosing between `renderable` or `visible`. Generally,\n     * setting alpha to zero is not recommended for purely skipping rendering.\n     *\n     * When your scene becomes large (especially when it is larger than can be viewed in a single screen), it is\n     * advised to employ **culling** to automatically skip rendering objects outside of the current screen.\n     * See [cullable]{@link PIXI.DisplayObject#cullable} and [cullArea]{@link PIXI.DisplayObject#cullArea}.\n     * Other culling methods might be better suited for a large number static objects; see\n     * [@pixi-essentials/cull]{@link https://www.npmjs.com/package/@pixi-essentials/cull} and\n     * [pixi-cull]{@link https://www.npmjs.com/package/pixi-cull}.\n     *\n     * The [renderAdvanced]{@link PIXI.Container#renderAdvanced} method is internally used when when masking or\n     * filtering is applied on a container. This does, however, break batching and can affect performance when\n     * masking and filtering is applied extensively throughout the scene graph.\n     *\n     * @param renderer - The renderer\n     */Container.prototype.render=function(renderer){// if the object is not visible or the alpha is 0 then no need to render this element\nif(!this.visible||this.worldAlpha<=0||!this.renderable){return;}// do a quick check to see if this element has a mask or a filter.\nif(this._mask||this.filters&&this.filters.length){this.renderAdvanced(renderer);}else if(this.cullable){this._renderWithCulling(renderer);}else{this._render(renderer);for(var i=0,j=this.children.length;i<j;++i){this.children[i].render(renderer);}}};/**\n     * Render the object using the WebGL renderer and advanced features.\n     *\n     * @param renderer - The renderer\n     */Container.prototype.renderAdvanced=function(renderer){var filters=this.filters;var mask=this._mask;// push filter first as we need to ensure the stencil buffer is correct for any masking\nif(filters){if(!this._enabledFilters){this._enabledFilters=[];}this._enabledFilters.length=0;for(var i=0;i<filters.length;i++){if(filters[i].enabled){this._enabledFilters.push(filters[i]);}}}var flush=filters&&this._enabledFilters&&this._enabledFilters.length||mask&&(!mask.isMaskData||mask.enabled&&(mask.autoDetect||mask.type!==MASK_TYPES.NONE));if(flush){renderer.batch.flush();}if(filters&&this._enabledFilters&&this._enabledFilters.length){renderer.filter.push(this,this._enabledFilters);}if(mask){renderer.mask.push(this,this._mask);}if(this.cullable){this._renderWithCulling(renderer);}else{this._render(renderer);for(var i=0,j=this.children.length;i<j;++i){this.children[i].render(renderer);}}if(flush){renderer.batch.flush();}if(mask){renderer.mask.pop(this);}if(filters&&this._enabledFilters&&this._enabledFilters.length){renderer.filter.pop();}};/**\n     * To be overridden by the subclasses.\n     *\n     * @param renderer - The renderer\n     */Container.prototype._render=function(_renderer){// this is where content itself gets rendered...\n};/**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     *\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */Container.prototype.destroy=function(options){_super.prototype.destroy.call(this);this.sortDirty=false;var destroyChildren=typeof options==='boolean'?options:options&&options.children;var oldChildren=this.removeChildren(0,this.children.length);if(destroyChildren){for(var i=0;i<oldChildren.length;++i){oldChildren[i].destroy(options);}}};Object.defineProperty(Container.prototype,\"width\",{/** The width of the Container, setting this will actually modify the scale to achieve the value set. */get:function get(){return this.scale.x*this.getLocalBounds().width;},set:function set(value){var width=this.getLocalBounds().width;if(width!==0){this.scale.x=value/width;}else{this.scale.x=1;}this._width=value;},enumerable:false,configurable:true});Object.defineProperty(Container.prototype,\"height\",{/** The height of the Container, setting this will actually modify the scale to achieve the value set. */get:function get(){return this.scale.y*this.getLocalBounds().height;},set:function set(value){var height=this.getLocalBounds().height;if(height!==0){this.scale.y=value/height;}else{this.scale.y=1;}this._height=value;},enumerable:false,configurable:true});return Container;}(DisplayObject);/**\n * Container default updateTransform, does update children of container.\n * Will crash if there's no parent element.\n *\n * @memberof PIXI.Container#\n * @method containerUpdateTransform\n */Container.prototype.containerUpdateTransform=Container.prototype.updateTransform;export{Bounds,Container,DisplayObject,TemporaryDisplayObject};","map":null,"metadata":{},"sourceType":"module"}