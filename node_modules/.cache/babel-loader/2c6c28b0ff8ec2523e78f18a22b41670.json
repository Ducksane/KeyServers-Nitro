{"ast":null,"code":"/*!\n * @pixi/interaction - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/interaction is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{Point}from'@pixi/math';import{Ticker,UPDATE_PRIORITY}from'@pixi/ticker';import{DisplayObject,TemporaryDisplayObject}from'@pixi/display';import{EventEmitter}from'@pixi/utils';/**\n * Holds all information related to an Interaction event\n *\n * @memberof PIXI\n */var InteractionData=/** @class */function(){function InteractionData(){/**\n         * Pressure applied by the pointing device during the event. A Touch's force property\n         * will be represented by this value.\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n         */this.pressure=0;/**\n         * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n         */this.rotationAngle=0;/**\n         * Twist of a stylus pointer.\n         *\n         * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n         */this.twist=0;/**\n         * Barrel pressure on a stylus pointer.\n         *\n         * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n         */this.tangentialPressure=0;this.global=new Point();this.target=null;this.originalEvent=null;this.identifier=null;this.isPrimary=false;this.button=0;this.buttons=0;this.width=0;this.height=0;this.tiltX=0;this.tiltY=0;this.pointerType=null;this.pressure=0;this.rotationAngle=0;this.twist=0;this.tangentialPressure=0;}Object.defineProperty(InteractionData.prototype,\"pointerId\",{/**\n         * The unique identifier of the pointer. It will be the same as `identifier`.\n         *\n         * @readonly\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n         */get:function get(){return this.identifier;},enumerable:false,configurable:true});/**\n     * This will return the local coordinates of the specified displayObject for this InteractionData\n     *\n     * @param displayObject - The DisplayObject that you would like the local\n     *  coords off\n     * @param point - A Point object in which to store the value, optional (otherwise\n     *  will create a new point)\n     * @param globalPos - A Point object containing your custom global coords, optional\n     *  (otherwise will use the current global coords)\n     * @return - A point containing the coordinates of the InteractionData position relative\n     *  to the DisplayObject\n     */InteractionData.prototype.getLocalPosition=function(displayObject,point,globalPos){return displayObject.worldTransform.applyInverse(globalPos||this.global,point);};/**\n     * Copies properties from normalized event data.\n     *\n     * @param {Touch|MouseEvent|PointerEvent} event - The normalized event data\n     */InteractionData.prototype.copyEvent=function(event){// isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n// it with \"false\" on later events when our shim for it on touch events might not be\n// accurate\nif('isPrimary'in event&&event.isPrimary){this.isPrimary=true;}this.button='button'in event&&event.button;// event.buttons is not available in all browsers (ie. Safari), but it does have a non-standard\n// event.which property instead, which conveys the same information.\nvar buttons='buttons'in event&&event.buttons;this.buttons=Number.isInteger(buttons)?buttons:'which'in event&&event.which;this.width='width'in event&&event.width;this.height='height'in event&&event.height;this.tiltX='tiltX'in event&&event.tiltX;this.tiltY='tiltY'in event&&event.tiltY;this.pointerType='pointerType'in event&&event.pointerType;this.pressure='pressure'in event&&event.pressure;this.rotationAngle='rotationAngle'in event&&event.rotationAngle;this.twist='twist'in event&&event.twist||0;this.tangentialPressure='tangentialPressure'in event&&event.tangentialPressure||0;};/** Resets the data for pooling. */InteractionData.prototype.reset=function(){// isPrimary is the only property that we really need to reset - everything else is\n// guaranteed to be overwritten\nthis.isPrimary=false;};return InteractionData;}();/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */ /* global Reflect, Promise */var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p)){d[p]=b[p];}}};return _extendStatics(d,b);};function __extends(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());}/**\n * Event class that mimics native DOM events.\n *\n * @memberof PIXI\n */var InteractionEvent=/** @class */function(){function InteractionEvent(){this.stopped=false;this.stopsPropagatingAt=null;this.stopPropagationHint=false;this.target=null;this.currentTarget=null;this.type=null;this.data=null;}/** Prevents event from reaching any objects other than the current object. */InteractionEvent.prototype.stopPropagation=function(){this.stopped=true;this.stopPropagationHint=true;this.stopsPropagatingAt=this.currentTarget;};/** Resets the event. */InteractionEvent.prototype.reset=function(){this.stopped=false;this.stopsPropagatingAt=null;this.stopPropagationHint=false;this.currentTarget=null;this.target=null;};return InteractionEvent;}();/**\n * DisplayObjects with the {@link PIXI.interactiveTarget} mixin use this class to track interactions\n *\n * @class\n * @private\n * @memberof PIXI\n */var InteractionTrackingData=/** @class */function(){/**\n     * @param {number} pointerId - Unique pointer id of the event\n     * @private\n     */function InteractionTrackingData(pointerId){this._pointerId=pointerId;this._flags=InteractionTrackingData.FLAGS.NONE;}/**\n     *\n     * @private\n     * @param {number} flag - The interaction flag to set\n     * @param {boolean} yn - Should the flag be set or unset\n     */InteractionTrackingData.prototype._doSet=function(flag,yn){if(yn){this._flags=this._flags|flag;}else{this._flags=this._flags&~flag;}};Object.defineProperty(InteractionTrackingData.prototype,\"pointerId\",{/**\n         * Unique pointer id of the event\n         *\n         * @readonly\n         * @private\n         * @member {number}\n         */get:function get(){return this._pointerId;},enumerable:false,configurable:true});Object.defineProperty(InteractionTrackingData.prototype,\"flags\",{/**\n         * State of the tracking data, expressed as bit flags\n         *\n         * @private\n         * @member {number}\n         */get:function get(){return this._flags;},set:function set(flags){this._flags=flags;},enumerable:false,configurable:true});Object.defineProperty(InteractionTrackingData.prototype,\"none\",{/**\n         * Is the tracked event inactive (not over or down)?\n         *\n         * @private\n         * @member {number}\n         */get:function get(){return this._flags===InteractionTrackingData.FLAGS.NONE;},enumerable:false,configurable:true});Object.defineProperty(InteractionTrackingData.prototype,\"over\",{/**\n         * Is the tracked event over the DisplayObject?\n         *\n         * @private\n         * @member {boolean}\n         */get:function get(){return(this._flags&InteractionTrackingData.FLAGS.OVER)!==0;},set:function set(yn){this._doSet(InteractionTrackingData.FLAGS.OVER,yn);},enumerable:false,configurable:true});Object.defineProperty(InteractionTrackingData.prototype,\"rightDown\",{/**\n         * Did the right mouse button come down in the DisplayObject?\n         *\n         * @private\n         * @member {boolean}\n         */get:function get(){return(this._flags&InteractionTrackingData.FLAGS.RIGHT_DOWN)!==0;},set:function set(yn){this._doSet(InteractionTrackingData.FLAGS.RIGHT_DOWN,yn);},enumerable:false,configurable:true});Object.defineProperty(InteractionTrackingData.prototype,\"leftDown\",{/**\n         * Did the left mouse button come down in the DisplayObject?\n         *\n         * @private\n         * @member {boolean}\n         */get:function get(){return(this._flags&InteractionTrackingData.FLAGS.LEFT_DOWN)!==0;},set:function set(yn){this._doSet(InteractionTrackingData.FLAGS.LEFT_DOWN,yn);},enumerable:false,configurable:true});InteractionTrackingData.FLAGS=Object.freeze({NONE:0,OVER:1<<0,LEFT_DOWN:1<<1,RIGHT_DOWN:1<<2});return InteractionTrackingData;}();/**\n * Strategy how to search through stage tree for interactive objects\n *\n * @memberof PIXI\n */var TreeSearch=/** @class */function(){function TreeSearch(){this._tempPoint=new Point();}/**\n     * Recursive implementation for findHit\n     *\n     * @private\n     * @param interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param func - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param hitTest - this indicates if the objects inside should be hit test against the point\n     * @param interactive - Whether the displayObject is interactive\n     * @return - Returns true if the displayObject hit the point\n     */TreeSearch.prototype.recursiveFindHit=function(interactionEvent,displayObject,func,hitTest,interactive){if(!displayObject||!displayObject.visible){return false;}var point=interactionEvent.data.global;// Took a little while to rework this function correctly! But now it is done and nice and optimized! ^_^\n//\n// This function will now loop through all objects and then only hit test the objects it HAS\n// to, not all of them. MUCH faster..\n// An object will be hit test if the following is true:\n//\n// 1: It is interactive.\n// 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n//\n// As another little optimization once an interactive object has been hit we can carry on\n// through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n// A final optimization is that an object is not hit test directly if a child has already been hit.\ninteractive=displayObject.interactive||interactive;var hit=false;var interactiveParent=interactive;// Flag here can set to false if the event is outside the parents hitArea or mask\nvar hitTestChildren=true;// If there is a hitArea, no need to test against anything else if the pointer is not within the hitArea\n// There is also no longer a need to hitTest children.\nif(displayObject.hitArea){if(hitTest){displayObject.worldTransform.applyInverse(point,this._tempPoint);if(!displayObject.hitArea.contains(this._tempPoint.x,this._tempPoint.y)){hitTest=false;hitTestChildren=false;}else{hit=true;}}interactiveParent=false;}// If there is a mask, no need to hitTest against anything else if the pointer is not within the mask.\n// We still want to hitTestChildren, however, to ensure a mouseout can still be generated.\n// https://github.com/pixijs/pixi.js/issues/5135\nelse if(displayObject._mask){if(hitTest){if(!(displayObject._mask.containsPoint&&displayObject._mask.containsPoint(point))){hitTest=false;}}}// ** FREE TIP **! If an object is not interactive or has no buttons in it\n// (such as a game scene!) set interactiveChildren to false for that displayObject.\n// This will allow PixiJS to completely ignore and bypass checking the displayObjects children.\nif(hitTestChildren&&displayObject.interactiveChildren&&displayObject.children){var children=displayObject.children;for(var i=children.length-1;i>=0;i--){var child=children[i];// time to get recursive.. if this function will return if something is hit..\nvar childHit=this.recursiveFindHit(interactionEvent,child,func,hitTest,interactiveParent);if(childHit){// its a good idea to check if a child has lost its parent.\n// this means it has been removed whilst looping so its best\nif(!child.parent){continue;}// we no longer need to hit test any more objects in this container as we we\n// now know the parent has been hit\ninteractiveParent=false;// If the child is interactive , that means that the object hit was actually\n// interactive and not just the child of an interactive object.\n// This means we no longer need to hit test anything else. We still need to run\n// through all objects, but we don't need to perform any hit tests.\nif(childHit){if(interactionEvent.target){hitTest=false;}hit=true;}}}}// no point running this if the item is not interactive or does not have an interactive parent.\nif(interactive){// if we are hit testing (as in we have no hit any objects yet)\n// We also don't need to worry about hit testing if once of the displayObjects children\n// has already been hit - but only if it was interactive, otherwise we need to keep\n// looking for an interactive child, just in case we hit one\nif(hitTest&&!interactionEvent.target){// already tested against hitArea if it is defined\nif(!displayObject.hitArea&&displayObject.containsPoint){if(displayObject.containsPoint(point)){hit=true;}}}if(displayObject.interactive){if(hit&&!interactionEvent.target){interactionEvent.target=displayObject;}if(func){func(interactionEvent,displayObject,!!hit);}}}return hit;};/**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @private\n     * @param interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param func - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param hitTest - this indicates if the objects inside should be hit test against the point\n     * @return - Returns true if the displayObject hit the point\n     */TreeSearch.prototype.findHit=function(interactionEvent,displayObject,func,hitTest){this.recursiveFindHit(interactionEvent,displayObject,func,hitTest,false);};return TreeSearch;}();/**\n * Interface for classes that represent a hit area.\n *\n * It is implemented by the following classes:\n * - {@link PIXI.Circle}\n * - {@link PIXI.Ellipse}\n * - {@link PIXI.Polygon}\n * - {@link PIXI.RoundedRectangle}\n *\n * @interface IHitArea\n * @memberof PIXI\n */ /**\n * Checks whether the x and y coordinates given are contained within this area\n *\n * @method\n * @name contains\n * @memberof PIXI.IHitArea#\n * @param {number} x - The X coordinate of the point to test\n * @param {number} y - The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this area\n */ /**\n * Default property values of interactive objects\n * Used by {@link PIXI.InteractionManager} to automatically give all DisplayObjects these properties\n *\n * @private\n * @name interactiveTarget\n * @type {Object}\n * @memberof PIXI\n * @example\n *      function MyObject() {}\n *\n *      Object.assign(\n *          DisplayObject.prototype,\n *          PIXI.interactiveTarget\n *      );\n */var interactiveTarget={interactive:false,interactiveChildren:true,hitArea:null,/**\n     * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive\n     * Setting this changes the 'cursor' property to `'pointer'`.\n     *\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.buttonMode = true;\n     * @member {boolean}\n     * @memberof PIXI.DisplayObject#\n     */get buttonMode(){return this.cursor==='pointer';},set buttonMode(value){if(value){this.cursor='pointer';}else if(this.cursor==='pointer'){this.cursor=null;}},/**\n     * This defines what cursor mode is used when the mouse cursor\n     * is hovered over the displayObject.\n     *\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.cursor = 'wait';\n     * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor\n     *\n     * @member {string}\n     * @memberof PIXI.DisplayObject#\n     */cursor:null,/**\n     * Internal set of all active pointers, by identifier\n     *\n     * @member {Map<number, InteractionTrackingData>}\n     * @memberof PIXI.DisplayObject#\n     * @private\n     */get trackedPointers(){if(this._trackedPointers===undefined){this._trackedPointers={};}return this._trackedPointers;},/**\n     * Map of all tracked pointers, by identifier. Use trackedPointers to access.\n     *\n     * @private\n     * @type {Map<number, InteractionTrackingData>}\n     */_trackedPointers:undefined};// Mix interactiveTarget into DisplayObject.prototype\nDisplayObject.mixin(interactiveTarget);var MOUSE_POINTER_ID=1;// helpers for hitTest() - only used inside hitTest()\nvar hitTestEvent={target:null,data:{global:null}};/**\n * The interaction manager deals with mouse, touch and pointer events.\n *\n * Any DisplayObject can be interactive if its `interactive` property is set to true.\n *\n * This manager also supports multitouch.\n *\n * An instance of this class is automatically created by default, and can be found at `renderer.plugins.interaction`\n *\n * @memberof PIXI\n */var InteractionManager=/** @class */function(_super){__extends(InteractionManager,_super);/**\n     * @param {PIXI.CanvasRenderer|PIXI.Renderer} renderer - A reference to the current renderer\n     * @param options - The options for the manager.\n     * @param {boolean} [options.autoPreventDefault=true] - Should the manager automatically prevent default browser actions.\n     * @param {number} [options.interactionFrequency=10] - Maximum frequency (ms) at pointer over/out states will be checked.\n     * @param {number} [options.useSystemTicker=true] - Whether to add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n     */function InteractionManager(renderer,options){var _this=_super.call(this)||this;options=options||{};_this.renderer=renderer;_this.autoPreventDefault=options.autoPreventDefault!==undefined?options.autoPreventDefault:true;_this.interactionFrequency=options.interactionFrequency||10;_this.mouse=new InteractionData();_this.mouse.identifier=MOUSE_POINTER_ID;// setting the mouse to start off far off screen will mean that mouse over does\n//  not get called before we even move the mouse.\n_this.mouse.global.set(-999999);_this.activeInteractionData={};_this.activeInteractionData[MOUSE_POINTER_ID]=_this.mouse;_this.interactionDataPool=[];_this.eventData=new InteractionEvent();_this.interactionDOMElement=null;_this.moveWhenInside=false;_this.eventsAdded=false;_this.tickerAdded=false;_this.mouseOverRenderer=!('PointerEvent'in globalThis);_this.supportsTouchEvents='ontouchstart'in globalThis;_this.supportsPointerEvents=!!globalThis.PointerEvent;// this will make it so that you don't have to call bind all the time\n_this.onPointerUp=_this.onPointerUp.bind(_this);_this.processPointerUp=_this.processPointerUp.bind(_this);_this.onPointerCancel=_this.onPointerCancel.bind(_this);_this.processPointerCancel=_this.processPointerCancel.bind(_this);_this.onPointerDown=_this.onPointerDown.bind(_this);_this.processPointerDown=_this.processPointerDown.bind(_this);_this.onPointerMove=_this.onPointerMove.bind(_this);_this.processPointerMove=_this.processPointerMove.bind(_this);_this.onPointerOut=_this.onPointerOut.bind(_this);_this.processPointerOverOut=_this.processPointerOverOut.bind(_this);_this.onPointerOver=_this.onPointerOver.bind(_this);_this.cursorStyles={default:'inherit',pointer:'pointer'};_this.currentCursorMode=null;_this.cursor=null;_this.resolution=1;_this.delayedEvents=[];_this.search=new TreeSearch();_this._tempDisplayObject=new TemporaryDisplayObject();_this._eventListenerOptions={capture:true,passive:false};/**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n         * object.\n         *\n         * @event PIXI.InteractionManager#mousedown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * on the display object.\n         *\n         * @event PIXI.InteractionManager#rightdown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button (usually a mouse left-button) is released over the display\n         * object.\n         *\n         * @event PIXI.InteractionManager#mouseup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * over the display object.\n         *\n         * @event PIXI.InteractionManager#rightup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n         * the display object.\n         *\n         * @event PIXI.InteractionManager#click\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * and released on the display object.\n         *\n         * @event PIXI.InteractionManager#rightclick\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button (usually a mouse left-button) is released outside the\n         * display object that initially registered a\n         * [mousedown]{@link PIXI.InteractionManager#event:mousedown}.\n         *\n         * @event PIXI.InteractionManager#mouseupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * outside the display object that initially registered a\n         * [rightdown]{@link PIXI.InteractionManager#event:rightdown}.\n         *\n         * @event PIXI.InteractionManager#rightupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device (usually a mouse) is moved while over the display object\n         *\n         * @event PIXI.InteractionManager#mousemove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device (usually a mouse) is moved onto the display object\n         *\n         * @event PIXI.InteractionManager#mouseover\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device (usually a mouse) is moved off the display object\n         *\n         * @event PIXI.InteractionManager#mouseout\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button is pressed on the display object.\n         *\n         * @event PIXI.InteractionManager#pointerdown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button is released over the display object.\n         * Not always fired when some buttons are held down while others are released. In those cases,\n         * use [mousedown]{@link PIXI.InteractionManager#event:mousedown} and\n         * [mouseup]{@link PIXI.InteractionManager#event:mouseup} instead.\n         *\n         * @event PIXI.InteractionManager#pointerup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when the operating system cancels a pointer event\n         *\n         * @event PIXI.InteractionManager#pointercancel\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button is pressed and released on the display object.\n         *\n         * @event PIXI.InteractionManager#pointertap\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button is released outside the display object that initially\n         * registered a [pointerdown]{@link PIXI.InteractionManager#event:pointerdown}.\n         *\n         * @event PIXI.InteractionManager#pointerupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device is moved while over the display object\n         *\n         * @event PIXI.InteractionManager#pointermove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device is moved onto the display object\n         *\n         * @event PIXI.InteractionManager#pointerover\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device is moved off the display object\n         *\n         * @event PIXI.InteractionManager#pointerout\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is placed on the display object.\n         *\n         * @event PIXI.InteractionManager#touchstart\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is removed from the display object.\n         *\n         * @event PIXI.InteractionManager#touchend\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when the operating system cancels a touch\n         *\n         * @event PIXI.InteractionManager#touchcancel\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is placed and removed from the display object.\n         *\n         * @event PIXI.InteractionManager#tap\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is removed outside of the display object that initially\n         * registered a [touchstart]{@link PIXI.InteractionManager#event:touchstart}.\n         *\n         * @event PIXI.InteractionManager#touchendoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is moved along the display object.\n         *\n         * @event PIXI.InteractionManager#touchmove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n         * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#mousedown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#rightdown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button (usually a mouse left-button) is released over the display\n         * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#mouseup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#rightup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n         * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#click\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n         * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#rightclick\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button (usually a mouse left-button) is released outside the\n         * display object that initially registered a\n         * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#mouseupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device secondary button (usually a mouse right-button) is released\n         * outside the display object that initially registered a\n         * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#rightupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device (usually a mouse) is moved while over the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#mousemove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device (usually a mouse) is moved onto the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#mouseover\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device (usually a mouse) is moved off the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#mouseout\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button is pressed on the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#pointerdown\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button is released over the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#pointerup\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when the operating system cancels a pointer event.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#pointercancel\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button is pressed and released on the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#pointertap\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device button is released outside the display object that initially\n         * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#pointerupoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device is moved while over the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#pointermove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device is moved onto the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#pointerover\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a pointer device is moved off the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#pointerout\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is placed on the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#touchstart\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is removed from the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#touchend\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when the operating system cancels a touch.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#touchcancel\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is placed and removed from the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#tap\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is removed outside of the display object that initially\n         * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#touchendoutside\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */ /**\n         * Fired when a touch point is moved along the display object.\n         * DisplayObject's `interactive` property must be set to `true` to fire event.\n         *\n         * This comes from the @pixi/interaction package.\n         *\n         * @event PIXI.DisplayObject#touchmove\n         * @param {PIXI.InteractionEvent} event - Interaction event\n         */_this._useSystemTicker=options.useSystemTicker!==undefined?options.useSystemTicker:true;_this.setTargetElement(_this.renderer.view,_this.renderer.resolution);return _this;}Object.defineProperty(InteractionManager.prototype,\"useSystemTicker\",{/**\n         * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n         *\n         * @default true\n         */get:function get(){return this._useSystemTicker;},set:function set(useSystemTicker){this._useSystemTicker=useSystemTicker;if(useSystemTicker){this.addTickerListener();}else{this.removeTickerListener();}},enumerable:false,configurable:true});Object.defineProperty(InteractionManager.prototype,\"lastObjectRendered\",{/**\n         * Last rendered object or temp object.\n         *\n         * @readonly\n         * @protected\n         */get:function get(){return this.renderer._lastObjectRendered||this._tempDisplayObject;},enumerable:false,configurable:true});/**\n     * Hit tests a point against the display tree, returning the first interactive object that is hit.\n     *\n     * @param globalPoint - A point to hit test with, in global space.\n     * @param root - The root display object to start from. If omitted, defaults\n     * to the last rendered root of the associated renderer.\n     * @return - The hit display object, if any.\n     */InteractionManager.prototype.hitTest=function(globalPoint,root){// clear the target for our hit test\nhitTestEvent.target=null;// assign the global point\nhitTestEvent.data.global=globalPoint;// ensure safety of the root\nif(!root){root=this.lastObjectRendered;}// run the hit test\nthis.processInteractive(hitTestEvent,root,null,true);// return our found object - it'll be null if we didn't hit anything\nreturn hitTestEvent.target;};/**\n     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to delegate\n     * another DOM element to receive those events.\n     *\n     * @param element - the DOM element which will receive mouse and touch events.\n     * @param resolution - The resolution / device pixel ratio of the new element (relative to the canvas).\n     */InteractionManager.prototype.setTargetElement=function(element,resolution){if(resolution===void 0){resolution=1;}this.removeTickerListener();this.removeEvents();this.interactionDOMElement=element;this.resolution=resolution;this.addEvents();this.addTickerListener();};/** Adds the ticker listener. */InteractionManager.prototype.addTickerListener=function(){if(this.tickerAdded||!this.interactionDOMElement||!this._useSystemTicker){return;}Ticker.system.add(this.tickerUpdate,this,UPDATE_PRIORITY.INTERACTION);this.tickerAdded=true;};/** Removes the ticker listener. */InteractionManager.prototype.removeTickerListener=function(){if(!this.tickerAdded){return;}Ticker.system.remove(this.tickerUpdate,this);this.tickerAdded=false;};/** Registers all the DOM events. */InteractionManager.prototype.addEvents=function(){if(this.eventsAdded||!this.interactionDOMElement){return;}var style=this.interactionDOMElement.style;if(globalThis.navigator.msPointerEnabled){style.msContentZooming='none';style.msTouchAction='none';}else if(this.supportsPointerEvents){style.touchAction='none';}/*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */if(this.supportsPointerEvents){globalThis.document.addEventListener('pointermove',this.onPointerMove,this._eventListenerOptions);this.interactionDOMElement.addEventListener('pointerdown',this.onPointerDown,this._eventListenerOptions);// pointerout is fired in addition to pointerup (for touch events) and pointercancel\n// we already handle those, so for the purposes of what we do in onPointerOut, we only\n// care about the pointerleave event\nthis.interactionDOMElement.addEventListener('pointerleave',this.onPointerOut,this._eventListenerOptions);this.interactionDOMElement.addEventListener('pointerover',this.onPointerOver,this._eventListenerOptions);globalThis.addEventListener('pointercancel',this.onPointerCancel,this._eventListenerOptions);globalThis.addEventListener('pointerup',this.onPointerUp,this._eventListenerOptions);}else{globalThis.document.addEventListener('mousemove',this.onPointerMove,this._eventListenerOptions);this.interactionDOMElement.addEventListener('mousedown',this.onPointerDown,this._eventListenerOptions);this.interactionDOMElement.addEventListener('mouseout',this.onPointerOut,this._eventListenerOptions);this.interactionDOMElement.addEventListener('mouseover',this.onPointerOver,this._eventListenerOptions);globalThis.addEventListener('mouseup',this.onPointerUp,this._eventListenerOptions);}// always look directly for touch events so that we can provide original data\n// In a future version we should change this to being just a fallback and rely solely on\n// PointerEvents whenever available\nif(this.supportsTouchEvents){this.interactionDOMElement.addEventListener('touchstart',this.onPointerDown,this._eventListenerOptions);this.interactionDOMElement.addEventListener('touchcancel',this.onPointerCancel,this._eventListenerOptions);this.interactionDOMElement.addEventListener('touchend',this.onPointerUp,this._eventListenerOptions);this.interactionDOMElement.addEventListener('touchmove',this.onPointerMove,this._eventListenerOptions);}this.eventsAdded=true;};/** Removes all the DOM events that were previously registered. */InteractionManager.prototype.removeEvents=function(){if(!this.eventsAdded||!this.interactionDOMElement){return;}var style=this.interactionDOMElement.style;if(globalThis.navigator.msPointerEnabled){style.msContentZooming='';style.msTouchAction='';}else if(this.supportsPointerEvents){style.touchAction='';}if(this.supportsPointerEvents){globalThis.document.removeEventListener('pointermove',this.onPointerMove,this._eventListenerOptions);this.interactionDOMElement.removeEventListener('pointerdown',this.onPointerDown,this._eventListenerOptions);this.interactionDOMElement.removeEventListener('pointerleave',this.onPointerOut,this._eventListenerOptions);this.interactionDOMElement.removeEventListener('pointerover',this.onPointerOver,this._eventListenerOptions);globalThis.removeEventListener('pointercancel',this.onPointerCancel,this._eventListenerOptions);globalThis.removeEventListener('pointerup',this.onPointerUp,this._eventListenerOptions);}else{globalThis.document.removeEventListener('mousemove',this.onPointerMove,this._eventListenerOptions);this.interactionDOMElement.removeEventListener('mousedown',this.onPointerDown,this._eventListenerOptions);this.interactionDOMElement.removeEventListener('mouseout',this.onPointerOut,this._eventListenerOptions);this.interactionDOMElement.removeEventListener('mouseover',this.onPointerOver,this._eventListenerOptions);globalThis.removeEventListener('mouseup',this.onPointerUp,this._eventListenerOptions);}if(this.supportsTouchEvents){this.interactionDOMElement.removeEventListener('touchstart',this.onPointerDown,this._eventListenerOptions);this.interactionDOMElement.removeEventListener('touchcancel',this.onPointerCancel,this._eventListenerOptions);this.interactionDOMElement.removeEventListener('touchend',this.onPointerUp,this._eventListenerOptions);this.interactionDOMElement.removeEventListener('touchmove',this.onPointerMove,this._eventListenerOptions);}this.interactionDOMElement=null;this.eventsAdded=false;};/**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link PIXI.Ticker.system}.\n     *\n     * @param deltaTime - time delta since the last call\n     */InteractionManager.prototype.tickerUpdate=function(deltaTime){this._deltaTime+=deltaTime;if(this._deltaTime<this.interactionFrequency){return;}this._deltaTime=0;this.update();};/** Updates the state of interactive objects. */InteractionManager.prototype.update=function(){if(!this.interactionDOMElement){return;}// if the user move the mouse this check has already been done using the mouse move!\nif(this._didMove){this._didMove=false;return;}this.cursor=null;// Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n// but there was a scenario of a display object moving under a static mouse cursor.\n// In this case, mouseover and mouseevents would not pass the flag test in dispatchEvent function\nfor(var k in this.activeInteractionData){// eslint-disable-next-line no-prototype-builtins\nif(this.activeInteractionData.hasOwnProperty(k)){var interactionData=this.activeInteractionData[k];if(interactionData.originalEvent&&interactionData.pointerType!=='touch'){var interactionEvent=this.configureInteractionEventForDOMEvent(this.eventData,interactionData.originalEvent,interactionData);this.processInteractive(interactionEvent,this.lastObjectRendered,this.processPointerOverOut,true);}}}this.setCursorMode(this.cursor);};/**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     *\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */InteractionManager.prototype.setCursorMode=function(mode){mode=mode||'default';var applyStyles=true;// offscreen canvas does not support setting styles, but cursor modes can be functions,\n// in order to handle pixi rendered cursors, so we can't bail\nif(globalThis.OffscreenCanvas&&this.interactionDOMElement instanceof OffscreenCanvas){applyStyles=false;}// if the mode didn't actually change, bail early\nif(this.currentCursorMode===mode){return;}this.currentCursorMode=mode;var style=this.cursorStyles[mode];// only do things if there is a cursor style for it\nif(style){switch(typeof style){case'string':// string styles are handled as cursor CSS\nif(applyStyles){this.interactionDOMElement.style.cursor=style;}break;case'function':// functions are just called, and passed the cursor mode\nstyle(mode);break;case'object':// if it is an object, assume that it is a dictionary of CSS styles,\n// apply it to the interactionDOMElement\nif(applyStyles){Object.assign(this.interactionDOMElement.style,style);}break;}}else if(applyStyles&&typeof mode==='string'&&!Object.prototype.hasOwnProperty.call(this.cursorStyles,mode)){// if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n// for the mode, then assume that the dev wants it to be CSS for the cursor.\nthis.interactionDOMElement.style.cursor=mode;}};/**\n     * Dispatches an event on the display object that was interacted with.\n     *\n     * @param displayObject - the display object in question\n     * @param eventString - the name of the event (e.g, mousedown)\n     * @param eventData - the event data object\n     */InteractionManager.prototype.dispatchEvent=function(displayObject,eventString,eventData){// Even if the event was stopped, at least dispatch any remaining events\n// for the same display object.\nif(!eventData.stopPropagationHint||displayObject===eventData.stopsPropagatingAt){eventData.currentTarget=displayObject;eventData.type=eventString;displayObject.emit(eventString,eventData);if(displayObject[eventString]){displayObject[eventString](eventData);}}};/**\n     * Puts a event on a queue to be dispatched later. This is used to guarantee correct\n     * ordering of over/out events.\n     *\n     * @param displayObject - the display object in question\n     * @param eventString - the name of the event (e.g, mousedown)\n     * @param eventData - the event data object\n     */InteractionManager.prototype.delayDispatchEvent=function(displayObject,eventString,eventData){this.delayedEvents.push({displayObject:displayObject,eventString:eventString,eventData:eventData});};/**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     *\n     * @param point - the point that the result will be stored in\n     * @param x - the x coord of the position to map\n     * @param y - the y coord of the position to map\n     */InteractionManager.prototype.mapPositionToPoint=function(point,x,y){var rect;// IE 11 fix\nif(!this.interactionDOMElement.parentElement){rect={x:0,y:0,width:this.interactionDOMElement.width,height:this.interactionDOMElement.height,left:0,top:0};}else{rect=this.interactionDOMElement.getBoundingClientRect();}var resolutionMultiplier=1.0/this.resolution;point.x=(x-rect.left)*(this.interactionDOMElement.width/rect.width)*resolutionMultiplier;point.y=(y-rect.top)*(this.interactionDOMElement.height/rect.height)*resolutionMultiplier;};/**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @protected\n     * @param interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param func - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param hitTest - indicates whether we want to calculate hits\n     *  or just iterate through all interactive objects\n     */InteractionManager.prototype.processInteractive=function(interactionEvent,displayObject,func,hitTest){var hit=this.search.findHit(interactionEvent,displayObject,func,hitTest);var delayedEvents=this.delayedEvents;if(!delayedEvents.length){return hit;}// Reset the propagation hint, because we start deeper in the tree again.\ninteractionEvent.stopPropagationHint=false;var delayedLen=delayedEvents.length;this.delayedEvents=[];for(var i=0;i<delayedLen;i++){var _a=delayedEvents[i],displayObject_1=_a.displayObject,eventString=_a.eventString,eventData=_a.eventData;// When we reach the object we wanted to stop propagating at,\n// set the propagation hint.\nif(eventData.stopsPropagatingAt===displayObject_1){eventData.stopPropagationHint=true;}this.dispatchEvent(displayObject_1,eventString,eventData);}return hit;};/**\n     * Is called when the pointer button is pressed down on the renderer element\n     *\n     * @param originalEvent - The DOM event of a pointer button being pressed down\n     */InteractionManager.prototype.onPointerDown=function(originalEvent){// if we support touch events, then only use those for touch events, not pointer events\nif(this.supportsTouchEvents&&originalEvent.pointerType==='touch'){return;}var events=this.normalizeToPointerData(originalEvent);/*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */ // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\nif(this.autoPreventDefault&&events[0].isNormalized){var cancelable=originalEvent.cancelable||!('cancelable'in originalEvent);if(cancelable){originalEvent.preventDefault();}}var eventLen=events.length;for(var i=0;i<eventLen;i++){var event=events[i];var interactionData=this.getInteractionDataForPointerId(event);var interactionEvent=this.configureInteractionEventForDOMEvent(this.eventData,event,interactionData);interactionEvent.data.originalEvent=originalEvent;this.processInteractive(interactionEvent,this.lastObjectRendered,this.processPointerDown,true);this.emit('pointerdown',interactionEvent);if(event.pointerType==='touch'){this.emit('touchstart',interactionEvent);}// emit a mouse event for \"pen\" pointers, the way a browser would emit a fallback event\nelse if(event.pointerType==='mouse'||event.pointerType==='pen'){var isRightButton=event.button===2;this.emit(isRightButton?'rightdown':'mousedown',this.eventData);}}};/**\n     * Processes the result of the pointer down check and dispatches the event if need be\n     *\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     * @param hit - the result of the hit test on the display object\n     */InteractionManager.prototype.processPointerDown=function(interactionEvent,displayObject,hit){var data=interactionEvent.data;var id=interactionEvent.data.identifier;if(hit){if(!displayObject.trackedPointers[id]){displayObject.trackedPointers[id]=new InteractionTrackingData(id);}this.dispatchEvent(displayObject,'pointerdown',interactionEvent);if(data.pointerType==='touch'){this.dispatchEvent(displayObject,'touchstart',interactionEvent);}else if(data.pointerType==='mouse'||data.pointerType==='pen'){var isRightButton=data.button===2;if(isRightButton){displayObject.trackedPointers[id].rightDown=true;}else{displayObject.trackedPointers[id].leftDown=true;}this.dispatchEvent(displayObject,isRightButton?'rightdown':'mousedown',interactionEvent);}}};/**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @param originalEvent - The DOM event of a pointer button being released\n     * @param cancelled - true if the pointer is cancelled\n     * @param func - Function passed to {@link processInteractive}\n     */InteractionManager.prototype.onPointerComplete=function(originalEvent,cancelled,func){var events=this.normalizeToPointerData(originalEvent);var eventLen=events.length;// if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n// in all cases (unless it was a pointercancel)\nvar eventAppend=originalEvent.target!==this.interactionDOMElement?'outside':'';for(var i=0;i<eventLen;i++){var event=events[i];var interactionData=this.getInteractionDataForPointerId(event);var interactionEvent=this.configureInteractionEventForDOMEvent(this.eventData,event,interactionData);interactionEvent.data.originalEvent=originalEvent;// perform hit testing for events targeting our canvas or cancel events\nthis.processInteractive(interactionEvent,this.lastObjectRendered,func,cancelled||!eventAppend);this.emit(cancelled?'pointercancel':\"pointerup\"+eventAppend,interactionEvent);if(event.pointerType==='mouse'||event.pointerType==='pen'){var isRightButton=event.button===2;this.emit(isRightButton?\"rightup\"+eventAppend:\"mouseup\"+eventAppend,interactionEvent);}else if(event.pointerType==='touch'){this.emit(cancelled?'touchcancel':\"touchend\"+eventAppend,interactionEvent);this.releaseInteractionDataForPointerId(event.pointerId);}}};/**\n     * Is called when the pointer button is cancelled\n     *\n     * @param event - The DOM event of a pointer button being released\n     */InteractionManager.prototype.onPointerCancel=function(event){// if we support touch events, then only use those for touch events, not pointer events\nif(this.supportsTouchEvents&&event.pointerType==='touch'){return;}this.onPointerComplete(event,true,this.processPointerCancel);};/**\n     * Processes the result of the pointer cancel check and dispatches the event if need be\n     *\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     */InteractionManager.prototype.processPointerCancel=function(interactionEvent,displayObject){var data=interactionEvent.data;var id=interactionEvent.data.identifier;if(displayObject.trackedPointers[id]!==undefined){delete displayObject.trackedPointers[id];this.dispatchEvent(displayObject,'pointercancel',interactionEvent);if(data.pointerType==='touch'){this.dispatchEvent(displayObject,'touchcancel',interactionEvent);}}};/**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @param event - The DOM event of a pointer button being released\n     */InteractionManager.prototype.onPointerUp=function(event){// if we support touch events, then only use those for touch events, not pointer events\nif(this.supportsTouchEvents&&event.pointerType==='touch'){return;}this.onPointerComplete(event,false,this.processPointerUp);};/**\n     * Processes the result of the pointer up check and dispatches the event if need be\n     *\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     * @param hit - the result of the hit test on the display object\n     */InteractionManager.prototype.processPointerUp=function(interactionEvent,displayObject,hit){var data=interactionEvent.data;var id=interactionEvent.data.identifier;var trackingData=displayObject.trackedPointers[id];var isTouch=data.pointerType==='touch';var isMouse=data.pointerType==='mouse'||data.pointerType==='pen';// need to track mouse down status in the mouse block so that we can emit\n// event in a later block\nvar isMouseTap=false;// Mouse only\nif(isMouse){var isRightButton=data.button===2;var flags=InteractionTrackingData.FLAGS;var test=isRightButton?flags.RIGHT_DOWN:flags.LEFT_DOWN;var isDown=trackingData!==undefined&&trackingData.flags&test;if(hit){this.dispatchEvent(displayObject,isRightButton?'rightup':'mouseup',interactionEvent);if(isDown){this.dispatchEvent(displayObject,isRightButton?'rightclick':'click',interactionEvent);// because we can confirm that the mousedown happened on this object, flag for later emit of pointertap\nisMouseTap=true;}}else if(isDown){this.dispatchEvent(displayObject,isRightButton?'rightupoutside':'mouseupoutside',interactionEvent);}// update the down state of the tracking data\nif(trackingData){if(isRightButton){trackingData.rightDown=false;}else{trackingData.leftDown=false;}}}// Pointers and Touches, and Mouse\nif(hit){this.dispatchEvent(displayObject,'pointerup',interactionEvent);if(isTouch){this.dispatchEvent(displayObject,'touchend',interactionEvent);}if(trackingData){// emit pointertap if not a mouse, or if the mouse block decided it was a tap\nif(!isMouse||isMouseTap){this.dispatchEvent(displayObject,'pointertap',interactionEvent);}if(isTouch){this.dispatchEvent(displayObject,'tap',interactionEvent);// touches are no longer over (if they ever were) when we get the touchend\n// so we should ensure that we don't keep pretending that they are\ntrackingData.over=false;}}}else if(trackingData){this.dispatchEvent(displayObject,'pointerupoutside',interactionEvent);if(isTouch){this.dispatchEvent(displayObject,'touchendoutside',interactionEvent);}}// Only remove the tracking data if there is no over/down state still associated with it\nif(trackingData&&trackingData.none){delete displayObject.trackedPointers[id];}};/**\n     * Is called when the pointer moves across the renderer element\n     *\n     * @param originalEvent - The DOM event of a pointer moving\n     */InteractionManager.prototype.onPointerMove=function(originalEvent){// if we support touch events, then only use those for touch events, not pointer events\nif(this.supportsTouchEvents&&originalEvent.pointerType==='touch'){return;}var events=this.normalizeToPointerData(originalEvent);if(events[0].pointerType==='mouse'||events[0].pointerType==='pen'){this._didMove=true;this.cursor=null;}var eventLen=events.length;for(var i=0;i<eventLen;i++){var event=events[i];var interactionData=this.getInteractionDataForPointerId(event);var interactionEvent=this.configureInteractionEventForDOMEvent(this.eventData,event,interactionData);interactionEvent.data.originalEvent=originalEvent;this.processInteractive(interactionEvent,this.lastObjectRendered,this.processPointerMove,true);this.emit('pointermove',interactionEvent);if(event.pointerType==='touch'){this.emit('touchmove',interactionEvent);}if(event.pointerType==='mouse'||event.pointerType==='pen'){this.emit('mousemove',interactionEvent);}}if(events[0].pointerType==='mouse'){this.setCursorMode(this.cursor);// TODO BUG for parents interactive object (border order issue)\n}};/**\n     * Processes the result of the pointer move check and dispatches the event if need be\n     *\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     * @param hit - the result of the hit test on the display object\n     */InteractionManager.prototype.processPointerMove=function(interactionEvent,displayObject,hit){var data=interactionEvent.data;var isTouch=data.pointerType==='touch';var isMouse=data.pointerType==='mouse'||data.pointerType==='pen';if(isMouse){this.processPointerOverOut(interactionEvent,displayObject,hit);}if(!this.moveWhenInside||hit){this.dispatchEvent(displayObject,'pointermove',interactionEvent);if(isTouch){this.dispatchEvent(displayObject,'touchmove',interactionEvent);}if(isMouse){this.dispatchEvent(displayObject,'mousemove',interactionEvent);}}};/**\n     * Is called when the pointer is moved out of the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n     */InteractionManager.prototype.onPointerOut=function(originalEvent){// if we support touch events, then only use those for touch events, not pointer events\nif(this.supportsTouchEvents&&originalEvent.pointerType==='touch'){return;}var events=this.normalizeToPointerData(originalEvent);// Only mouse and pointer can call onPointerOut, so events will always be length 1\nvar event=events[0];if(event.pointerType==='mouse'){this.mouseOverRenderer=false;this.setCursorMode(null);}var interactionData=this.getInteractionDataForPointerId(event);var interactionEvent=this.configureInteractionEventForDOMEvent(this.eventData,event,interactionData);interactionEvent.data.originalEvent=event;this.processInteractive(interactionEvent,this.lastObjectRendered,this.processPointerOverOut,false);this.emit('pointerout',interactionEvent);if(event.pointerType==='mouse'||event.pointerType==='pen'){this.emit('mouseout',interactionEvent);}else{// we can get touchleave events after touchend, so we want to make sure we don't\n// introduce memory leaks\nthis.releaseInteractionDataForPointerId(interactionData.identifier);}};/**\n     * Processes the result of the pointer over/out check and dispatches the event if need be.\n     *\n     * @param interactionEvent - The interaction event wrapping the DOM event\n     * @param displayObject - The display object that was tested\n     * @param hit - the result of the hit test on the display object\n     */InteractionManager.prototype.processPointerOverOut=function(interactionEvent,displayObject,hit){var data=interactionEvent.data;var id=interactionEvent.data.identifier;var isMouse=data.pointerType==='mouse'||data.pointerType==='pen';var trackingData=displayObject.trackedPointers[id];// if we just moused over the display object, then we need to track that state\nif(hit&&!trackingData){trackingData=displayObject.trackedPointers[id]=new InteractionTrackingData(id);}if(trackingData===undefined){return;}if(hit&&this.mouseOverRenderer){if(!trackingData.over){trackingData.over=true;this.delayDispatchEvent(displayObject,'pointerover',interactionEvent);if(isMouse){this.delayDispatchEvent(displayObject,'mouseover',interactionEvent);}}// only change the cursor if it has not already been changed (by something deeper in the\n// display tree)\nif(isMouse&&this.cursor===null){this.cursor=displayObject.cursor;}}else if(trackingData.over){trackingData.over=false;this.dispatchEvent(displayObject,'pointerout',this.eventData);if(isMouse){this.dispatchEvent(displayObject,'mouseout',interactionEvent);}// if there is no mouse down information for the pointer, then it is safe to delete\nif(trackingData.none){delete displayObject.trackedPointers[id];}}};/**\n     * Is called when the pointer is moved into the renderer element.\n     *\n     * @param originalEvent - The DOM event of a pointer button being moved into the renderer view.\n     */InteractionManager.prototype.onPointerOver=function(originalEvent){var events=this.normalizeToPointerData(originalEvent);// Only mouse and pointer can call onPointerOver, so events will always be length 1\nvar event=events[0];var interactionData=this.getInteractionDataForPointerId(event);var interactionEvent=this.configureInteractionEventForDOMEvent(this.eventData,event,interactionData);interactionEvent.data.originalEvent=event;if(event.pointerType==='mouse'){this.mouseOverRenderer=true;}this.emit('pointerover',interactionEvent);if(event.pointerType==='mouse'||event.pointerType==='pen'){this.emit('mouseover',interactionEvent);}};/**\n     * Get InteractionData for a given pointerId. Store that data as well.\n     *\n     * @param event - Normalized pointer event, output from normalizeToPointerData.\n     * @return - Interaction data for the given pointer identifier.\n     */InteractionManager.prototype.getInteractionDataForPointerId=function(event){var pointerId=event.pointerId;var interactionData;if(pointerId===MOUSE_POINTER_ID||event.pointerType==='mouse'){interactionData=this.mouse;}else if(this.activeInteractionData[pointerId]){interactionData=this.activeInteractionData[pointerId];}else{interactionData=this.interactionDataPool.pop()||new InteractionData();interactionData.identifier=pointerId;this.activeInteractionData[pointerId]=interactionData;}// copy properties from the event, so that we can make sure that touch/pointer specific\n// data is available\ninteractionData.copyEvent(event);return interactionData;};/**\n     * Return unused InteractionData to the pool, for a given pointerId\n     *\n     * @param pointerId - Identifier from a pointer event\n     */InteractionManager.prototype.releaseInteractionDataForPointerId=function(pointerId){var interactionData=this.activeInteractionData[pointerId];if(interactionData){delete this.activeInteractionData[pointerId];interactionData.reset();this.interactionDataPool.push(interactionData);}};/**\n     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n     *\n     * @param interactionEvent - The event to be configured\n     * @param pointerEvent - The DOM event that will be paired with the InteractionEvent\n     * @param interactionData - The InteractionData that will be paired\n     *        with the InteractionEvent\n     * @return - the interaction event that was passed in\n     */InteractionManager.prototype.configureInteractionEventForDOMEvent=function(interactionEvent,pointerEvent,interactionData){interactionEvent.data=interactionData;this.mapPositionToPoint(interactionData.global,pointerEvent.clientX,pointerEvent.clientY);// Not really sure why this is happening, but it's how a previous version handled things\nif(pointerEvent.pointerType==='touch'){pointerEvent.globalX=interactionData.global.x;pointerEvent.globalY=interactionData.global.y;}interactionData.originalEvent=pointerEvent;interactionEvent.reset();return interactionEvent;};/**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     *\n     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n     * @return - An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */InteractionManager.prototype.normalizeToPointerData=function(event){var normalizedEvents=[];if(this.supportsTouchEvents&&event instanceof TouchEvent){for(var i=0,li=event.changedTouches.length;i<li;i++){var touch=event.changedTouches[i];if(typeof touch.button==='undefined'){touch.button=event.touches.length?1:0;}if(typeof touch.buttons==='undefined'){touch.buttons=event.touches.length?1:0;}if(typeof touch.isPrimary==='undefined'){touch.isPrimary=event.touches.length===1&&event.type==='touchstart';}if(typeof touch.width==='undefined'){touch.width=touch.radiusX||1;}if(typeof touch.height==='undefined'){touch.height=touch.radiusY||1;}if(typeof touch.tiltX==='undefined'){touch.tiltX=0;}if(typeof touch.tiltY==='undefined'){touch.tiltY=0;}if(typeof touch.pointerType==='undefined'){touch.pointerType='touch';}if(typeof touch.pointerId==='undefined'){touch.pointerId=touch.identifier||0;}if(typeof touch.pressure==='undefined'){touch.pressure=touch.force||0.5;}if(typeof touch.twist==='undefined'){touch.twist=0;}if(typeof touch.tangentialPressure==='undefined'){touch.tangentialPressure=0;}// TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n// support, and the fill ins are not quite the same\n// offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n// left is not 0,0 on the page\nif(typeof touch.layerX==='undefined'){touch.layerX=touch.offsetX=touch.clientX;}if(typeof touch.layerY==='undefined'){touch.layerY=touch.offsetY=touch.clientY;}// mark the touch as normalized, just so that we know we did it\ntouch.isNormalized=true;normalizedEvents.push(touch);}}// apparently PointerEvent subclasses MouseEvent, so yay\nelse if(!globalThis.MouseEvent||event instanceof MouseEvent&&(!this.supportsPointerEvents||!(event instanceof globalThis.PointerEvent))){var tempEvent=event;if(typeof tempEvent.isPrimary==='undefined'){tempEvent.isPrimary=true;}if(typeof tempEvent.width==='undefined'){tempEvent.width=1;}if(typeof tempEvent.height==='undefined'){tempEvent.height=1;}if(typeof tempEvent.tiltX==='undefined'){tempEvent.tiltX=0;}if(typeof tempEvent.tiltY==='undefined'){tempEvent.tiltY=0;}if(typeof tempEvent.pointerType==='undefined'){tempEvent.pointerType='mouse';}if(typeof tempEvent.pointerId==='undefined'){tempEvent.pointerId=MOUSE_POINTER_ID;}if(typeof tempEvent.pressure==='undefined'){tempEvent.pressure=0.5;}if(typeof tempEvent.twist==='undefined'){tempEvent.twist=0;}if(typeof tempEvent.tangentialPressure==='undefined'){tempEvent.tangentialPressure=0;}// mark the mouse event as normalized, just so that we know we did it\ntempEvent.isNormalized=true;normalizedEvents.push(tempEvent);}else{normalizedEvents.push(event);}return normalizedEvents;};/** Destroys the interaction manager. */InteractionManager.prototype.destroy=function(){this.removeEvents();this.removeTickerListener();this.removeAllListeners();this.renderer=null;this.mouse=null;this.eventData=null;this.interactionDOMElement=null;this.onPointerDown=null;this.processPointerDown=null;this.onPointerUp=null;this.processPointerUp=null;this.onPointerCancel=null;this.processPointerCancel=null;this.onPointerMove=null;this.processPointerMove=null;this.onPointerOut=null;this.processPointerOverOut=null;this.onPointerOver=null;this.search=null;};return InteractionManager;}(EventEmitter);export{InteractionData,InteractionEvent,InteractionManager,InteractionTrackingData,interactiveTarget};","map":null,"metadata":{},"sourceType":"module"}