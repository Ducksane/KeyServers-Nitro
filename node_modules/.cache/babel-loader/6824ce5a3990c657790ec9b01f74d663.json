{"ast":null,"code":"import _createForOfIteratorHelper from\"/home/muphy/Documents/habboom/Nitro-Edit-main/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import{Vector,getDistances,getStyleFromRgb,rangeColorToRgb}from\"tsparticles-engine\";export function drawPolygonMask(context,rawData,stroke){var color=rangeColorToRgb(stroke.color);if(!color){return;}context.beginPath();context.moveTo(rawData[0].x,rawData[0].y);var _iterator=_createForOfIteratorHelper(rawData),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var item=_step.value;context.lineTo(item.x,item.y);}}catch(err){_iterator.e(err);}finally{_iterator.f();}context.closePath();context.strokeStyle=getStyleFromRgb(color);context.lineWidth=stroke.width;context.stroke();}export function drawPolygonMaskPath(context,path,stroke,position){context.translate(position.x,position.y);var color=rangeColorToRgb(stroke.color);if(!color){return;}context.strokeStyle=getStyleFromRgb(color,stroke.opacity);context.lineWidth=stroke.width;context.stroke(path);}export function parsePaths(paths,scale,offset){var _a;var res=[];var _iterator2=_createForOfIteratorHelper(paths),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var path=_step2.value;var segments=path.element.pathSegList,len=(_a=segments===null||segments===void 0?void 0:segments.numberOfItems)!==null&&_a!==void 0?_a:0,p={x:0,y:0};for(var i=0;i<len;i++){var segment=segments===null||segments===void 0?void 0:segments.getItem(i);var svgPathSeg=window.SVGPathSeg;switch(segment===null||segment===void 0?void 0:segment.pathSegType){case svgPathSeg.PATHSEG_MOVETO_ABS:case svgPathSeg.PATHSEG_LINETO_ABS:case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:case svgPathSeg.PATHSEG_ARC_ABS:case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:{var absSeg=segment;p.x=absSeg.x;p.y=absSeg.y;break;}case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:p.x=segment.x;break;case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:p.y=segment.y;break;case svgPathSeg.PATHSEG_LINETO_REL:case svgPathSeg.PATHSEG_MOVETO_REL:case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:case svgPathSeg.PATHSEG_ARC_REL:case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:{var relSeg=segment;p.x+=relSeg.x;p.y+=relSeg.y;break;}case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:p.x+=segment.x;break;case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:p.y+=segment.y;break;case svgPathSeg.PATHSEG_UNKNOWN:case svgPathSeg.PATHSEG_CLOSEPATH:continue;}res.push({x:p.x*scale+offset.x,y:p.y*scale+offset.y});}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return res;}export function calcClosestPtOnSegment(s1,s2,pos){var _getDistances=getDistances(pos,s1),dx=_getDistances.dx,dy=_getDistances.dy,_getDistances2=getDistances(s2,s1),dxx=_getDistances2.dx,dyy=_getDistances2.dy,t=(dx*dxx+dy*dyy)/(Math.pow(dxx,2)+Math.pow(dyy,2)),res={x:s1.x+dxx*t,y:s1.x+dyy*t,isOnSegment:t>=0&&t<=1};if(t<0){res.x=s1.x;res.y=s1.y;}else if(t>1){res.x=s2.x;res.y=s2.y;}return res;}export function segmentBounce(start,stop,velocity){var _getDistances3=getDistances(start,stop),dx=_getDistances3.dx,dy=_getDistances3.dy,wallAngle=Math.atan2(dy,dx),wallNormal=Vector.create(Math.sin(wallAngle),-Math.cos(wallAngle)),d=2*(velocity.x*wallNormal.x+velocity.y*wallNormal.y);wallNormal.multTo(d);velocity.subFrom(wallNormal);}","map":null,"metadata":{},"sourceType":"module"}