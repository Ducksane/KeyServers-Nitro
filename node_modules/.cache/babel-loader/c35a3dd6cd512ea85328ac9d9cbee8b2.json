{"ast":null,"code":"/*!\n * @pixi/extract - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/extract is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{CanvasRenderTarget}from'@pixi/utils';import{Rectangle}from'@pixi/math';import{RenderTexture}from'@pixi/core';var TEMP_RECT=new Rectangle();var BYTES_PER_PIXEL=4;/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n *\n * @example\n * // Create a new app (will auto-add extract plugin to renderer)\n * const app = new PIXI.Application();\n *\n * // Draw a red circle\n * const graphics = new PIXI.Graphics()\n *     .beginFill(0xFF0000)\n *     .drawCircle(0, 0, 50);\n *\n * // Render the graphics as an HTMLImageElement\n * const image = app.renderer.plugins.extract.image(graphics);\n * document.body.appendChild(image);\n *\n * @memberof PIXI\n */var Extract=/** @class */function(){/**\n     * @param renderer - A reference to the current renderer\n     */function Extract(renderer){this.renderer=renderer;}/**\n     * Will return a HTML Image of the target\n     *\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @return - HTML Image of the target\n     */Extract.prototype.image=function(target,format,quality){var image=new Image();image.src=this.base64(target,format,quality);return image;};/**\n     * Will return a base64 encoded string of this target. It works by calling\n     *  `Extract.getCanvas` and then running toDataURL on that.\n     *\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param format - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param quality - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @return - A base64 encoded string of the texture.\n     */Extract.prototype.base64=function(target,format,quality){return this.canvas(target).toDataURL(format,quality);};/**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     *\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @return - A Canvas element with the texture rendered on.\n     */Extract.prototype.canvas=function(target){var renderer=this.renderer;var resolution;var frame;var flipY=false;var renderTexture;var generated=false;if(target){if(target instanceof RenderTexture){renderTexture=target;}else{renderTexture=this.renderer.generateTexture(target);generated=true;}}if(renderTexture){resolution=renderTexture.baseTexture.resolution;frame=renderTexture.frame;flipY=false;renderer.renderTexture.bind(renderTexture);}else{resolution=this.renderer.resolution;flipY=true;frame=TEMP_RECT;frame.width=this.renderer.width;frame.height=this.renderer.height;renderer.renderTexture.bind(null);}var width=Math.floor(frame.width*resolution+1e-4);var height=Math.floor(frame.height*resolution+1e-4);var canvasBuffer=new CanvasRenderTarget(width,height,1);var webglPixels=new Uint8Array(BYTES_PER_PIXEL*width*height);// read pixels to the array\nvar gl=renderer.gl;gl.readPixels(frame.x*resolution,frame.y*resolution,width,height,gl.RGBA,gl.UNSIGNED_BYTE,webglPixels);// add the pixels to the canvas\nvar canvasData=canvasBuffer.context.getImageData(0,0,width,height);Extract.arrayPostDivide(webglPixels,canvasData.data);canvasBuffer.context.putImageData(canvasData,0,0);// pulling pixels\nif(flipY){var target_1=new CanvasRenderTarget(canvasBuffer.width,canvasBuffer.height,1);target_1.context.scale(1,-1);// we can't render to itself because we should be empty before render.\ntarget_1.context.drawImage(canvasBuffer.canvas,0,-height);canvasBuffer.destroy();canvasBuffer=target_1;}if(generated){renderTexture.destroy(true);}// send the canvas back..\nreturn canvasBuffer.canvas;};/**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     *\n     * @param target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @return - One-dimensional array containing the pixel data of the entire texture\n     */Extract.prototype.pixels=function(target){var renderer=this.renderer;var resolution;var frame;var renderTexture;var generated=false;if(target){if(target instanceof RenderTexture){renderTexture=target;}else{renderTexture=this.renderer.generateTexture(target);generated=true;}}if(renderTexture){resolution=renderTexture.baseTexture.resolution;frame=renderTexture.frame;// bind the buffer\nrenderer.renderTexture.bind(renderTexture);}else{resolution=renderer.resolution;frame=TEMP_RECT;frame.width=renderer.width;frame.height=renderer.height;renderer.renderTexture.bind(null);}var width=frame.width*resolution;var height=frame.height*resolution;var webglPixels=new Uint8Array(BYTES_PER_PIXEL*width*height);// read pixels to the array\nvar gl=renderer.gl;gl.readPixels(frame.x*resolution,frame.y*resolution,width,height,gl.RGBA,gl.UNSIGNED_BYTE,webglPixels);if(generated){renderTexture.destroy(true);}Extract.arrayPostDivide(webglPixels,webglPixels);return webglPixels;};/** Destroys the extract. */Extract.prototype.destroy=function(){this.renderer=null;};/**\n     * Takes premultiplied pixel data and produces regular pixel data\n     *\n     * @private\n     * @param pixels - array of pixel data\n     * @param out - output array\n     */Extract.arrayPostDivide=function(pixels,out){for(var i=0;i<pixels.length;i+=4){var alpha=out[i+3]=pixels[i+3];if(alpha!==0){out[i]=Math.round(Math.min(pixels[i]*255.0/alpha,255.0));out[i+1]=Math.round(Math.min(pixels[i+1]*255.0/alpha,255.0));out[i+2]=Math.round(Math.min(pixels[i+2]*255.0/alpha,255.0));}else{out[i]=pixels[i];out[i+1]=pixels[i+1];out[i+2]=pixels[i+2];}}};return Extract;}();export{Extract};","map":null,"metadata":{},"sourceType":"module"}