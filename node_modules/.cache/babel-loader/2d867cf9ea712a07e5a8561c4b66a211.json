{"ast":null,"code":"/*!\n * @pixi/text - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/text is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{Sprite}from'@pixi/sprite';import{Texture}from'@pixi/core';import{settings}from'@pixi/settings';import{Rectangle}from'@pixi/math';import{hex2string,hex2rgb,string2hex,trimCanvas,sign}from'@pixi/utils';/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */ /* global Reflect, Promise */var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p)){d[p]=b[p];}}};return _extendStatics(d,b);};function __extends(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());}/**\n * Constants that define the type of gradient on text.\n *\n * @static\n * @constant\n * @name TEXT_GRADIENT\n * @memberof PIXI\n * @type {object}\n * @property {number} LINEAR_VERTICAL Vertical gradient\n * @property {number} LINEAR_HORIZONTAL Linear gradient\n */var TEXT_GRADIENT;(function(TEXT_GRADIENT){TEXT_GRADIENT[TEXT_GRADIENT[\"LINEAR_VERTICAL\"]=0]=\"LINEAR_VERTICAL\";TEXT_GRADIENT[TEXT_GRADIENT[\"LINEAR_HORIZONTAL\"]=1]=\"LINEAR_HORIZONTAL\";})(TEXT_GRADIENT||(TEXT_GRADIENT={}));// disabling eslint for now, going to rewrite this in v5\nvar defaultStyle={align:'left',breakWords:false,dropShadow:false,dropShadowAlpha:1,dropShadowAngle:Math.PI/6,dropShadowBlur:0,dropShadowColor:'black',dropShadowDistance:5,fill:'black',fillGradientType:TEXT_GRADIENT.LINEAR_VERTICAL,fillGradientStops:[],fontFamily:'Arial',fontSize:26,fontStyle:'normal',fontVariant:'normal',fontWeight:'normal',letterSpacing:0,lineHeight:0,lineJoin:'miter',miterLimit:10,padding:0,stroke:'black',strokeThickness:0,textBaseline:'alphabetic',trim:false,whiteSpace:'pre',wordWrap:false,wordWrapWidth:100,leading:0};var genericFontFamilies=['serif','sans-serif','monospace','cursive','fantasy','system-ui'];/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n *\n * A tool can be used to generate a text style [here](https://pixijs.io/pixi-text-style).\n *\n * @memberof PIXI\n */var TextStyle=/** @class */function(){/**\n     * @param {object} [style] - The style parameters\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'),\n     *  does not affect single line text\n     * @param {boolean} [style.breakWords=false] - Indicates if lines can be wrapped within words, it\n     *  needs wordWrap to be set to true\n     * @param {boolean} [style.dropShadow=false] - Set a drop shadow for the text\n     * @param {number} [style.dropShadowAlpha=1] - Set alpha for the drop shadow\n     * @param {number} [style.dropShadowAngle=Math.PI/6] - Set a angle of the drop shadow\n     * @param {number} [style.dropShadowBlur=0] - Set a shadow blur radius\n     * @param {string|number} [style.dropShadowColor='black'] - A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n     * @param {number} [style.dropShadowDistance=5] - Set a distance of the drop shadow\n     * @param {string|string[]|number|number[]|CanvasGradient|CanvasPattern} [style.fill='black'] - A canvas\n     *  fillstyle that will be used on the text e.g 'red', '#00FF00'. Can be an array to create a gradient\n     *  eg ['#000000','#FFFFFF']\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @param {number} [style.fillGradientType=PIXI.TEXT_GRADIENT.LINEAR_VERTICAL] - If fill is an array of colours\n     *  to create a gradient, this can change the type/direction of the gradient. See {@link PIXI.TEXT_GRADIENT}\n     * @param {number[]} [style.fillGradientStops] - If fill is an array of colours to create a gradient, this array can set\n     * the stop points (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.\n     * @param {string|string[]} [style.fontFamily='Arial'] - The font family\n     * @param {number|string} [style.fontSize=26] - The font size (as a number it converts to px, but as a string,\n     *  equivalents are '26px','20pt','160%' or '1.6em')\n     * @param {string} [style.fontStyle='normal'] - The font style ('normal', 'italic' or 'oblique')\n     * @param {string} [style.fontVariant='normal'] - The font variant ('normal' or 'small-caps')\n     * @param {string} [style.fontWeight='normal'] - The font weight ('normal', 'bold', 'bolder', 'lighter' and '100',\n     *  '200', '300', '400', '500', '600', '700', '800' or '900')\n     * @param {number} [style.leading=0] - The space between lines\n     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters, default is 0\n     * @param {number} [style.lineHeight] - The line height, a number that represents the vertical space that a letter uses\n     * @param {string} [style.lineJoin='miter'] - The lineJoin property sets the type of corner created, it can resolve\n     *      spiked text issues. Possible values \"miter\" (creates a sharp corner), \"round\" (creates a round corner) or \"bevel\"\n     *      (creates a squared corner).\n     * @param {number} [style.miterLimit=10] - The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n     *      or increase the spikiness of rendered text.\n     * @param {number} [style.padding=0] - Occasionally some fonts are cropped. Adding some padding will prevent this from\n     *     happening by adding padding to all sides of the text.\n     * @param {string|number} [style.stroke='black'] - A canvas fillstyle that will be used on the text stroke\n     *  e.g 'blue', '#FCFF00'\n     * @param {number} [style.strokeThickness=0] - A number that represents the thickness of the stroke.\n     *  Default is 0 (no stroke)\n     * @param {boolean} [style.trim=false] - Trim transparent borders\n     * @param {string} [style.textBaseline='alphabetic'] - The baseline of the text that is rendered.\n     * @param {string} [style.whiteSpace='pre'] - Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     *      (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve, collapse). It needs wordWrap to be set to true\n     * @param {boolean} [style.wordWrap=false] - Indicates if word wrap should be used\n     * @param {number} [style.wordWrapWidth=100] - The width at which text will wrap, it needs wordWrap to be set to true\n     */function TextStyle(style){this.styleID=0;this.reset();deepCopyProperties(this,style,style);}/**\n     * Creates a new TextStyle object with the same values as this one.\n     * Note that the only the properties of the object are cloned.\n     *\n     * @return New cloned TextStyle object\n     */TextStyle.prototype.clone=function(){var clonedProperties={};deepCopyProperties(clonedProperties,this,defaultStyle);return new TextStyle(clonedProperties);};/** Resets all properties to the defaults specified in TextStyle.prototype._default */TextStyle.prototype.reset=function(){deepCopyProperties(this,defaultStyle,defaultStyle);};Object.defineProperty(TextStyle.prototype,\"align\",{/**\n         * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n         *\n         * @member {string}\n         */get:function get(){return this._align;},set:function set(align){if(this._align!==align){this._align=align;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"breakWords\",{/** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */get:function get(){return this._breakWords;},set:function set(breakWords){if(this._breakWords!==breakWords){this._breakWords=breakWords;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"dropShadow\",{/** Set a drop shadow for the text. */get:function get(){return this._dropShadow;},set:function set(dropShadow){if(this._dropShadow!==dropShadow){this._dropShadow=dropShadow;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"dropShadowAlpha\",{/** Set alpha for the drop shadow. */get:function get(){return this._dropShadowAlpha;},set:function set(dropShadowAlpha){if(this._dropShadowAlpha!==dropShadowAlpha){this._dropShadowAlpha=dropShadowAlpha;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"dropShadowAngle\",{/** Set a angle of the drop shadow. */get:function get(){return this._dropShadowAngle;},set:function set(dropShadowAngle){if(this._dropShadowAngle!==dropShadowAngle){this._dropShadowAngle=dropShadowAngle;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"dropShadowBlur\",{/** Set a shadow blur radius. */get:function get(){return this._dropShadowBlur;},set:function set(dropShadowBlur){if(this._dropShadowBlur!==dropShadowBlur){this._dropShadowBlur=dropShadowBlur;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"dropShadowColor\",{/** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */get:function get(){return this._dropShadowColor;},set:function set(dropShadowColor){var outputColor=getColor(dropShadowColor);if(this._dropShadowColor!==outputColor){this._dropShadowColor=outputColor;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"dropShadowDistance\",{/** Set a distance of the drop shadow. */get:function get(){return this._dropShadowDistance;},set:function set(dropShadowDistance){if(this._dropShadowDistance!==dropShadowDistance){this._dropShadowDistance=dropShadowDistance;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"fill\",{/**\n         * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.\n         *\n         * Can be an array to create a gradient eg ['#000000','#FFFFFF']\n         * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n         *\n         * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */get:function get(){return this._fill;},set:function set(fill){// TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n//       the setter converts to string. See this thread for more details:\n//       https://github.com/microsoft/TypeScript/issues/2521\n// TODO: Not sure if getColor works properly with CanvasGradient and/or CanvasPattern, can't pass in\n//       without casting here.\nvar outputColor=getColor(fill);if(this._fill!==outputColor){this._fill=outputColor;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"fillGradientType\",{/**\n         * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.\n         *\n         * @see PIXI.TEXT_GRADIENT\n         */get:function get(){return this._fillGradientType;},set:function set(fillGradientType){if(this._fillGradientType!==fillGradientType){this._fillGradientType=fillGradientType;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"fillGradientStops\",{/**\n         * If fill is an array of colours to create a gradient, this array can set the stop points\n         * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.\n         */get:function get(){return this._fillGradientStops;},set:function set(fillGradientStops){if(!areArraysEqual(this._fillGradientStops,fillGradientStops)){this._fillGradientStops=fillGradientStops;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"fontFamily\",{/** The font family. */get:function get(){return this._fontFamily;},set:function set(fontFamily){if(this.fontFamily!==fontFamily){this._fontFamily=fontFamily;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"fontSize\",{/**\n         * The font size\n         * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')\n         */get:function get(){return this._fontSize;},set:function set(fontSize){if(this._fontSize!==fontSize){this._fontSize=fontSize;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"fontStyle\",{/**\n         * The font style\n         * ('normal', 'italic' or 'oblique')\n         *\n         * @member {string}\n         */get:function get(){return this._fontStyle;},set:function set(fontStyle){if(this._fontStyle!==fontStyle){this._fontStyle=fontStyle;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"fontVariant\",{/**\n         * The font variant\n         * ('normal' or 'small-caps')\n         *\n         * @member {string}\n         */get:function get(){return this._fontVariant;},set:function set(fontVariant){if(this._fontVariant!==fontVariant){this._fontVariant=fontVariant;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"fontWeight\",{/**\n         * The font weight\n         * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')\n         *\n         * @member {string}\n         */get:function get(){return this._fontWeight;},set:function set(fontWeight){if(this._fontWeight!==fontWeight){this._fontWeight=fontWeight;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"letterSpacing\",{/** The amount of spacing between letters, default is 0. */get:function get(){return this._letterSpacing;},set:function set(letterSpacing){if(this._letterSpacing!==letterSpacing){this._letterSpacing=letterSpacing;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"lineHeight\",{/** The line height, a number that represents the vertical space that a letter uses. */get:function get(){return this._lineHeight;},set:function set(lineHeight){if(this._lineHeight!==lineHeight){this._lineHeight=lineHeight;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"leading\",{/** The space between lines. */get:function get(){return this._leading;},set:function set(leading){if(this._leading!==leading){this._leading=leading;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"lineJoin\",{/**\n         * The lineJoin property sets the type of corner created, it can resolve spiked text issues.\n         * Default is 'miter' (creates a sharp corner).\n         *\n         * @member {string}\n         */get:function get(){return this._lineJoin;},set:function set(lineJoin){if(this._lineJoin!==lineJoin){this._lineJoin=lineJoin;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"miterLimit\",{/**\n         * The miter limit to use when using the 'miter' lineJoin mode.\n         *\n         * This can reduce or increase the spikiness of rendered text.\n         */get:function get(){return this._miterLimit;},set:function set(miterLimit){if(this._miterLimit!==miterLimit){this._miterLimit=miterLimit;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"padding\",{/**\n         * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n         * by adding padding to all sides of the text.\n         */get:function get(){return this._padding;},set:function set(padding){if(this._padding!==padding){this._padding=padding;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"stroke\",{/**\n         * A canvas fillstyle that will be used on the text stroke\n         * e.g 'blue', '#FCFF00'\n         */get:function get(){return this._stroke;},set:function set(stroke){// TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n//       the setter converts to string. See this thread for more details:\n//       https://github.com/microsoft/TypeScript/issues/2521\nvar outputColor=getColor(stroke);if(this._stroke!==outputColor){this._stroke=outputColor;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"strokeThickness\",{/**\n         * A number that represents the thickness of the stroke.\n         *\n         * @default 0\n         */get:function get(){return this._strokeThickness;},set:function set(strokeThickness){if(this._strokeThickness!==strokeThickness){this._strokeThickness=strokeThickness;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"textBaseline\",{/**\n         * The baseline of the text that is rendered.\n         *\n         * @member {string}\n         */get:function get(){return this._textBaseline;},set:function set(textBaseline){if(this._textBaseline!==textBaseline){this._textBaseline=textBaseline;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"trim\",{/** Trim transparent borders. */get:function get(){return this._trim;},set:function set(trim){if(this._trim!==trim){this._trim=trim;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"whiteSpace\",{/**\n         * How newlines and spaces should be handled.\n         * Default is 'pre' (preserve, preserve).\n         *\n         *  value       | New lines     |   Spaces\n         *  ---         | ---           |   ---\n         * 'normal'     | Collapse      |   Collapse\n         * 'pre'        | Preserve      |   Preserve\n         * 'pre-line'   | Preserve      |   Collapse\n         *\n         * @member {string}\n         */get:function get(){return this._whiteSpace;},set:function set(whiteSpace){if(this._whiteSpace!==whiteSpace){this._whiteSpace=whiteSpace;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"wordWrap\",{/** Indicates if word wrap should be used. */get:function get(){return this._wordWrap;},set:function set(wordWrap){if(this._wordWrap!==wordWrap){this._wordWrap=wordWrap;this.styleID++;}},enumerable:false,configurable:true});Object.defineProperty(TextStyle.prototype,\"wordWrapWidth\",{/** The width at which text will wrap, it needs wordWrap to be set to true. */get:function get(){return this._wordWrapWidth;},set:function set(wordWrapWidth){if(this._wordWrapWidth!==wordWrapWidth){this._wordWrapWidth=wordWrapWidth;this.styleID++;}},enumerable:false,configurable:true});/**\n     * Generates a font style string to use for `TextMetrics.measureFont()`.\n     *\n     * @return Font style string, for passing to `TextMetrics.measureFont()`\n     */TextStyle.prototype.toFontString=function(){// build canvas api font setting from individual components. Convert a numeric this.fontSize to px\nvar fontSizeString=typeof this.fontSize==='number'?this.fontSize+\"px\":this.fontSize;// Clean-up fontFamily property by quoting each font name\n// this will support font names with spaces\nvar fontFamilies=this.fontFamily;if(!Array.isArray(this.fontFamily)){fontFamilies=this.fontFamily.split(',');}for(var i=fontFamilies.length-1;i>=0;i--){// Trim any extra white-space\nvar fontFamily=fontFamilies[i].trim();// Check if font already contains strings\nif(!/([\\\"\\'])[^\\'\\\"]+\\1/.test(fontFamily)&&genericFontFamilies.indexOf(fontFamily)<0){fontFamily=\"\\\"\"+fontFamily+\"\\\"\";}fontFamilies[i]=fontFamily;}return this.fontStyle+\" \"+this.fontVariant+\" \"+this.fontWeight+\" \"+fontSizeString+\" \"+fontFamilies.join(',');};return TextStyle;}();/**\n * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.\n * @private\n * @param color\n * @return The color as a string.\n */function getSingleColor(color){if(typeof color==='number'){return hex2string(color);}else if(typeof color==='string'){if(color.indexOf('0x')===0){color=color.replace('0x','#');}}return color;}function getColor(color){if(!Array.isArray(color)){return getSingleColor(color);}else{for(var i=0;i<color.length;++i){color[i]=getSingleColor(color[i]);}return color;}}/**\n * Utility function to convert hexadecimal colors to strings, and simply return the color if it's a string.\n * This version can also convert array of colors\n * @private\n * @param array1 - First array to compare\n * @param array2 - Second array to compare\n * @return Do the arrays contain the same values in the same order\n */function areArraysEqual(array1,array2){if(!Array.isArray(array1)||!Array.isArray(array2)){return false;}if(array1.length!==array2.length){return false;}for(var i=0;i<array1.length;++i){if(array1[i]!==array2[i]){return false;}}return true;}/**\n * Utility function to ensure that object properties are copied by value, and not by reference\n * @private\n * @param target - Target object to copy properties into\n * @param source - Source object for the properties to copy\n * @param propertyObj - Object containing properties names we want to loop over\n */function deepCopyProperties(target,source,propertyObj){for(var prop in propertyObj){if(Array.isArray(source[prop])){target[prop]=source[prop].slice();}else{target[prop]=source[prop];}}}/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n *\n * ```js\n * let style = new PIXI.TextStyle({fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'})\n * let textMetrics = PIXI.TextMetrics.measureText('Your text', style)\n * ```\n *\n * @memberof PIXI\n */var TextMetrics=/** @class */function(){/**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {PIXI.IFontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */function TextMetrics(text,style,width,height,lines,lineWidths,lineHeight,maxLineWidth,fontProperties){this.text=text;this.style=style;this.width=width;this.height=height;this.lines=lines;this.lineWidths=lineWidths;this.lineHeight=lineHeight;this.maxLineWidth=maxLineWidth;this.fontProperties=fontProperties;}/**\n     * Measures the supplied string of text and returns a Rectangle.\n     *\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param wordWrap - Override for if word-wrap should be applied to the text.\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @return Measured width and height of the text.\n     */TextMetrics.measureText=function(text,style,wordWrap,canvas){if(canvas===void 0){canvas=TextMetrics._canvas;}wordWrap=wordWrap===undefined||wordWrap===null?style.wordWrap:wordWrap;var font=style.toFontString();var fontProperties=TextMetrics.measureFont(font);// fallback in case UA disallow canvas data extraction\n// (toDataURI, getImageData functions)\nif(fontProperties.fontSize===0){fontProperties.fontSize=style.fontSize;fontProperties.ascent=style.fontSize;}var context=canvas.getContext('2d');context.font=font;var outputText=wordWrap?TextMetrics.wordWrap(text,style,canvas):text;var lines=outputText.split(/(?:\\r\\n|\\r|\\n)/);var lineWidths=new Array(lines.length);var maxLineWidth=0;for(var i=0;i<lines.length;i++){var lineWidth=context.measureText(lines[i]).width+(lines[i].length-1)*style.letterSpacing;lineWidths[i]=lineWidth;maxLineWidth=Math.max(maxLineWidth,lineWidth);}var width=maxLineWidth+style.strokeThickness;if(style.dropShadow){width+=style.dropShadowDistance;}var lineHeight=style.lineHeight||fontProperties.fontSize+style.strokeThickness;var height=Math.max(lineHeight,fontProperties.fontSize+style.strokeThickness)+(lines.length-1)*(lineHeight+style.leading);if(style.dropShadow){height+=style.dropShadowDistance;}return new TextMetrics(text,style,width,height,lines,lineWidths,lineHeight+style.leading,maxLineWidth,fontProperties);};/**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     *\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @return New string with new lines applied where required\n     */TextMetrics.wordWrap=function(text,style,canvas){if(canvas===void 0){canvas=TextMetrics._canvas;}var context=canvas.getContext('2d');var width=0;var line='';var lines='';var cache=Object.create(null);var letterSpacing=style.letterSpacing,whiteSpace=style.whiteSpace;// How to handle whitespaces\nvar collapseSpaces=TextMetrics.collapseSpaces(whiteSpace);var collapseNewlines=TextMetrics.collapseNewlines(whiteSpace);// whether or not spaces may be added to the beginning of lines\nvar canPrependSpaces=!collapseSpaces;// There is letterSpacing after every char except the last one\n// t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n// so for convenience the above needs to be compared to width + 1 extra letterSpace\n// t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n// ________________________________________________\n// And then the final space is simply no appended to each line\nvar wordWrapWidth=style.wordWrapWidth+letterSpacing;// break text into words, spaces and newline chars\nvar tokens=TextMetrics.tokenize(text);for(var i=0;i<tokens.length;i++){// get the word, space or newlineChar\nvar token=tokens[i];// if word is a new line\nif(TextMetrics.isNewline(token)){// keep the new line\nif(!collapseNewlines){lines+=TextMetrics.addLine(line);canPrependSpaces=!collapseSpaces;line='';width=0;continue;}// if we should collapse new lines\n// we simply convert it into a space\ntoken=' ';}// if we should collapse repeated whitespaces\nif(collapseSpaces){// check both this and the last tokens for spaces\nvar currIsBreakingSpace=TextMetrics.isBreakingSpace(token);var lastIsBreakingSpace=TextMetrics.isBreakingSpace(line[line.length-1]);if(currIsBreakingSpace&&lastIsBreakingSpace){continue;}}// get word width from cache if possible\nvar tokenWidth=TextMetrics.getFromCache(token,letterSpacing,cache,context);// word is longer than desired bounds\nif(tokenWidth>wordWrapWidth){// if we are not already at the beginning of a line\nif(line!==''){// start newlines for overflow words\nlines+=TextMetrics.addLine(line);line='';width=0;}// break large word over multiple lines\nif(TextMetrics.canBreakWords(token,style.breakWords)){// break word into characters\nvar characters=TextMetrics.wordWrapSplit(token);// loop the characters\nfor(var j=0;j<characters.length;j++){var char=characters[j];var k=1;// we are not at the end of the token\nwhile(characters[j+k]){var nextChar=characters[j+k];var lastChar=char[char.length-1];// should not split chars\nif(!TextMetrics.canBreakChars(lastChar,nextChar,token,j,style.breakWords)){// combine chars & move forward one\nchar+=nextChar;}else{break;}k++;}j+=char.length-1;var characterWidth=TextMetrics.getFromCache(char,letterSpacing,cache,context);if(characterWidth+width>wordWrapWidth){lines+=TextMetrics.addLine(line);canPrependSpaces=false;line='';width=0;}line+=char;width+=characterWidth;}}// run word out of the bounds\nelse{// if there are words in this line already\n// finish that line and start a new one\nif(line.length>0){lines+=TextMetrics.addLine(line);line='';width=0;}var isLastToken=i===tokens.length-1;// give it its own line if it's not the end\nlines+=TextMetrics.addLine(token,!isLastToken);canPrependSpaces=false;line='';width=0;}}// word could fit\nelse{// word won't fit because of existing words\n// start a new line\nif(tokenWidth+width>wordWrapWidth){// if its a space we don't want it\ncanPrependSpaces=false;// add a new line\nlines+=TextMetrics.addLine(line);// start a new line\nline='';width=0;}// don't add spaces to the beginning of lines\nif(line.length>0||!TextMetrics.isBreakingSpace(token)||canPrependSpaces){// add the word to the current line\nline+=token;// update width counter\nwidth+=tokenWidth;}}}lines+=TextMetrics.addLine(line,false);return lines;};/**\n     * Convienience function for logging each line added during the wordWrap method.\n     *\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @return A formatted line\n     */TextMetrics.addLine=function(line,newLine){if(newLine===void 0){newLine=true;}line=TextMetrics.trimRight(line);line=newLine?line+\"\\n\":line;return line;};/**\n     * Gets & sets the widths of calculated characters in a cache object\n     *\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @return The from cache.\n     */TextMetrics.getFromCache=function(key,letterSpacing,cache,context){var width=cache[key];if(typeof width!=='number'){var spacing=key.length*letterSpacing;width=context.measureText(key).width+spacing;cache[key]=width;}return width;};/**\n     * Determines whether we should collapse breaking spaces.\n     *\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @return Should collapse\n     */TextMetrics.collapseSpaces=function(whiteSpace){return whiteSpace==='normal'||whiteSpace==='pre-line';};/**\n     * Determines whether we should collapse newLine chars.\n     *\n     * @param whiteSpace - The white space\n     * @return  should collapse\n     */TextMetrics.collapseNewlines=function(whiteSpace){return whiteSpace==='normal';};/**\n     * Trims breaking whitespaces from string.\n     *\n     * @param  text - The text\n     * @return Trimmed string\n     */TextMetrics.trimRight=function(text){if(typeof text!=='string'){return'';}for(var i=text.length-1;i>=0;i--){var char=text[i];if(!TextMetrics.isBreakingSpace(char)){break;}text=text.slice(0,-1);}return text;};/**\n     * Determines if char is a newline.\n     *\n     * @param  char - The character\n     * @return True if newline, False otherwise.\n     */TextMetrics.isNewline=function(char){if(typeof char!=='string'){return false;}return TextMetrics._newlines.indexOf(char.charCodeAt(0))>=0;};/**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     *\n     * @param char     - The character\n     * @param [nextChar] - The next character\n     * @return True if whitespace, False otherwise.\n     */TextMetrics.isBreakingSpace=function(char,_nextChar){if(typeof char!=='string'){return false;}return TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0))>=0;};/**\n     * Splits a string into words, breaking-spaces and newLine characters\n     *\n     * @param  text - The text\n     * @return  A tokenized array\n     */TextMetrics.tokenize=function(text){var tokens=[];var token='';if(typeof text!=='string'){return tokens;}for(var i=0;i<text.length;i++){var char=text[i];var nextChar=text[i+1];if(TextMetrics.isBreakingSpace(char,nextChar)||TextMetrics.isNewline(char)){if(token!==''){tokens.push(token);token='';}tokens.push(char);continue;}token+=char;}if(token!==''){tokens.push(token);}return tokens;};/**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     *\n     * @param  token       - The token\n     * @param  breakWords - The style attr break words\n     * @return Whether to break word or not\n     */TextMetrics.canBreakWords=function(_token,breakWords){return breakWords;};/**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     *\n     * @param  char        - The character\n     * @param  nextChar    - The next character\n     * @param  token       - The token/word the characters are from\n     * @param  index       - The index in the token of the char\n     * @param  breakWords - The style attr break words\n     * @return whether to break word or not\n     */TextMetrics.canBreakChars=function(_char,_nextChar,_token,_index,_breakWords){return true;};/**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     *\n     * @example\n     * // Correctly splits emojis, eg \"ðŸ¤ªðŸ¤ª\" will result in two element array, each with one emoji.\n     * TextMetrics.wordWrapSplit = (token) => [...token];\n     *\n     * @param  token - The token to split\n     * @return The characters of the token\n     */TextMetrics.wordWrapSplit=function(token){return token.split('');};/**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     *\n     * @param font - String representing the style of the font\n     * @return Font properties object\n     */TextMetrics.measureFont=function(font){// as this method is used for preparing assets, don't recalculate things if we don't need to\nif(TextMetrics._fonts[font]){return TextMetrics._fonts[font];}var properties={ascent:0,descent:0,fontSize:0};var canvas=TextMetrics._canvas;var context=TextMetrics._context;context.font=font;var metricsString=TextMetrics.METRICS_STRING+TextMetrics.BASELINE_SYMBOL;var width=Math.ceil(context.measureText(metricsString).width);var baseline=Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);var height=Math.ceil(TextMetrics.HEIGHT_MULTIPLIER*baseline);baseline=baseline*TextMetrics.BASELINE_MULTIPLIER|0;canvas.width=width;canvas.height=height;context.fillStyle='#f00';context.fillRect(0,0,width,height);context.font=font;context.textBaseline='alphabetic';context.fillStyle='#000';context.fillText(metricsString,0,baseline);var imagedata=context.getImageData(0,0,width,height).data;var pixels=imagedata.length;var line=width*4;var i=0;var idx=0;var stop=false;// ascent. scan from top to bottom until we find a non red pixel\nfor(i=0;i<baseline;++i){for(var j=0;j<line;j+=4){if(imagedata[idx+j]!==255){stop=true;break;}}if(!stop){idx+=line;}else{break;}}properties.ascent=baseline-i;idx=pixels-line;stop=false;// descent. scan from bottom to top until we find a non red pixel\nfor(i=height;i>baseline;--i){for(var j=0;j<line;j+=4){if(imagedata[idx+j]!==255){stop=true;break;}}if(!stop){idx-=line;}else{break;}}properties.descent=i-baseline;properties.fontSize=properties.ascent+properties.descent;TextMetrics._fonts[font]=properties;return properties;};/**\n     * Clear font metrics in metrics cache.\n     *\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */TextMetrics.clearMetrics=function(font){if(font===void 0){font='';}if(font){delete TextMetrics._fonts[font];}else{TextMetrics._fonts={};}};return TextMetrics;}();/**\n * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.\n *\n * @typedef {object} FontMetrics\n * @property {number} ascent - The ascent distance\n * @property {number} descent - The descent distance\n * @property {number} fontSize - Font size from ascent to descent\n * @memberof PIXI.TextMetrics\n * @private\n */var canvas=function(){try{// OffscreenCanvas2D measureText can be up to 40% faster.\nvar c=new OffscreenCanvas(0,0);var context=c.getContext('2d');if(context&&context.measureText){return c;}return document.createElement('canvas');}catch(ex){return document.createElement('canvas');}}();canvas.width=canvas.height=10;/**\n * Cached canvas element for measuring text\n *\n * @memberof PIXI.TextMetrics\n * @type {HTMLCanvasElement}\n * @private\n */TextMetrics._canvas=canvas;/**\n * Cache for context to use.\n *\n * @memberof PIXI.TextMetrics\n * @type {CanvasRenderingContext2D}\n * @private\n */TextMetrics._context=canvas.getContext('2d');/**\n * Cache of {@see PIXI.TextMetrics.FontMetrics} objects.\n *\n * @memberof PIXI.TextMetrics\n * @type {Object}\n * @private\n */TextMetrics._fonts={};/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n *\n * @static\n * @memberof PIXI.TextMetrics\n * @name METRICS_STRING\n * @type {string}\n * @default |Ã‰qÃ…\n */TextMetrics.METRICS_STRING='|Ã‰qÃ…';/**\n * Baseline symbol for calculate font metrics.\n *\n * @static\n * @memberof PIXI.TextMetrics\n * @name BASELINE_SYMBOL\n * @type {string}\n * @default M\n */TextMetrics.BASELINE_SYMBOL='M';/**\n * Baseline multiplier for calculate font metrics.\n *\n * @static\n * @memberof PIXI.TextMetrics\n * @name BASELINE_MULTIPLIER\n * @type {number}\n * @default 1.4\n */TextMetrics.BASELINE_MULTIPLIER=1.4;/**\n * Height multiplier for setting height of canvas to calculate font metrics.\n *\n * @static\n * @memberof PIXI.TextMetrics\n * @name HEIGHT_MULTIPLIER\n * @type {number}\n * @default 2.00\n */TextMetrics.HEIGHT_MULTIPLIER=2.0;/**\n * Cache of new line chars.\n *\n * @memberof PIXI.TextMetrics\n * @type {number[]}\n * @private\n */TextMetrics._newlines=[0x000A,0x000D];/**\n * Cache of breaking spaces.\n *\n * @memberof PIXI.TextMetrics\n * @type {number[]}\n * @private\n */TextMetrics._breakingSpaces=[0x0009,0x0020,0x2000,0x2001,0x2002,0x2003,0x2004,0x2005,0x2006,0x2008,0x2009,0x200A,0x205F,0x3000];/**\n * A number, or a string containing a number.\n *\n * @memberof PIXI\n * @typedef {object} IFontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */var defaultDestroyOptions={texture:true,children:false,baseTexture:true};/**\n * A Text Object will create a line or multiple lines of text.\n *\n * The text is created using the [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API).\n *\n * The primary advantage of this class over BitmapText is that you have great control over the style of the text,\n * which you can change at runtime.\n *\n * The primary disadvantages is that each piece of text has it's own texture, which can use more memory.\n * When text changes, this texture has to be re-generated and re-uploaded to the GPU, taking up time.\n *\n * To split a line you can use '\\n' in your text string, or, on the `style` object,\n * change its `wordWrap` property to true and and give the `wordWrapWidth` property a value.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n *\n * ```js\n * let text = new PIXI.Text('This is a PixiJS text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});\n * ```\n *\n * @memberof PIXI\n */var Text=/** @class */function(_super){__extends(Text,_super);/**\n     * @param text - The string that you would like the text to display\n     * @param {object|PIXI.TextStyle} [style] - The style parameters\n     * @param canvas - The canvas element for drawing text\n     */function Text(text,style,canvas){var _this=this;var ownCanvas=false;if(!canvas){canvas=document.createElement('canvas');ownCanvas=true;}canvas.width=3;canvas.height=3;var texture=Texture.from(canvas);texture.orig=new Rectangle();texture.trim=new Rectangle();_this=_super.call(this,texture)||this;_this._ownCanvas=ownCanvas;_this.canvas=canvas;_this.context=_this.canvas.getContext('2d');_this._resolution=settings.RESOLUTION;_this._autoResolution=true;_this._text=null;_this._style=null;_this._styleListener=null;_this._font='';_this.text=text;_this.style=style;_this.localStyleID=-1;return _this;}/**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     *\n     * @param respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */Text.prototype.updateText=function(respectDirty){var style=this._style;// check if style has changed..\nif(this.localStyleID!==style.styleID){this.dirty=true;this.localStyleID=style.styleID;}if(!this.dirty&&respectDirty){return;}this._font=this._style.toFontString();var context=this.context;var measured=TextMetrics.measureText(this._text||' ',this._style,this._style.wordWrap,this.canvas);var width=measured.width;var height=measured.height;var lines=measured.lines;var lineHeight=measured.lineHeight;var lineWidths=measured.lineWidths;var maxLineWidth=measured.maxLineWidth;var fontProperties=measured.fontProperties;this.canvas.width=Math.ceil(Math.ceil(Math.max(1,width)+style.padding*2)*this._resolution);this.canvas.height=Math.ceil(Math.ceil(Math.max(1,height)+style.padding*2)*this._resolution);context.scale(this._resolution,this._resolution);context.clearRect(0,0,this.canvas.width,this.canvas.height);context.font=this._font;context.lineWidth=style.strokeThickness;context.textBaseline=style.textBaseline;context.lineJoin=style.lineJoin;context.miterLimit=style.miterLimit;var linePositionX;var linePositionY;// require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\nvar passesCount=style.dropShadow?2:1;// For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n// but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n//\n// For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n// visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n// and the stroke; and fill drop shadows would appear over the top of the stroke.\n//\n// For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n// text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n// drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n// beneath the text, whilst also having the proper text shadow styling.\nfor(var i=0;i<passesCount;++i){var isShadowPass=style.dropShadow&&i===0;// we only want the drop shadow, so put text way off-screen\nvar dsOffsetText=isShadowPass?Math.ceil(Math.max(1,height)+style.padding*2):0;var dsOffsetShadow=dsOffsetText*this._resolution;if(isShadowPass){// On Safari, text with gradient and drop shadows together do not position correctly\n// if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n// Therefore we'll set the styles to be a plain black whilst generating this drop shadow\ncontext.fillStyle='black';context.strokeStyle='black';var dropShadowColor=style.dropShadowColor;var rgb=hex2rgb(typeof dropShadowColor==='number'?dropShadowColor:string2hex(dropShadowColor));var dropShadowBlur=style.dropShadowBlur*this._resolution;var dropShadowDistance=style.dropShadowDistance*this._resolution;context.shadowColor=\"rgba(\"+rgb[0]*255+\",\"+rgb[1]*255+\",\"+rgb[2]*255+\",\"+style.dropShadowAlpha+\")\";context.shadowBlur=dropShadowBlur;context.shadowOffsetX=Math.cos(style.dropShadowAngle)*dropShadowDistance;context.shadowOffsetY=Math.sin(style.dropShadowAngle)*dropShadowDistance+dsOffsetShadow;}else{// set canvas text styles\ncontext.fillStyle=this._generateFillStyle(style,lines,measured);// TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n//       the setter converts to string. See this thread for more details:\n//       https://github.com/microsoft/TypeScript/issues/2521\ncontext.strokeStyle=style.stroke;context.shadowColor='black';context.shadowBlur=0;context.shadowOffsetX=0;context.shadowOffsetY=0;}var linePositionYShift=(lineHeight-fontProperties.fontSize)/2;if(!Text.nextLineHeightBehavior||lineHeight-fontProperties.fontSize<0){linePositionYShift=0;}// draw lines line by line\nfor(var i_1=0;i_1<lines.length;i_1++){linePositionX=style.strokeThickness/2;linePositionY=style.strokeThickness/2+i_1*lineHeight+fontProperties.ascent+linePositionYShift;if(style.align==='right'){linePositionX+=maxLineWidth-lineWidths[i_1];}else if(style.align==='center'){linePositionX+=(maxLineWidth-lineWidths[i_1])/2;}if(style.stroke&&style.strokeThickness){this.drawLetterSpacing(lines[i_1],linePositionX+style.padding,linePositionY+style.padding-dsOffsetText,true);}if(style.fill){this.drawLetterSpacing(lines[i_1],linePositionX+style.padding,linePositionY+style.padding-dsOffsetText);}}}this.updateTexture();};/**\n     * Render the text with letter-spacing.\n     *\n     * @param text - The text to draw\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */Text.prototype.drawLetterSpacing=function(text,x,y,isStroke){if(isStroke===void 0){isStroke=false;}var style=this._style;// letterSpacing of 0 means normal\nvar letterSpacing=style.letterSpacing;// Checking that we can use moddern canvas2D api\n// https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n// note: this is unstable API, Chrome less 94 use a `textLetterSpacing`, newest use a letterSpacing\n// eslint-disable-next-line max-len\nvar supportLetterSpacing=Text.experimentalLetterSpacing&&('letterSpacing'in CanvasRenderingContext2D.prototype||'textLetterSpacing'in CanvasRenderingContext2D.prototype);if(letterSpacing===0||supportLetterSpacing){if(supportLetterSpacing){this.context.letterSpacing=letterSpacing;this.context.textLetterSpacing=letterSpacing;}if(isStroke){this.context.strokeText(text,x,y);}else{this.context.fillText(text,x,y);}return;}var currentPosition=x;// Using Array.from correctly splits characters whilst keeping emoji together.\n// This is not supported on IE as it requires ES6, so regular text splitting occurs.\n// This also doesn't account for emoji that are multiple emoji put together to make something else.\n// Handling all of this would require a big library itself.\n// https://medium.com/@giltayar/iterating-over-emoji-characters-the-es6-way-f06e4589516\n// https://github.com/orling/grapheme-splitter\nvar stringArray=Array.from?Array.from(text):text.split('');var previousWidth=this.context.measureText(text).width;var currentWidth=0;for(var i=0;i<stringArray.length;++i){var currentChar=stringArray[i];if(isStroke){this.context.strokeText(currentChar,currentPosition,y);}else{this.context.fillText(currentChar,currentPosition,y);}var textStr='';for(var j=i+1;j<stringArray.length;++j){textStr+=stringArray[j];}currentWidth=this.context.measureText(textStr).width;currentPosition+=previousWidth-currentWidth+letterSpacing;previousWidth=currentWidth;}};/** Updates texture size based on canvas size. */Text.prototype.updateTexture=function(){var canvas=this.canvas;if(this._style.trim){var trimmed=trimCanvas(canvas);if(trimmed.data){canvas.width=trimmed.width;canvas.height=trimmed.height;this.context.putImageData(trimmed.data,0,0);}}var texture=this._texture;var style=this._style;var padding=style.trim?0:style.padding;var baseTexture=texture.baseTexture;texture.trim.width=texture._frame.width=canvas.width/this._resolution;texture.trim.height=texture._frame.height=canvas.height/this._resolution;texture.trim.x=-padding;texture.trim.y=-padding;texture.orig.width=texture._frame.width-padding*2;texture.orig.height=texture._frame.height-padding*2;// call sprite onTextureUpdate to update scale if _width or _height were set\nthis._onTextureUpdate();baseTexture.setRealSize(canvas.width,canvas.height,this._resolution);texture.updateUvs();// Recursively updates transform of all objects from the root to this one\nthis._recursivePostUpdateTransform();this.dirty=false;};/**\n     * Renders the object using the WebGL renderer\n     *\n     * @param renderer - The renderer\n     */Text.prototype._render=function(renderer){if(this._autoResolution&&this._resolution!==renderer.resolution){this._resolution=renderer.resolution;this.dirty=true;}this.updateText(true);_super.prototype._render.call(this,renderer);};/**\n     * Gets the local bounds of the text object.\n     *\n     * @param rect - The output rectangle.\n     * @return The bounds.\n     */Text.prototype.getLocalBounds=function(rect){this.updateText(true);return _super.prototype.getLocalBounds.call(this,rect);};/** Calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account. */Text.prototype._calculateBounds=function(){this.updateText(true);this.calculateVertices();// if we have already done this on THIS frame.\nthis._bounds.addQuad(this.vertexData);};/**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     *\n     * @param style - The style.\n     * @param lines - The lines of text.\n     * @return The fill style\n     */Text.prototype._generateFillStyle=function(style,lines,metrics){// TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n//       the setter converts to string. See this thread for more details:\n//       https://github.com/microsoft/TypeScript/issues/2521\nvar fillStyle=style.fill;if(!Array.isArray(fillStyle)){return fillStyle;}else if(fillStyle.length===1){return fillStyle[0];}// the gradient will be evenly spaced out according to how large the array is.\n// ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\nvar gradient;// a dropshadow will enlarge the canvas and result in the gradient being\n// generated with the incorrect dimensions\nvar dropShadowCorrection=style.dropShadow?style.dropShadowDistance:0;// should also take padding into account, padding can offset the gradient\nvar padding=style.padding||0;var width=this.canvas.width/this._resolution-dropShadowCorrection-padding*2;var height=this.canvas.height/this._resolution-dropShadowCorrection-padding*2;// make a copy of the style settings, so we can manipulate them later\nvar fill=fillStyle.slice();var fillGradientStops=style.fillGradientStops.slice();// wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\nif(!fillGradientStops.length){var lengthPlus1=fill.length+1;for(var i=1;i<lengthPlus1;++i){fillGradientStops.push(i/lengthPlus1);}}// stop the bleeding of the last gradient on the line above to the top gradient of the this line\n// by hard defining the first gradient colour at point 0, and last gradient colour at point 1\nfill.unshift(fillStyle[0]);fillGradientStops.unshift(0);fill.push(fillStyle[fillStyle.length-1]);fillGradientStops.push(1);if(style.fillGradientType===TEXT_GRADIENT.LINEAR_VERTICAL){// start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\ngradient=this.context.createLinearGradient(width/2,padding,width/2,height+padding);// we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n// ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n// Actual height of the text itself, not counting spacing for lineHeight/leading/dropShadow etc\nvar textHeight=metrics.fontProperties.fontSize+style.strokeThickness;for(var i=0;i<lines.length;i++){var lastLineBottom=metrics.lineHeight*(i-1)+textHeight;var thisLineTop=metrics.lineHeight*i;var thisLineGradientStart=thisLineTop;// Handle case where last & this line overlap\nif(i>0&&lastLineBottom>thisLineTop){thisLineGradientStart=(thisLineTop+lastLineBottom)/2;}var thisLineBottom=thisLineTop+textHeight;var nextLineTop=metrics.lineHeight*(i+1);var thisLineGradientEnd=thisLineBottom;// Handle case where this & next line overlap\nif(i+1<lines.length&&nextLineTop<thisLineBottom){thisLineGradientEnd=(thisLineBottom+nextLineTop)/2;}// textHeight, but as a 0-1 size in global gradient stop space\nvar gradStopLineHeight=(thisLineGradientEnd-thisLineGradientStart)/height;for(var j=0;j<fill.length;j++){// 0-1 stop point for the current line, multiplied to global space afterwards\nvar lineStop=0;if(typeof fillGradientStops[j]==='number'){lineStop=fillGradientStops[j];}else{lineStop=j/fill.length;}var globalStop=Math.min(1,Math.max(0,thisLineGradientStart/height+lineStop*gradStopLineHeight));// There's potential for floating point precision issues at the seams between gradient repeats.\nglobalStop=Number(globalStop.toFixed(5));gradient.addColorStop(globalStop,fill[j]);}}}else{// start the gradient at the center left of the canvas, and end at the center right of the canvas\ngradient=this.context.createLinearGradient(padding,height/2,width+padding,height/2);// can just evenly space out the gradients in this case, as multiple lines makes no difference\n// to an even left to right gradient\nvar totalIterations=fill.length+1;var currentIteration=1;for(var i=0;i<fill.length;i++){var stop=void 0;if(typeof fillGradientStops[i]==='number'){stop=fillGradientStops[i];}else{stop=currentIteration/totalIterations;}gradient.addColorStop(stop,fill[i]);currentIteration++;}}return gradient;};/**\n     * Destroys this text object.\n     *\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     *\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */Text.prototype.destroy=function(options){if(typeof options==='boolean'){options={children:options};}options=Object.assign({},defaultDestroyOptions,options);_super.prototype.destroy.call(this,options);// set canvas width and height to 0 to workaround memory leak in Safari < 13\n// https://stackoverflow.com/questions/52532614/total-canvas-memory-use-exceeds-the-maximum-limit-safari-12\nif(this._ownCanvas){this.canvas.height=this.canvas.width=0;}// make sure to reset the context and canvas.. dont want this hanging around in memory!\nthis.context=null;this.canvas=null;this._style=null;};Object.defineProperty(Text.prototype,\"width\",{/** The width of the Text, setting this will actually modify the scale to achieve the value set. */get:function get(){this.updateText(true);return Math.abs(this.scale.x)*this._texture.orig.width;},set:function set(value){this.updateText(true);var s=sign(this.scale.x)||1;this.scale.x=s*value/this._texture.orig.width;this._width=value;},enumerable:false,configurable:true});Object.defineProperty(Text.prototype,\"height\",{/** The height of the Text, setting this will actually modify the scale to achieve the value set. */get:function get(){this.updateText(true);return Math.abs(this.scale.y)*this._texture.orig.height;},set:function set(value){this.updateText(true);var s=sign(this.scale.y)||1;this.scale.y=s*value/this._texture.orig.height;this._height=value;},enumerable:false,configurable:true});Object.defineProperty(Text.prototype,\"style\",{/**\n         * Set the style of the text.\n         *\n         * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n         */get:function get(){// TODO: Can't have different types for getter and setter. The getter shouldn't have the ITextStyle\n//       since the setter creates the TextStyle. See this thread for more details:\n//       https://github.com/microsoft/TypeScript/issues/2521\nreturn this._style;},set:function set(style){style=style||{};if(style instanceof TextStyle){this._style=style;}else{this._style=new TextStyle(style);}this.localStyleID=-1;this.dirty=true;},enumerable:false,configurable:true});Object.defineProperty(Text.prototype,\"text\",{/** Set the copy for the text object. To split a line you can use '\\n'. */get:function get(){return this._text;},set:function set(text){text=String(text===null||text===undefined?'':text);if(this._text===text){return;}this._text=text;this.dirty=true;},enumerable:false,configurable:true});Object.defineProperty(Text.prototype,\"resolution\",{/**\n         * The resolution / device pixel ratio of the canvas.\n         *\n         * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n         *\n         * @default 1\n         */get:function get(){return this._resolution;},set:function set(value){this._autoResolution=false;if(this._resolution===value){return;}this._resolution=value;this.dirty=true;},enumerable:false,configurable:true});/**\n     * New behavior for `lineHeight` that's meant to mimic HTML text. A value of `true` will\n     * make sure the first baseline is offset by the `lineHeight` value if it is greater than `fontSize`.\n     * A value of `false` will use the legacy behavior and not change the baseline of the first line.\n     * In the next major release, we'll enable this by default.\n     */Text.nextLineHeightBehavior=false;/**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     */Text.experimentalLetterSpacing=false;return Text;}(Sprite);export{TEXT_GRADIENT,Text,TextMetrics,TextStyle};","map":null,"metadata":{},"sourceType":"module"}