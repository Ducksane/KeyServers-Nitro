{"ast":null,"code":"/*!\n * @pixi/canvas-renderer - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/canvas-renderer is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{RenderTexture,BaseRenderTexture,CanvasResource,AbstractRenderer,Renderer,BaseTexture,Texture}from'@pixi/core';import{deprecation,CanvasRenderTarget,hex2string,rgb2hex,sayHello,hex2rgb}from'@pixi/utils';import{SHAPES,Matrix}from'@pixi/math';import{BLEND_MODES,SCALE_MODES,RENDERER_TYPE}from'@pixi/constants';import{settings}from'@pixi/settings';/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */ /* global Reflect, Promise */var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p)){d[p]=b[p];}}};return _extendStatics(d,b);};function __extends(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());}/**\n * A set of functions used to handle masking.\n *\n * Sprite masking is not supported on the CanvasRenderer.\n *\n * @class\n * @memberof PIXI\n */var CanvasMaskManager=/** @class */function(){/** @param renderer - A reference to the current renderer */function CanvasMaskManager(renderer){this._foundShapes=[];this.renderer=renderer;}/**\n     * This method adds it to the current stack of masks.\n     *\n     * @param maskData - the maskData that will be pushed\n     */CanvasMaskManager.prototype.pushMask=function(maskData){var renderer=this.renderer;var maskObject=maskData.maskObject||maskData;renderer.context.save();// TODO support sprite alpha masks??\n// lots of effort required. If demand is great enough..\nvar foundShapes=this._foundShapes;this.recursiveFindShapes(maskObject,foundShapes);if(foundShapes.length>0){var context=renderer.context;context.beginPath();for(var i=0;i<foundShapes.length;i++){var shape=foundShapes[i];var transform=shape.transform.worldTransform;this.renderer.setContextTransform(transform);this.renderGraphicsShape(shape);}foundShapes.length=0;context.clip();}};/**\n     * Renders all PIXI.Graphics shapes in a subtree.\n     *\n     * @param container - container to scan.\n     * @param out - where to put found shapes\n     */CanvasMaskManager.prototype.recursiveFindShapes=function(container,out){if(container.geometry&&container.geometry.graphicsData){out.push(container);}var children=container.children;if(children){for(var i=0;i<children.length;i++){this.recursiveFindShapes(children[i],out);}}};/**\n     * Renders a PIXI.Graphics shape.\n     *\n     * @param graphics - The object to render.\n     */CanvasMaskManager.prototype.renderGraphicsShape=function(graphics){graphics.finishPoly();var context=this.renderer.context;var graphicsData=graphics.geometry.graphicsData;var len=graphicsData.length;if(len===0){return;}for(var i=0;i<len;i++){var data=graphicsData[i];var shape=data.shape;if(shape.type===SHAPES.POLY){var points=shape.points;var holes=data.holes;var outerArea=void 0;var innerArea=void 0;var px=void 0;var py=void 0;context.moveTo(points[0],points[1]);for(var j=1;j<points.length/2;j++){context.lineTo(points[j*2],points[j*2+1]);}if(holes.length>0){outerArea=0;px=points[0];py=points[1];for(var j=2;j+2<points.length;j+=2){outerArea+=(points[j]-px)*(points[j+3]-py)-(points[j+2]-px)*(points[j+1]-py);}for(var k=0;k<holes.length;k++){points=holes[k].shape.points;if(!points){continue;}innerArea=0;px=points[0];py=points[1];for(var j=2;j+2<points.length;j+=2){innerArea+=(points[j]-px)*(points[j+3]-py)-(points[j+2]-px)*(points[j+1]-py);}if(innerArea*outerArea<0){context.moveTo(points[0],points[1]);for(var j=2;j<points.length;j+=2){context.lineTo(points[j],points[j+1]);}}else{context.moveTo(points[points.length-2],points[points.length-1]);for(var j=points.length-4;j>=0;j-=2){context.lineTo(points[j],points[j+1]);}}if(holes[k].shape.closeStroke){context.closePath();}}}// if the first and last point are the same close the path - much neater :)\nif(points[0]===points[points.length-2]&&points[1]===points[points.length-1]){context.closePath();}}else if(shape.type===SHAPES.RECT){context.rect(shape.x,shape.y,shape.width,shape.height);context.closePath();}else if(shape.type===SHAPES.CIRC){// TODO - need to be Undefined!\ncontext.arc(shape.x,shape.y,shape.radius,0,2*Math.PI);context.closePath();}else if(shape.type===SHAPES.ELIP){// ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\nvar w=shape.width*2;var h=shape.height*2;var x=shape.x-w/2;var y=shape.y-h/2;var kappa=0.5522848;var ox=w/2*kappa;// control point offset horizontal\nvar oy=h/2*kappa;// control point offset vertical\nvar xe=x+w;// x-end\nvar ye=y+h;// y-end\nvar xm=x+w/2;// x-middle\nvar ym=y+h/2;// y-middle\ncontext.moveTo(x,ym);context.bezierCurveTo(x,ym-oy,xm-ox,y,xm,y);context.bezierCurveTo(xm+ox,y,xe,ym-oy,xe,ym);context.bezierCurveTo(xe,ym+oy,xm+ox,ye,xm,ye);context.bezierCurveTo(xm-ox,ye,x,ym+oy,x,ym);context.closePath();}else if(shape.type===SHAPES.RREC){var rx=shape.x;var ry=shape.y;var width=shape.width;var height=shape.height;var radius=shape.radius;var maxRadius=Math.min(width,height)/2;radius=radius>maxRadius?maxRadius:radius;context.moveTo(rx,ry+radius);context.lineTo(rx,ry+height-radius);context.quadraticCurveTo(rx,ry+height,rx+radius,ry+height);context.lineTo(rx+width-radius,ry+height);context.quadraticCurveTo(rx+width,ry+height,rx+width,ry+height-radius);context.lineTo(rx+width,ry+radius);context.quadraticCurveTo(rx+width,ry,rx+width-radius,ry);context.lineTo(rx+radius,ry);context.quadraticCurveTo(rx,ry,rx,ry+radius);context.closePath();}}};/**\n     * Restores the current drawing context to the state it was before the mask was applied.\n     *\n     * @param renderer - The renderer context to use.\n     */CanvasMaskManager.prototype.popMask=function(renderer){renderer.context.restore();renderer.invalidateBlendMode();};/** Destroys this canvas mask manager. */CanvasMaskManager.prototype.destroy=function(){/* empty */};return CanvasMaskManager;}();/**\n * Creates a little colored canvas\n *\n * @ignore\n * @param {string} color - The color to make the canvas\n * @return {canvas} a small canvas element\n */function createColoredCanvas(color){var canvas=document.createElement('canvas');canvas.width=6;canvas.height=1;var context=canvas.getContext('2d');context.fillStyle=color;context.fillRect(0,0,6,1);return canvas;}/**\n * Checks whether the Canvas BlendModes are supported by the current browser\n *\n * @private\n * @return {boolean} whether they are supported\n */function canUseNewCanvasBlendModes(){if(typeof document==='undefined'){return false;}var magenta=createColoredCanvas('#ff00ff');var yellow=createColoredCanvas('#ffff00');var canvas=document.createElement('canvas');canvas.width=6;canvas.height=1;var context=canvas.getContext('2d');context.globalCompositeOperation='multiply';context.drawImage(magenta,0,0);context.drawImage(yellow,2,0);var imageData=context.getImageData(2,0,1,1);if(!imageData){return false;}var data=imageData.data;return data[0]===255&&data[1]===0&&data[2]===0;}/**\n * Maps blend combinations to Canvas.\n *\n * @memberof PIXI\n * @function mapCanvasBlendModesToPixi\n * @private\n * @param {string[]} [array=[]] - The array to output into.\n * @return {string[]} Mapped modes.\n */function mapCanvasBlendModesToPixi(array){if(array===void 0){array=[];}if(canUseNewCanvasBlendModes()){array[BLEND_MODES.NORMAL]='source-over';array[BLEND_MODES.ADD]='lighter';// IS THIS OK???\narray[BLEND_MODES.MULTIPLY]='multiply';array[BLEND_MODES.SCREEN]='screen';array[BLEND_MODES.OVERLAY]='overlay';array[BLEND_MODES.DARKEN]='darken';array[BLEND_MODES.LIGHTEN]='lighten';array[BLEND_MODES.COLOR_DODGE]='color-dodge';array[BLEND_MODES.COLOR_BURN]='color-burn';array[BLEND_MODES.HARD_LIGHT]='hard-light';array[BLEND_MODES.SOFT_LIGHT]='soft-light';array[BLEND_MODES.DIFFERENCE]='difference';array[BLEND_MODES.EXCLUSION]='exclusion';array[BLEND_MODES.HUE]='hue';array[BLEND_MODES.SATURATION]='saturate';array[BLEND_MODES.COLOR]='color';array[BLEND_MODES.LUMINOSITY]='luminosity';}else{// this means that the browser does not support the cool new blend modes in canvas 'cough' ie 'cough'\narray[BLEND_MODES.NORMAL]='source-over';array[BLEND_MODES.ADD]='lighter';// IS THIS OK???\narray[BLEND_MODES.MULTIPLY]='source-over';array[BLEND_MODES.SCREEN]='source-over';array[BLEND_MODES.OVERLAY]='source-over';array[BLEND_MODES.DARKEN]='source-over';array[BLEND_MODES.LIGHTEN]='source-over';array[BLEND_MODES.COLOR_DODGE]='source-over';array[BLEND_MODES.COLOR_BURN]='source-over';array[BLEND_MODES.HARD_LIGHT]='source-over';array[BLEND_MODES.SOFT_LIGHT]='source-over';array[BLEND_MODES.DIFFERENCE]='source-over';array[BLEND_MODES.EXCLUSION]='source-over';array[BLEND_MODES.HUE]='source-over';array[BLEND_MODES.SATURATION]='source-over';array[BLEND_MODES.COLOR]='source-over';array[BLEND_MODES.LUMINOSITY]='source-over';}// not-premultiplied, only for webgl\narray[BLEND_MODES.NORMAL_NPM]=array[BLEND_MODES.NORMAL];array[BLEND_MODES.ADD_NPM]=array[BLEND_MODES.ADD];array[BLEND_MODES.SCREEN_NPM]=array[BLEND_MODES.SCREEN];// composite operations\narray[BLEND_MODES.SRC_IN]='source-in';array[BLEND_MODES.SRC_OUT]='source-out';array[BLEND_MODES.SRC_ATOP]='source-atop';array[BLEND_MODES.DST_OVER]='destination-over';array[BLEND_MODES.DST_IN]='destination-in';array[BLEND_MODES.DST_OUT]='destination-out';array[BLEND_MODES.DST_ATOP]='destination-atop';array[BLEND_MODES.XOR]='xor';// SUBTRACT from flash, does not exist in canvas\narray[BLEND_MODES.SUBTRACT]='source-over';return array;}var tempMatrix=new Matrix();/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas.\n *\n * This renderer should be used for browsers that do not support WebGL.\n * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything!\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.AbstractRenderer\n */var CanvasRenderer=/** @class */function(_super){__extends(CanvasRenderer,_super);/**\n     * @param options - The optional renderer parameters\n     * @param {number} [options.width=800] - the width of the screen\n     * @param {number} [options.height=600] - the height of the screen\n     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n     * @param {boolean} [options.useContextAlpha=true] - Pass-through value for canvas' context `alpha` property.\n     *   If you want to set transparency, please use `backgroundAlpha`. This option is for cases where the\n     *   canvas needs to be opaque, possibly for performance reasons on some older devices.\n     * @param {boolean} [options.autoDensity=false] - Resizes renderer view in CSS pixels to allow for\n     *   resolutions other than 1\n     * @param {boolean} [options.antialias=false] - sets antialias\n     * @param {number} [options.resolution=PIXI.settings.RESOLUTION] - The resolution / device pixel ratio of the renderer.\n     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n     *  enable this if you need to call toDataUrl on the webgl context.\n     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or\n     *      not before the new render pass.\n     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n     *  (shown if not transparent).\n     * @param {number} [options.backgroundAlpha=1] - Value from 0 (fully transparent) to 1 (fully opaque).\n     */function CanvasRenderer(options){var _this=_super.call(this,RENDERER_TYPE.CANVAS,options)||this;/** Boolean flag controlling canvas refresh. */_this.refresh=true;/**\n         * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n         * @member {PIXI.CanvasMaskManager}\n         */_this.maskManager=new CanvasMaskManager(_this);/** The canvas property used to set the canvas smoothing property. */_this.smoothProperty='imageSmoothingEnabled';/** Tracks the blend modes useful for this renderer. */_this.blendModes=mapCanvasBlendModesToPixi();_this.renderingToScreen=false;_this._activeBlendMode=null;/** Projection transform, passed in render() stored here */_this._projTransform=null;/** @private */_this._outerBlend=false;_this.rootContext=_this.view.getContext('2d',{alpha:_this.useContextAlpha});_this.context=_this.rootContext;if(!_this.rootContext.imageSmoothingEnabled){var rc=_this.rootContext;if(rc.webkitImageSmoothingEnabled){_this.smoothProperty='webkitImageSmoothingEnabled';}else if(rc.mozImageSmoothingEnabled){_this.smoothProperty='mozImageSmoothingEnabled';}else if(rc.oImageSmoothingEnabled){_this.smoothProperty='oImageSmoothingEnabled';}else if(rc.msImageSmoothingEnabled){_this.smoothProperty='msImageSmoothingEnabled';}}_this.initPlugins(CanvasRenderer.__plugins);sayHello('Canvas');_this.resize(_this.options.width,_this.options.height);return _this;}/**\n     * Adds a new system to the renderer. It does nothing in the CanvasRenderer.\n     */CanvasRenderer.prototype.addSystem=function(){return this;};/** @ignore */CanvasRenderer.prototype.render=function(displayObject,options){if(!this.view){return;}var renderTexture;var clear;var transform;var skipUpdateTransform;if(options){if(options instanceof RenderTexture||options instanceof BaseRenderTexture){deprecation('6.0.0','CanvasRenderer#render arguments changed, use options instead.');/* eslint-disable prefer-rest-params */renderTexture=options;clear=arguments[2];transform=arguments[3];skipUpdateTransform=arguments[4];/* eslint-enable prefer-rest-params */}else{renderTexture=options.renderTexture;clear=options.clear;transform=options.transform;skipUpdateTransform=options.skipUpdateTransform;}}// can be handy to know!\nthis.renderingToScreen=!renderTexture;this.emit('prerender');var rootResolution=this.resolution;if(renderTexture){renderTexture=renderTexture.castToBaseTexture();if(!renderTexture._canvasRenderTarget){renderTexture._canvasRenderTarget=new CanvasRenderTarget(renderTexture.width,renderTexture.height,renderTexture.resolution);renderTexture.resource=new CanvasResource(renderTexture._canvasRenderTarget.canvas);renderTexture.valid=true;}this.context=renderTexture._canvasRenderTarget.context;this.resolution=renderTexture._canvasRenderTarget.resolution;}else{this.context=this.rootContext;}var context=this.context;this._projTransform=transform||null;if(!renderTexture){this._lastObjectRendered=displayObject;}if(!skipUpdateTransform){// update the scene graph\nvar cacheParent=displayObject.enableTempParent();displayObject.updateTransform();displayObject.disableTempParent(cacheParent);}context.save();context.setTransform(1,0,0,1,0,0);context.globalAlpha=1;this._activeBlendMode=BLEND_MODES.NORMAL;this._outerBlend=false;context.globalCompositeOperation=this.blendModes[BLEND_MODES.NORMAL];if(clear!==undefined?clear:this.clearBeforeRender){if(this.renderingToScreen){context.clearRect(0,0,this.width,this.height);if(this.backgroundAlpha>0){context.globalAlpha=this.useContextAlpha?this.backgroundAlpha:1;context.fillStyle=this._backgroundColorString;context.fillRect(0,0,this.width,this.height);context.globalAlpha=1;}}else{renderTexture=renderTexture;renderTexture._canvasRenderTarget.clear();var clearColor=renderTexture.clearColor;if(clearColor[3]>0){context.globalAlpha=this.useContextAlpha?clearColor[3]:1;context.fillStyle=hex2string(rgb2hex(clearColor));context.fillRect(0,0,renderTexture.realWidth,renderTexture.realHeight);context.globalAlpha=1;}}}// TODO RENDER TARGET STUFF HERE..\nvar tempContext=this.context;this.context=context;displayObject.renderCanvas(this);this.context=tempContext;context.restore();this.resolution=rootResolution;this._projTransform=null;this.emit('postrender');};/**\n     * Sets matrix of context.\n     * called only from render() methods\n     * takes care about resolution\n     * @param transform - world matrix of current element\n     * @param roundPixels - whether to round (tx,ty) coords\n     * @param localResolution - If specified, used instead of `renderer.resolution` for local scaling\n     */CanvasRenderer.prototype.setContextTransform=function(transform,roundPixels,localResolution){var mat=transform;var proj=this._projTransform;var resolution=this.resolution;localResolution=localResolution||resolution;if(proj){mat=tempMatrix;mat.copyFrom(transform);mat.prepend(proj);}if(roundPixels){this.context.setTransform(mat.a*localResolution,mat.b*localResolution,mat.c*localResolution,mat.d*localResolution,mat.tx*resolution|0,mat.ty*resolution|0);}else{this.context.setTransform(mat.a*localResolution,mat.b*localResolution,mat.c*localResolution,mat.d*localResolution,mat.tx*resolution,mat.ty*resolution);}};/**\n     * Clear the canvas of renderer.\n     *\n     * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.\n     * @param {number} [alpha] - Alpha to apply to the background fill color.\n     */CanvasRenderer.prototype.clear=function(clearColor,alpha){if(clearColor===void 0){clearColor=this._backgroundColorString;}if(alpha===void 0){alpha=this.backgroundAlpha;}var context=this.context;context.clearRect(0,0,this.width,this.height);if(clearColor){context.globalAlpha=this.useContextAlpha?alpha:1;context.fillStyle=clearColor;context.fillRect(0,0,this.width,this.height);context.globalAlpha=1;}};/**\n     * Sets the blend mode of the renderer.\n     *\n     * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.\n     * @param {boolean} [readyForOuterBlend=false] - Some blendModes are dangerous, they affect outer space of sprite.\n     * Pass `true` only if you are ready to use them.\n     */CanvasRenderer.prototype.setBlendMode=function(blendMode,readyForOuterBlend){var outerBlend=blendMode===BLEND_MODES.SRC_IN||blendMode===BLEND_MODES.SRC_OUT||blendMode===BLEND_MODES.DST_IN||blendMode===BLEND_MODES.DST_ATOP;if(!readyForOuterBlend&&outerBlend){blendMode=BLEND_MODES.NORMAL;}if(this._activeBlendMode===blendMode){return;}this._activeBlendMode=blendMode;this._outerBlend=outerBlend;this.context.globalCompositeOperation=this.blendModes[blendMode];};/**\n     * Removes everything from the renderer and optionally removes the Canvas DOM element.\n     *\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     */CanvasRenderer.prototype.destroy=function(removeView){// call the base destroy\n_super.prototype.destroy.call(this,removeView);this.context=null;this.refresh=true;this.maskManager.destroy();this.maskManager=null;this.smoothProperty=null;};/**\n     * Resizes the canvas view to the specified width and height.\n     *\n     * @extends PIXI.AbstractRenderer#resize\n     *\n     * @param desiredScreenWidth - the desired width of the screen\n     * @param desiredScreenHeight - the desired height of the screen\n     */CanvasRenderer.prototype.resize=function(desiredScreenWidth,desiredScreenHeight){_super.prototype.resize.call(this,desiredScreenWidth,desiredScreenHeight);// reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n// surely a browser bug?? Let PixiJS fix that for you..\nif(this.smoothProperty){this.rootContext[this.smoothProperty]=settings.SCALE_MODE===SCALE_MODES.LINEAR;}};/** Checks if blend mode has changed. */CanvasRenderer.prototype.invalidateBlendMode=function(){this._activeBlendMode=this.blendModes.indexOf(this.context.globalCompositeOperation);};/**\n     * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n     * by creating a custom build. Consult the README for more information about creating custom\n     * builds and excluding plugins.\n     * @member {object} plugins\n     * @readonly\n     * @property {PIXI.AccessibilityManager} accessibility Support tabbing interactive elements.\n     * @property {PIXI.CanvasExtract} extract Extract image data from renderer.\n     * @property {PIXI.InteractionManager} interaction Handles mouse, touch and pointer events.\n     * @property {PIXI.CanvasPrepare} prepare Pre-render display objects.\n     */ /**\n     * Adds a plugin to the renderer.\n     *\n     * @param pluginName - The name of the plugin.\n     * @param ctor - The constructor function or class for the plugin.\n     */CanvasRenderer.registerPlugin=function(pluginName,ctor){CanvasRenderer.__plugins=CanvasRenderer.__plugins||{};CanvasRenderer.__plugins[pluginName]=ctor;};return CanvasRenderer;}(AbstractRenderer);/**\n * Utility methods for Sprite/Texture tinting.\n *\n * Tinting with the CanvasRenderer involves creating a new canvas to use as a texture,\n * so be aware of the performance implications.\n *\n * @namespace PIXI.canvasUtils\n * @memberof PIXI\n */var canvasUtils={canvas:null,/**\n     * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n     *\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Sprite} sprite - the sprite to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @return {HTMLCanvasElement} The tinted canvas\n     */getTintedCanvas:function getTintedCanvas(sprite,color){var texture=sprite.texture;color=canvasUtils.roundColor(color);var stringColor=\"#\"+(\"00000\"+(color|0).toString(16)).slice(-6);texture.tintCache=texture.tintCache||{};var cachedCanvas=texture.tintCache[stringColor];var canvas;if(cachedCanvas){if(cachedCanvas.tintId===texture._updateID){return texture.tintCache[stringColor];}canvas=texture.tintCache[stringColor];}else{canvas=document.createElement('canvas');}canvasUtils.tintMethod(texture,color,canvas);canvas.tintId=texture._updateID;if(canvasUtils.convertTintToImage){// is this better?\nvar tintImage=new Image();tintImage.src=canvas.toDataURL();texture.tintCache[stringColor]=tintImage;}else{texture.tintCache[stringColor]=canvas;}return canvas;},/**\n     * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n     *\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Texture} texture - the sprite to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @return {HTMLCanvasElement} The tinted canvas\n     */getTintedPattern:function getTintedPattern(texture,color){color=canvasUtils.roundColor(color);var stringColor=\"#\"+(\"00000\"+(color|0).toString(16)).slice(-6);texture.patternCache=texture.patternCache||{};var pattern=texture.patternCache[stringColor];if(pattern&&pattern.tintId===texture._updateID){return pattern;}if(!canvasUtils.canvas){canvasUtils.canvas=document.createElement('canvas');}canvasUtils.tintMethod(texture,color,canvasUtils.canvas);pattern=canvasUtils.canvas.getContext('2d').createPattern(canvasUtils.canvas,'repeat');pattern.tintId=texture._updateID;texture.patternCache[stringColor]=pattern;return pattern;},/**\n     * Tint a texture using the 'multiply' operation.\n     *\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */tintWithMultiply:function tintWithMultiply(texture,color,canvas){var context=canvas.getContext('2d');var crop=texture._frame.clone();var resolution=texture.baseTexture.resolution;crop.x*=resolution;crop.y*=resolution;crop.width*=resolution;crop.height*=resolution;canvas.width=Math.ceil(crop.width);canvas.height=Math.ceil(crop.height);context.save();context.fillStyle=\"#\"+(\"00000\"+(color|0).toString(16)).slice(-6);context.fillRect(0,0,crop.width,crop.height);context.globalCompositeOperation='multiply';var source=texture.baseTexture.getDrawableSource();context.drawImage(source,crop.x,crop.y,crop.width,crop.height,0,0,crop.width,crop.height);context.globalCompositeOperation='destination-atop';context.drawImage(source,crop.x,crop.y,crop.width,crop.height,0,0,crop.width,crop.height);context.restore();},/**\n     * Tint a texture using the 'overlay' operation.\n     *\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */tintWithOverlay:function tintWithOverlay(texture,color,canvas){var context=canvas.getContext('2d');var crop=texture._frame.clone();var resolution=texture.baseTexture.resolution;crop.x*=resolution;crop.y*=resolution;crop.width*=resolution;crop.height*=resolution;canvas.width=Math.ceil(crop.width);canvas.height=Math.ceil(crop.height);context.save();context.globalCompositeOperation='copy';context.fillStyle=\"#\"+(\"00000\"+(color|0).toString(16)).slice(-6);context.fillRect(0,0,crop.width,crop.height);context.globalCompositeOperation='destination-atop';context.drawImage(texture.baseTexture.getDrawableSource(),crop.x,crop.y,crop.width,crop.height,0,0,crop.width,crop.height);// context.globalCompositeOperation = 'copy';\ncontext.restore();},/**\n     * Tint a texture pixel per pixel.\n     *\n     * @memberof PIXI.canvasUtils\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */tintWithPerPixel:function tintWithPerPixel(texture,color,canvas){var context=canvas.getContext('2d');var crop=texture._frame.clone();var resolution=texture.baseTexture.resolution;crop.x*=resolution;crop.y*=resolution;crop.width*=resolution;crop.height*=resolution;canvas.width=Math.ceil(crop.width);canvas.height=Math.ceil(crop.height);context.save();context.globalCompositeOperation='copy';context.drawImage(texture.baseTexture.getDrawableSource(),crop.x,crop.y,crop.width,crop.height,0,0,crop.width,crop.height);context.restore();var rgbValues=hex2rgb(color);var r=rgbValues[0];var g=rgbValues[1];var b=rgbValues[2];var pixelData=context.getImageData(0,0,crop.width,crop.height);var pixels=pixelData.data;for(var i=0;i<pixels.length;i+=4){pixels[i+0]*=r;pixels[i+1]*=g;pixels[i+2]*=b;}context.putImageData(pixelData,0,0);},/**\n     * Rounds the specified color according to the canvasUtils.cacheStepsPerColorChannel.\n     *\n     * @memberof PIXI.canvasUtils\n     * @param {number} color - the color to round, should be a hex color\n     * @return {number} The rounded color.\n     */roundColor:function roundColor(color){var step=canvasUtils.cacheStepsPerColorChannel;var rgbValues=hex2rgb(color);rgbValues[0]=Math.min(255,rgbValues[0]/step*step);rgbValues[1]=Math.min(255,rgbValues[1]/step*step);rgbValues[2]=Math.min(255,rgbValues[2]/step*step);return rgb2hex(rgbValues);},/**\n     * Number of steps which will be used as a cap when rounding colors.\n     *\n     * @memberof PIXI.canvasUtils\n     * @type {number}\n     */cacheStepsPerColorChannel:8,/**\n     * Tint cache boolean flag.\n     *\n     * @memberof PIXI.canvasUtils\n     * @type {boolean}\n     */convertTintToImage:false,/**\n     * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n     *\n     * @memberof PIXI.canvasUtils\n     * @type {boolean}\n     */canUseMultiply:canUseNewCanvasBlendModes(),/**\n     * The tinting method that will be used.\n     *\n     * @memberof PIXI.canvasUtils\n     * @type {Function}\n     */tintMethod:null};canvasUtils.tintMethod=canvasUtils.canUseMultiply?canvasUtils.tintWithMultiply:canvasUtils.tintWithPerPixel;// Reference to Renderer.create static function\nvar parentCreate=Renderer.create;/**\n * Override the Renderer.create to fallback to use CanvasRenderer.\n * Also supports forceCanvas option with Application or autoDetectRenderer.\n * @private\n */Renderer.create=function create(options){var forceCanvas=options&&options.forceCanvas;if(!forceCanvas){try{return parentCreate(options);}catch(err){// swallow WebGL-unsupported error\n}}return new CanvasRenderer(options);};/**\n * Get the drawable source, such as HTMLCanvasElement or HTMLImageElement suitable\n * for rendering with CanvasRenderer. Provided by **@pixi/canvas-renderer** package.\n * @method getDrawableSource\n * @memberof PIXI.BaseTexture#\n * @return {PIXI.ICanvasImageSource} Source to render with CanvasRenderer\n */BaseTexture.prototype.getDrawableSource=function getDrawableSource(){var resource=this.resource;return resource?resource.bitmap||resource.source:null;};/**\n * A reference to the canvas render target (we only need one as this can be shared across renderers)\n *\n * @protected\n * @member {PIXI.utils.CanvasRenderTarget} _canvasRenderTarget\n * @memberof PIXI.BaseRenderTexture#\n */BaseRenderTexture.prototype._canvasRenderTarget=null;Texture.prototype.patternCache=null;Texture.prototype.tintCache=null;export{CanvasRenderer,canUseNewCanvasBlendModes,canvasUtils};","map":null,"metadata":{},"sourceType":"module"}