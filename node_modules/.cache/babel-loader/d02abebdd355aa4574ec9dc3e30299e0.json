{"ast":null,"code":"/*!\n * @pixi/graphics-extras - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/graphics-extras is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{Graphics}from'@pixi/graphics';import{Polygon,PI_2}from'@pixi/math';/**\n * Draw a torus shape, like a donut. Can be used for something like a circle loader.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n *\n * @method PIXI.Graphics#drawTorus\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} innerRadius - Inner circle radius\n * @param {number} outerRadius - Outer circle radius\n * @param {number} [startArc=0] - Where to begin sweep, in radians, 0.0 = to the right\n * @param {number} [endArc=Math.PI*2] - Where to end sweep, in radians\n * @return {PIXI.Graphics}\n */function drawTorus(x,y,innerRadius,outerRadius,startArc,endArc){if(startArc===void 0){startArc=0;}if(endArc===void 0){endArc=Math.PI*2;}if(Math.abs(endArc-startArc)>=Math.PI*2){return this.drawCircle(x,y,outerRadius).beginHole().drawCircle(x,y,innerRadius).endHole();}this.finishPoly();this.arc(x,y,innerRadius,endArc,startArc,true).arc(x,y,outerRadius,startArc,endArc,false).finishPoly();return this;}/**\n * Draw Rectangle with chamfer corners. These are angled corners.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n *\n * @method PIXI.Graphics#drawChamferRect\n * @param {number} x - Upper left corner of rect\n * @param {number} y - Upper right corner of rect\n * @param {number} width - Width of rect\n * @param {number} height - Height of rect\n * @param {number} chamfer - non-zero real number, size of corner cutout\n * @return {PIXI.Graphics} Returns self.\n */function drawChamferRect(x,y,width,height,chamfer){if(chamfer<=0){return this.drawRect(x,y,width,height);}var inset=Math.min(chamfer,Math.min(width,height)/2);var right=x+width;var bottom=y+height;var points=[x+inset,y,right-inset,y,right,y+inset,right,bottom-inset,right-inset,bottom,x+inset,bottom,x,bottom-inset,x,y+inset];// Remove overlapping points\nfor(var i=points.length-1;i>=2;i-=2){if(points[i]===points[i-2]&&points[i-1]===points[i-3]){points.splice(i-1,2);}}return this.drawPolygon(points);}/**\n * Draw Rectangle with fillet corners. This is much like rounded rectangle\n * however it support negative numbers as well for the corner radius.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n *\n * @method PIXI.Graphics#drawFilletRect\n * @param {number} x - Upper left corner of rect\n * @param {number} y - Upper right corner of rect\n * @param {number} width - Width of rect\n * @param {number} height - Height of rect\n * @param {number} fillet - accept negative or positive values\n * @return {PIXI.Graphics} Returns self.\n */function drawFilletRect(x,y,width,height,fillet){if(fillet===0){return this.drawRect(x,y,width,height);}var maxFillet=Math.min(width,height)/2;var inset=Math.min(maxFillet,Math.max(-maxFillet,fillet));var right=x+width;var bottom=y+height;var dir=inset<0?-inset:0;var size=Math.abs(inset);return this.moveTo(x,y+size).arcTo(x+dir,y+dir,x+size,y,size).lineTo(right-size,y).arcTo(right-dir,y+dir,right,y+size,size).lineTo(right,bottom-size).arcTo(right-dir,bottom-dir,x+width-size,bottom,size).lineTo(x+size,bottom).arcTo(x+dir,bottom-dir,x,bottom-size,size).closePath();}/**\n * Draw a regular polygon where all sides are the same length.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n *\n * @method PIXI.Graphics#drawRegularPolygon\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} radius - Polygon radius\n * @param {number} sides - Minimum value is 3\n * @param {number} rotation - Starting rotation values in radians..\n * @return {PIXI.Graphics}\n */function drawRegularPolygon(x,y,radius,sides,rotation){if(rotation===void 0){rotation=0;}sides=Math.max(sides|0,3);var startAngle=-1*Math.PI/2+rotation;var delta=Math.PI*2/sides;var polygon=[];for(var i=0;i<sides;i++){var angle=i*delta+startAngle;polygon.push(x+radius*Math.cos(angle),y+radius*Math.sin(angle));}return this.drawPolygon(polygon);}/**\n * Draw a regular polygon with rounded corners.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n *\n * @method PIXI.Graphics#drawRoundedPolygon\n * @param {number} x - X position\n * @param {number} y - Y position\n * @param {number} radius - Polygon radius\n * @param {number} sides - Minimum value is 3\n * @param {number} corner - Corner size in pixels.\n * @param {number} rotation - Starting rotation values in radians..\n * @return {PIXI.Graphics}\n */function drawRoundedPolygon(x,y,radius,sides,corner,rotation){if(rotation===void 0){rotation=0;}sides=Math.max(sides|0,3);if(corner<=0){return this.drawRegularPolygon(x,y,radius,sides,rotation);}var sideLength=radius*Math.sin(Math.PI/sides)-0.001;corner=Math.min(corner,sideLength);var startAngle=-1*Math.PI/2+rotation;var delta=Math.PI*2/sides;var internalAngle=(sides-2)*Math.PI/sides/2;for(var i=0;i<sides;i++){var angle=i*delta+startAngle;var x0=x+radius*Math.cos(angle);var y0=y+radius*Math.sin(angle);var a1=angle+Math.PI+internalAngle;var a2=angle-Math.PI-internalAngle;var x1=x0+corner*Math.cos(a1);var y1=y0+corner*Math.sin(a1);var x3=x0+corner*Math.cos(a2);var y3=y0+corner*Math.sin(a2);if(i===0){this.moveTo(x1,y1);}else{this.lineTo(x1,y1);}this.quadraticCurveTo(x0,y0,x3,y3);}return this.closePath();}/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */ /* global Reflect, Promise */var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p)){d[p]=b[p];}}};return _extendStatics(d,b);};function __extends(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());}/**\n * Draw a star shape with an arbitrary number of points.\n *\n * @ignore\n */var Star=/** @class */function(_super){__extends(Star,_super);/**\n     * @param x - Center X position of the star\n     * @param y - Center Y position of the star\n     * @param points - The number of points of the star, must be > 1\n     * @param radius - The outer radius of the star\n     * @param innerRadius - The inner radius between points, default half `radius`\n     * @param rotation - The rotation of the star in radians, where 0 is vertical\n     */function Star(x,y,points,radius,innerRadius,rotation){if(rotation===void 0){rotation=0;}var _this=this;innerRadius=innerRadius||radius/2;var startAngle=-1*Math.PI/2+rotation;var len=points*2;var delta=PI_2/len;var polygon=[];for(var i=0;i<len;i++){var r=i%2?innerRadius:radius;var angle=i*delta+startAngle;polygon.push(x+r*Math.cos(angle),y+r*Math.sin(angle));}_this=_super.call(this,polygon)||this;return _this;}return Star;}(Polygon);/**\n * Draw a star shape with an arbitrary number of points.\n *\n * _Note: Only available with **@pixi/graphics-extras**._\n *\n * @method PIXI.Graphics#drawStar\n * @param x - Center X position of the star\n * @param y - Center Y position of the star\n * @param points - The number of points of the star, must be > 1\n * @param radius - The outer radius of the star\n * @param innerRadius - The inner radius between points, default half `radius`\n * @param rotation - The rotation of the star in radians, where 0 is vertical\n * @return - This Graphics object. Good for chaining method calls\n */function drawStar(x,y,points,radius,innerRadius,rotation){if(rotation===void 0){rotation=0;}return this.drawPolygon(new Star(x,y,points,radius,innerRadius,rotation));}// Assign extras to Graphics\nObject.defineProperties(Graphics.prototype,{drawTorus:{value:drawTorus},drawChamferRect:{value:drawChamferRect},drawFilletRect:{value:drawFilletRect},drawRegularPolygon:{value:drawRegularPolygon},drawRoundedPolygon:{value:drawRoundedPolygon},drawStar:{value:drawStar}});","map":null,"metadata":{},"sourceType":"module"}