{"ast":null,"code":"/*!\n * @pixi/spritesheet - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{Rectangle}from'@pixi/math';import{Texture,BaseTexture}from'@pixi/core';import{getResolutionOfUrl,url}from'@pixi/utils';import{LoaderResource}from'@pixi/loaders';/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @memberof PIXI\n */var Spritesheet=/** @class */function(){/**\n     * @param baseTexture - Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param resolutionFilename - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */function Spritesheet(texture,data,resolutionFilename){if(resolutionFilename===void 0){resolutionFilename=null;}this._texture=texture instanceof Texture?texture:null;this.baseTexture=texture instanceof BaseTexture?texture:this._texture.baseTexture;this.textures={};this.animations={};this.data=data;var resource=this.baseTexture.resource;this.resolution=this._updateResolution(resolutionFilename||(resource?resource.url:null));this._frames=this.data.frames;this._frameKeys=Object.keys(this._frames);this._batchIndex=0;this._callback=null;}/**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     *\n     * @param resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @return Resolution to use for spritesheet.\n     */Spritesheet.prototype._updateResolution=function(resolutionFilename){if(resolutionFilename===void 0){resolutionFilename=null;}var scale=this.data.meta.scale;// Use a defaultValue of `null` to check if a url-based resolution is set\nvar resolution=getResolutionOfUrl(resolutionFilename,null);// No resolution found via URL\nif(resolution===null){// Use the scale value or default to 1\nresolution=scale!==undefined?parseFloat(scale):1;}// For non-1 resolutions, update baseTexture\nif(resolution!==1){this.baseTexture.setResolution(resolution);}return resolution;};/**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     *\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */Spritesheet.prototype.parse=function(callback){this._batchIndex=0;this._callback=callback;if(this._frameKeys.length<=Spritesheet.BATCH_SIZE){this._processFrames(0);this._processAnimations();this._parseComplete();}else{this._nextBatch();}};/**\n     * Process a batch of frames\n     *\n     * @param initialFrameIndex - The index of frame to start.\n     */Spritesheet.prototype._processFrames=function(initialFrameIndex){var frameIndex=initialFrameIndex;var maxFrames=Spritesheet.BATCH_SIZE;while(frameIndex-initialFrameIndex<maxFrames&&frameIndex<this._frameKeys.length){var i=this._frameKeys[frameIndex];var data=this._frames[i];var rect=data.frame;if(rect){var frame=null;var trim=null;var sourceSize=data.trimmed!==false&&data.sourceSize?data.sourceSize:data.frame;var orig=new Rectangle(0,0,Math.floor(sourceSize.w)/this.resolution,Math.floor(sourceSize.h)/this.resolution);if(data.rotated){frame=new Rectangle(Math.floor(rect.x)/this.resolution,Math.floor(rect.y)/this.resolution,Math.floor(rect.h)/this.resolution,Math.floor(rect.w)/this.resolution);}else{frame=new Rectangle(Math.floor(rect.x)/this.resolution,Math.floor(rect.y)/this.resolution,Math.floor(rect.w)/this.resolution,Math.floor(rect.h)/this.resolution);}//  Check to see if the sprite is trimmed\nif(data.trimmed!==false&&data.spriteSourceSize){trim=new Rectangle(Math.floor(data.spriteSourceSize.x)/this.resolution,Math.floor(data.spriteSourceSize.y)/this.resolution,Math.floor(rect.w)/this.resolution,Math.floor(rect.h)/this.resolution);}this.textures[i]=new Texture(this.baseTexture,frame,orig,trim,data.rotated?2:0,data.anchor);// lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\nTexture.addToCache(this.textures[i],i);}frameIndex++;}};/** Parse animations config. */Spritesheet.prototype._processAnimations=function(){var animations=this.data.animations||{};for(var animName in animations){this.animations[animName]=[];for(var i=0;i<animations[animName].length;i++){var frameName=animations[animName][i];this.animations[animName].push(this.textures[frameName]);}}};/** The parse has completed. */Spritesheet.prototype._parseComplete=function(){var callback=this._callback;this._callback=null;this._batchIndex=0;callback.call(this,this.textures);};/** Begin the next batch of textures. */Spritesheet.prototype._nextBatch=function(){var _this=this;this._processFrames(this._batchIndex*Spritesheet.BATCH_SIZE);this._batchIndex++;setTimeout(function(){if(_this._batchIndex*Spritesheet.BATCH_SIZE<_this._frameKeys.length){_this._nextBatch();}else{_this._processAnimations();_this._parseComplete();}},0);};/**\n     * Destroy Spritesheet and don't use after this.\n     *\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */Spritesheet.prototype.destroy=function(destroyBase){var _a;if(destroyBase===void 0){destroyBase=false;}for(var i in this.textures){this.textures[i].destroy();}this._frames=null;this._frameKeys=null;this.data=null;this.textures=null;if(destroyBase){(_a=this._texture)===null||_a===void 0?void 0:_a.destroy();this.baseTexture.destroy();}this._texture=null;this.baseTexture=null;};/** The maximum number of Textures to build per process. */Spritesheet.BATCH_SIZE=1000;return Spritesheet;}();/**\n * Reference to Spritesheet object created.\n * @member {PIXI.Spritesheet} spritesheet\n * @memberof PIXI.LoaderResource\n * @instance\n */ /**\n * Dictionary of textures from Spritesheet.\n * @member {object<string, PIXI.Texture>} textures\n * @memberof PIXI.LoaderResource\n * @instance\n */ /**\n * {@link PIXI.Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * If you're using Webpack or other bundlers and plan on bundling the atlas' JSON,\n * use the {@link PIXI.Spritesheet} class to directly parse the JSON.\n *\n * The Loader's image Resource name is automatically appended with `\"_image\"`.\n * If a Resource with this name is already loaded, the Loader will skip parsing the\n * Spritesheet. The code below will generate an internal Loader Resource called `\"myatlas_image\"`.\n *\n * @example\n * loader.add('myatlas', 'path/to/myatlas.json');\n * loader.load(() => {\n *   loader.resources.myatlas; // atlas JSON resource\n *   loader.resources.myatlas_image; // atlas Image resource\n * });\n *\n * @memberof PIXI\n */var SpritesheetLoader=/** @class */function(){function SpritesheetLoader(){}/**\n     * Called after a resource is loaded.\n     *\n     * @see PIXI.Loader.loaderMiddleware\n     * @param resource\n     * @param next\n     */SpritesheetLoader.use=function(resource,next){var _a,_b;// because this is middleware, it execute in loader context. `this` = loader\nvar loader=this;var imageResourceName=resource.name+\"_image\";// skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\nif(!resource.data||resource.type!==LoaderResource.TYPE.JSON||!resource.data.frames||loader.resources[imageResourceName]){next();return;}// Check and add the multi atlas\n// Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n// eslint-disable-next-line camelcase\nvar multiPacks=(_b=(_a=resource.data)===null||_a===void 0?void 0:_a.meta)===null||_b===void 0?void 0:_b.related_multi_packs;if(Array.isArray(multiPacks)){var _loop_1=function _loop_1(item){if(typeof item!=='string'){return\"continue\";}var itemName=item.replace('.json','');var itemUrl=url.resolve(resource.url.replace(loader.baseUrl,''),item);// Check if the file wasn't already added as multipacks are redundant\nif(loader.resources[itemName]||Object.values(loader.resources).some(function(r){return url.format(url.parse(r.url))===itemUrl;})){return\"continue\";}var options={crossOrigin:resource.crossOrigin,loadType:LoaderResource.LOAD_TYPE.XHR,xhrType:LoaderResource.XHR_RESPONSE_TYPE.JSON,parentResource:resource,metadata:resource.metadata};loader.add(itemName,itemUrl,options);};for(var _i=0,multiPacks_1=multiPacks;_i<multiPacks_1.length;_i++){var item=multiPacks_1[_i];_loop_1(item);}}var loadOptions={crossOrigin:resource.crossOrigin,metadata:resource.metadata.imageMetadata,parentResource:resource};var resourcePath=SpritesheetLoader.getResourcePath(resource,loader.baseUrl);// load the image for this sheet\nloader.add(imageResourceName,resourcePath,loadOptions,function onImageLoad(res){if(res.error){next(res.error);return;}var spritesheet=new Spritesheet(res.texture,resource.data,resource.url);spritesheet.parse(function(){resource.spritesheet=spritesheet;resource.textures=spritesheet.textures;next();});});};/**\n     * Get the spritesheets root path\n     *\n     * @param resource - Resource to check path\n     * @param baseUrl - Base root url\n     */SpritesheetLoader.getResourcePath=function(resource,baseUrl){// Prepend url path unless the resource image is a data url\nif(resource.isDataUrl){return resource.data.meta.image;}return url.resolve(resource.url.replace(baseUrl,''),resource.data.meta.image);};return SpritesheetLoader;}();export{Spritesheet,SpritesheetLoader};","map":null,"metadata":{},"sourceType":"module"}