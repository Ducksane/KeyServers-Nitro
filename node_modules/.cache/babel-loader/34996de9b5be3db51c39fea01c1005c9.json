{"ast":null,"code":"/*!\n * @pixi/math - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/math is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */ /**\n * Two Pi.\n *\n * @static\n * @member {number}\n * @memberof PIXI\n */var PI_2=Math.PI*2;/**\n * Conversion factor for converting radians to degrees.\n *\n * @static\n * @member {number} RAD_TO_DEG\n * @memberof PIXI\n */var RAD_TO_DEG=180/Math.PI;/**\n * Conversion factor for converting degrees to radians.\n *\n * @static\n * @member {number}\n * @memberof PIXI\n */var DEG_TO_RAD=Math.PI/180;/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n *\n * @static\n * @memberof PIXI\n * @enum {number}\n * @property {number} POLY Polygon\n * @property {number} RECT Rectangle\n * @property {number} CIRC Circle\n * @property {number} ELIP Ellipse\n * @property {number} RREC Rounded Rectangle\n */var SHAPES;(function(SHAPES){SHAPES[SHAPES[\"POLY\"]=0]=\"POLY\";SHAPES[SHAPES[\"RECT\"]=1]=\"RECT\";SHAPES[SHAPES[\"CIRC\"]=2]=\"CIRC\";SHAPES[SHAPES[\"ELIP\"]=3]=\"ELIP\";SHAPES[SHAPES[\"RREC\"]=4]=\"RREC\";})(SHAPES||(SHAPES={}));/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis\n *\n * @class\n * @memberof PIXI\n * @implements IPoint\n */var Point=/** @class */function(){/** Creates a new `Point`\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */function Point(x,y){if(x===void 0){x=0;}if(y===void 0){y=0;}/** Position of the point on the x axis */this.x=0;/** Position of the point on the y axis */this.y=0;this.x=x;this.y=y;}/** Creates a clone of this point\n     * @returns A clone of this point\n     */Point.prototype.clone=function(){return new Point(this.x,this.y);};/**\n     * Copies `x` and `y` from the given point into this point\n     *\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     */Point.prototype.copyFrom=function(p){this.set(p.x,p.y);return this;};/**\n     * Copies this point's x and y into the given point (`p`).\n     *\n     * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\n     * @returns The point (`p`) with values updated\n     */Point.prototype.copyTo=function(p){p.set(this.x,this.y);return p;};/**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     *\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */Point.prototype.equals=function(p){return p.x===this.x&&p.y===this.y;};/**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     *\n     * @param {number} [x=0] - position of the point on the `x` axis\n     * @param {number} [y=x] - position of the point on the `y` axis\n     * @returns The point instance itself\n     */Point.prototype.set=function(x,y){if(x===void 0){x=0;}if(y===void 0){y=x;}this.x=x;this.y=y;return this;};Point.prototype.toString=function(){return\"[@pixi/math:Point x=\"+this.x+\" y=\"+this.y+\"]\";};return Point;}();var tempPoints=[new Point(),new Point(),new Point(),new Point()];/**\n * Size object, contains width and height\n *\n * @memberof PIXI\n * @typedef {object} ISize\n */ /**\n * Rectangle object is an area defined by its position, as indicated by its top-left corner\n * point (x, y) and by its width and its height.\n *\n * @memberof PIXI\n */var Rectangle=/** @class */function(){/**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */function Rectangle(x,y,width,height){if(x===void 0){x=0;}if(y===void 0){y=0;}if(width===void 0){width=0;}if(height===void 0){height=0;}this.x=Number(x);this.y=Number(y);this.width=Number(width);this.height=Number(height);this.type=SHAPES.RECT;}Object.defineProperty(Rectangle.prototype,\"left\",{/** Returns the left edge of the rectangle. */get:function get(){return this.x;},enumerable:false,configurable:true});Object.defineProperty(Rectangle.prototype,\"right\",{/** Returns the right edge of the rectangle. */get:function get(){return this.x+this.width;},enumerable:false,configurable:true});Object.defineProperty(Rectangle.prototype,\"top\",{/** Returns the top edge of the rectangle. */get:function get(){return this.y;},enumerable:false,configurable:true});Object.defineProperty(Rectangle.prototype,\"bottom\",{/** Returns the bottom edge of the rectangle. */get:function get(){return this.y+this.height;},enumerable:false,configurable:true});Object.defineProperty(Rectangle,\"EMPTY\",{/** A constant empty rectangle. */get:function get(){return new Rectangle(0,0,0,0);},enumerable:false,configurable:true});/**\n     * Creates a clone of this Rectangle\n     *\n     * @return a copy of the rectangle\n     */Rectangle.prototype.clone=function(){return new Rectangle(this.x,this.y,this.width,this.height);};/**\n     * Copies another rectangle to this one.\n     *\n     * @param rectangle - The rectangle to copy from.\n     * @return Returns itself.\n     */Rectangle.prototype.copyFrom=function(rectangle){this.x=rectangle.x;this.y=rectangle.y;this.width=rectangle.width;this.height=rectangle.height;return this;};/**\n     * Copies this rectangle to another one.\n     *\n     * @param rectangle - The rectangle to copy to.\n     * @return Returns given parameter.\n     */Rectangle.prototype.copyTo=function(rectangle){rectangle.x=this.x;rectangle.y=this.y;rectangle.width=this.width;rectangle.height=this.height;return rectangle;};/**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     *\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @return Whether the x/y coordinates are within this Rectangle\n     */Rectangle.prototype.contains=function(x,y){if(this.width<=0||this.height<=0){return false;}if(x>=this.x&&x<this.x+this.width){if(y>=this.y&&y<this.y+this.height){return true;}}return false;};/**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     *\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */Rectangle.prototype.intersects=function(other,transform){if(!transform){var x0_1=this.x<other.x?other.x:this.x;var x1_1=this.right>other.right?other.right:this.right;if(x1_1<=x0_1){return false;}var y0_1=this.y<other.y?other.y:this.y;var y1_1=this.bottom>other.bottom?other.bottom:this.bottom;return y1_1>y0_1;}var x0=this.left;var x1=this.right;var y0=this.top;var y1=this.bottom;if(x1<=x0||y1<=y0){return false;}var lt=tempPoints[0].set(other.left,other.top);var lb=tempPoints[1].set(other.left,other.bottom);var rt=tempPoints[2].set(other.right,other.top);var rb=tempPoints[3].set(other.right,other.bottom);if(rt.x<=lt.x||lb.y<=lt.y){return false;}var s=Math.sign(transform.a*transform.d-transform.b*transform.c);if(s===0){return false;}transform.apply(lt,lt);transform.apply(lb,lb);transform.apply(rt,rt);transform.apply(rb,rb);if(Math.max(lt.x,lb.x,rt.x,rb.x)<=x0||Math.min(lt.x,lb.x,rt.x,rb.x)>=x1||Math.max(lt.y,lb.y,rt.y,rb.y)<=y0||Math.min(lt.y,lb.y,rt.y,rb.y)>=y1){return false;}var nx=s*(lb.y-lt.y);var ny=s*(lt.x-lb.x);var n00=nx*x0+ny*y0;var n10=nx*x1+ny*y0;var n01=nx*x0+ny*y1;var n11=nx*x1+ny*y1;if(Math.max(n00,n10,n01,n11)<=nx*lt.x+ny*lt.y||Math.min(n00,n10,n01,n11)>=nx*rb.x+ny*rb.y){return false;}var mx=s*(lt.y-rt.y);var my=s*(rt.x-lt.x);var m00=mx*x0+my*y0;var m10=mx*x1+my*y0;var m01=mx*x0+my*y1;var m11=mx*x1+my*y1;if(Math.max(m00,m10,m01,m11)<=mx*lt.x+my*lt.y||Math.min(m00,m10,m01,m11)>=mx*rb.x+my*rb.y){return false;}return true;};/**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     *\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     * @return Returns itself.\n     */Rectangle.prototype.pad=function(paddingX,paddingY){if(paddingX===void 0){paddingX=0;}if(paddingY===void 0){paddingY=paddingX;}this.x-=paddingX;this.y-=paddingY;this.width+=paddingX*2;this.height+=paddingY*2;return this;};/**\n     * Fits this rectangle around the passed one.\n     *\n     * @param rectangle - The rectangle to fit.\n     * @return Returns itself.\n     */Rectangle.prototype.fit=function(rectangle){var x1=Math.max(this.x,rectangle.x);var x2=Math.min(this.x+this.width,rectangle.x+rectangle.width);var y1=Math.max(this.y,rectangle.y);var y2=Math.min(this.y+this.height,rectangle.y+rectangle.height);this.x=x1;this.width=Math.max(x2-x1,0);this.y=y1;this.height=Math.max(y2-y1,0);return this;};/**\n     * Enlarges rectangle that way its corners lie on grid\n     *\n     * @param resolution - resolution\n     * @param eps - precision\n     * @return Returns itself.\n     */Rectangle.prototype.ceil=function(resolution,eps){if(resolution===void 0){resolution=1;}if(eps===void 0){eps=0.001;}var x2=Math.ceil((this.x+this.width-eps)*resolution)/resolution;var y2=Math.ceil((this.y+this.height-eps)*resolution)/resolution;this.x=Math.floor((this.x+eps)*resolution)/resolution;this.y=Math.floor((this.y+eps)*resolution)/resolution;this.width=x2-this.x;this.height=y2-this.y;return this;};/**\n     * Enlarges this rectangle to include the passed rectangle.\n     *\n     * @param rectangle - The rectangle to include.\n     * @return Returns itself.\n     */Rectangle.prototype.enlarge=function(rectangle){var x1=Math.min(this.x,rectangle.x);var x2=Math.max(this.x+this.width,rectangle.x+rectangle.width);var y1=Math.min(this.y,rectangle.y);var y2=Math.max(this.y+this.height,rectangle.y+rectangle.height);this.x=x1;this.width=x2-x1;this.y=y1;this.height=y2-y1;return this;};Rectangle.prototype.toString=function(){return\"[@pixi/math:Rectangle x=\"+this.x+\" y=\"+this.y+\" width=\"+this.width+\" height=\"+this.height+\"]\";};return Rectangle;}();/**\n * The Circle object is used to help draw graphics and can also be used to specify a hit area for displayObjects.\n *\n * @memberof PIXI\n */var Circle=/** @class */function(){/**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */function Circle(x,y,radius){if(x===void 0){x=0;}if(y===void 0){y=0;}if(radius===void 0){radius=0;}this.x=x;this.y=y;this.radius=radius;this.type=SHAPES.CIRC;}/**\n     * Creates a clone of this Circle instance\n     *\n     * @return A copy of the Circle\n     */Circle.prototype.clone=function(){return new Circle(this.x,this.y,this.radius);};/**\n     * Checks whether the x and y coordinates given are contained within this circle\n     *\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @return Whether the x/y coordinates are within this Circle\n     */Circle.prototype.contains=function(x,y){if(this.radius<=0){return false;}var r2=this.radius*this.radius;var dx=this.x-x;var dy=this.y-y;dx*=dx;dy*=dy;return dx+dy<=r2;};/**\n    * Returns the framing rectangle of the circle as a Rectangle object\n    *\n    * @return The framing rectangle\n    */Circle.prototype.getBounds=function(){return new Rectangle(this.x-this.radius,this.y-this.radius,this.radius*2,this.radius*2);};Circle.prototype.toString=function(){return\"[@pixi/math:Circle x=\"+this.x+\" y=\"+this.y+\" radius=\"+this.radius+\"]\";};return Circle;}();/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for displayObjects.\n *\n * @memberof PIXI\n */var Ellipse=/** @class */function(){/**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */function Ellipse(x,y,halfWidth,halfHeight){if(x===void 0){x=0;}if(y===void 0){y=0;}if(halfWidth===void 0){halfWidth=0;}if(halfHeight===void 0){halfHeight=0;}this.x=x;this.y=y;this.width=halfWidth;this.height=halfHeight;this.type=SHAPES.ELIP;}/**\n     * Creates a clone of this Ellipse instance\n     *\n     * @return {PIXI.Ellipse} A copy of the ellipse\n     */Ellipse.prototype.clone=function(){return new Ellipse(this.x,this.y,this.width,this.height);};/**\n     * Checks whether the x and y coordinates given are contained within this ellipse\n     *\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @return Whether the x/y coords are within this ellipse\n     */Ellipse.prototype.contains=function(x,y){if(this.width<=0||this.height<=0){return false;}// normalize the coords to an ellipse with center 0,0\nvar normx=(x-this.x)/this.width;var normy=(y-this.y)/this.height;normx*=normx;normy*=normy;return normx+normy<=1;};/**\n     * Returns the framing rectangle of the ellipse as a Rectangle object\n     *\n     * @return The framing rectangle\n     */Ellipse.prototype.getBounds=function(){return new Rectangle(this.x-this.width,this.y-this.height,this.width,this.height);};Ellipse.prototype.toString=function(){return\"[@pixi/math:Ellipse x=\"+this.x+\" y=\"+this.y+\" width=\"+this.width+\" height=\"+this.height+\"]\";};return Ellipse;}();/**\n * A class to define a shape via user defined coordinates.\n *\n * @memberof PIXI\n */var Polygon=/** @class */function(){/**\n     * @param {PIXI.IPointData[]|number[]} points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */function Polygon(){var arguments$1=arguments;var points=[];for(var _i=0;_i<arguments.length;_i++){points[_i]=arguments$1[_i];}var flat=Array.isArray(points[0])?points[0]:points;// if this is an array of points, convert it to a flat array of numbers\nif(typeof flat[0]!=='number'){var p=[];for(var i=0,il=flat.length;i<il;i++){p.push(flat[i].x,flat[i].y);}flat=p;}this.points=flat;this.type=SHAPES.POLY;this.closeStroke=true;}/**\n     * Creates a clone of this polygon.\n     *\n     * @return - A copy of the polygon.\n     */Polygon.prototype.clone=function(){var points=this.points.slice();var polygon=new Polygon(points);polygon.closeStroke=this.closeStroke;return polygon;};/**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     *\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @return - Whether the x/y coordinates are within this polygon.\n     */Polygon.prototype.contains=function(x,y){var inside=false;// use some raycasting to test hits\n// https://github.com/substack/point-in-polygon/blob/master/index.js\nvar length=this.points.length/2;for(var i=0,j=length-1;i<length;j=i++){var xi=this.points[i*2];var yi=this.points[i*2+1];var xj=this.points[j*2];var yj=this.points[j*2+1];var intersect=yi>y!==yj>y&&x<(xj-xi)*((y-yi)/(yj-yi))+xi;if(intersect){inside=!inside;}}return inside;};Polygon.prototype.toString=function(){return\"[@pixi/math:Polygon\"+(\"closeStroke=\"+this.closeStroke)+(\"points=\"+this.points.reduce(function(pointsDesc,currentPoint){return pointsDesc+\", \"+currentPoint;},'')+\"]\");};return Polygon;}();/**\n * The Rounded Rectangle object is an area that has nice rounded corners, as indicated by its\n * top-left corner point (x, y) and by its width and its height and its radius.\n *\n * @memberof PIXI\n */var RoundedRectangle=/** @class */function(){/**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */function RoundedRectangle(x,y,width,height,radius){if(x===void 0){x=0;}if(y===void 0){y=0;}if(width===void 0){width=0;}if(height===void 0){height=0;}if(radius===void 0){radius=20;}this.x=x;this.y=y;this.width=width;this.height=height;this.radius=radius;this.type=SHAPES.RREC;}/**\n     * Creates a clone of this Rounded Rectangle.\n     *\n     * @return - A copy of the rounded rectangle.\n     */RoundedRectangle.prototype.clone=function(){return new RoundedRectangle(this.x,this.y,this.width,this.height,this.radius);};/**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     *\n     * @param x - The X coordinate of the point to test.\n     * @param y - The Y coordinate of the point to test.\n     * @return - Whether the x/y coordinates are within this Rounded Rectangle.\n     */RoundedRectangle.prototype.contains=function(x,y){if(this.width<=0||this.height<=0){return false;}if(x>=this.x&&x<=this.x+this.width){if(y>=this.y&&y<=this.y+this.height){var radius=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(y>=this.y+radius&&y<=this.y+this.height-radius||x>=this.x+radius&&x<=this.x+this.width-radius){return true;}var dx=x-(this.x+radius);var dy=y-(this.y+radius);var radius2=radius*radius;if(dx*dx+dy*dy<=radius2){return true;}dx=x-(this.x+this.width-radius);if(dx*dx+dy*dy<=radius2){return true;}dy=y-(this.y+this.height-radius);if(dx*dx+dy*dy<=radius2){return true;}dx=x-(this.x+radius);if(dx*dx+dy*dy<=radius2){return true;}}}return false;};RoundedRectangle.prototype.toString=function(){return\"[@pixi/math:RoundedRectangle x=\"+this.x+\" y=\"+this.y+(\"width=\"+this.width+\" height=\"+this.height+\" radius=\"+this.radius+\"]\");};return RoundedRectangle;}();/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * An `ObservablePoint` is a point that triggers a callback when the point's position is changed.\n *\n * @memberof PIXI\n */var ObservablePoint=/** @class */function(){/**\n     * Creates a new `ObservablePoint`\n     *\n     * @param cb - callback function triggered when `x` and/or `y` are changed\n     * @param scope - owner of callback\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n    */function ObservablePoint(cb,scope,x,y){if(x===void 0){x=0;}if(y===void 0){y=0;}this._x=x;this._y=y;this.cb=cb;this.scope=scope;}/**\n     * Creates a clone of this point.\n     * The callback and scope params can be overridden otherwise they will default\n     * to the clone object's values.\n     *\n     * @override\n     * @param cb - The callback function triggered when `x` and/or `y` are changed\n     * @param scope - The owner of the callback\n     * @return a copy of this observable point\n     */ObservablePoint.prototype.clone=function(cb,scope){if(cb===void 0){cb=this.cb;}if(scope===void 0){scope=this.scope;}return new ObservablePoint(cb,scope,this._x,this._y);};/**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     *\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=x] - position of the point on the y axis\n     * @returns The observable point instance itself\n     */ObservablePoint.prototype.set=function(x,y){if(x===void 0){x=0;}if(y===void 0){y=x;}if(this._x!==x||this._y!==y){this._x=x;this._y=y;this.cb.call(this.scope);}return this;};/**\n     * Copies x and y from the given point (`p`)\n     *\n     * @param p - The point to copy from. Can be any of type that is or extends `IPointData`\n     * @returns The observable point instance itself\n     */ObservablePoint.prototype.copyFrom=function(p){if(this._x!==p.x||this._y!==p.y){this._x=p.x;this._y=p.y;this.cb.call(this.scope);}return this;};/**\n     * Copies this point's x and y into that of the given point (`p`)\n     *\n     * @param p - The point to copy to. Can be any of type that is or extends `IPointData`\n     * @returns The point (`p`) with values updated\n     */ObservablePoint.prototype.copyTo=function(p){p.set(this._x,this._y);return p;};/**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     *\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */ObservablePoint.prototype.equals=function(p){return p.x===this._x&&p.y===this._y;};ObservablePoint.prototype.toString=function(){return\"[@pixi/math:ObservablePoint x=\"+0+\" y=\"+0+\" scope=\"+this.scope+\"]\";};Object.defineProperty(ObservablePoint.prototype,\"x\",{/** Position of the observable point on the x axis. */get:function get(){return this._x;},set:function set(value){if(this._x!==value){this._x=value;this.cb.call(this.scope);}},enumerable:false,configurable:true});Object.defineProperty(ObservablePoint.prototype,\"y\",{/** Position of the observable point on the y axis. */get:function get(){return this._y;},set:function set(value){if(this._y!==value){this._y=value;this.cb.call(this.scope);}},enumerable:false,configurable:true});return ObservablePoint;}();/**\n * The PixiJS Matrix as a class makes it a lot faster.\n *\n * Here is a representation of it:\n * ```js\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n * ```\n *\n * @memberof PIXI\n */var Matrix=/** @class */function(){/**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */function Matrix(a,b,c,d,tx,ty){if(a===void 0){a=1;}if(b===void 0){b=0;}if(c===void 0){c=0;}if(d===void 0){d=1;}if(tx===void 0){tx=0;}if(ty===void 0){ty=0;}this.array=null;this.a=a;this.b=b;this.c=c;this.d=d;this.tx=tx;this.ty=ty;}/**\n     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n     *\n     * a = array[0]\n     * b = array[1]\n     * c = array[3]\n     * d = array[4]\n     * tx = array[2]\n     * ty = array[5]\n     *\n     * @param array - The array that the matrix will be populated from.\n     */Matrix.prototype.fromArray=function(array){this.a=array[0];this.b=array[1];this.c=array[3];this.d=array[4];this.tx=array[2];this.ty=array[5];};/**\n     * Sets the matrix properties.\n     *\n     * @param a - Matrix component\n     * @param b - Matrix component\n     * @param c - Matrix component\n     * @param d - Matrix component\n     * @param tx - Matrix component\n     * @param ty - Matrix component\n     * @return This matrix. Good for chaining method calls.\n     */Matrix.prototype.set=function(a,b,c,d,tx,ty){this.a=a;this.b=b;this.c=c;this.d=d;this.tx=tx;this.ty=ty;return this;};/**\n     * Creates an array from the current Matrix object.\n     *\n     * @param transpose - Whether we need to transpose the matrix or not\n     * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n     * @return The newly created array which contains the matrix\n     */Matrix.prototype.toArray=function(transpose,out){if(!this.array){this.array=new Float32Array(9);}var array=out||this.array;if(transpose){array[0]=this.a;array[1]=this.b;array[2]=0;array[3]=this.c;array[4]=this.d;array[5]=0;array[6]=this.tx;array[7]=this.ty;array[8]=1;}else{array[0]=this.a;array[1]=this.c;array[2]=this.tx;array[3]=this.b;array[4]=this.d;array[5]=this.ty;array[6]=0;array[7]=0;array[8]=1;}return array;};/**\n     * Get a new position with the current transformation applied.\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     *\n     * @param pos - The origin\n     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @return {PIXI.Point} The new point, transformed through this matrix\n     */Matrix.prototype.apply=function(pos,newPos){newPos=newPos||new Point();var x=pos.x;var y=pos.y;newPos.x=this.a*x+this.c*y+this.tx;newPos.y=this.b*x+this.d*y+this.ty;return newPos;};/**\n     * Get a new position with the inverse of the current transformation applied.\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     *\n     * @param pos - The origin\n     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @return {PIXI.Point} The new point, inverse-transformed through this matrix\n     */Matrix.prototype.applyInverse=function(pos,newPos){newPos=newPos||new Point();var id=1/(this.a*this.d+this.c*-this.b);var x=pos.x;var y=pos.y;newPos.x=this.d*id*x+-this.c*id*y+(this.ty*this.c-this.tx*this.d)*id;newPos.y=this.a*id*y+-this.b*id*x+(-this.ty*this.a+this.tx*this.b)*id;return newPos;};/**\n     * Translates the matrix on the x and y.\n     *\n     * @param x - How much to translate x by\n     * @param y - How much to translate y by\n     * @return This matrix. Good for chaining method calls.\n     */Matrix.prototype.translate=function(x,y){this.tx+=x;this.ty+=y;return this;};/**\n     * Applies a scale transformation to the matrix.\n     *\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @return This matrix. Good for chaining method calls.\n     */Matrix.prototype.scale=function(x,y){this.a*=x;this.d*=y;this.c*=x;this.b*=y;this.tx*=x;this.ty*=y;return this;};/**\n     * Applies a rotation transformation to the matrix.\n     *\n     * @param angle - The angle in radians.\n     * @return This matrix. Good for chaining method calls.\n     */Matrix.prototype.rotate=function(angle){var cos=Math.cos(angle);var sin=Math.sin(angle);var a1=this.a;var c1=this.c;var tx1=this.tx;this.a=a1*cos-this.b*sin;this.b=a1*sin+this.b*cos;this.c=c1*cos-this.d*sin;this.d=c1*sin+this.d*cos;this.tx=tx1*cos-this.ty*sin;this.ty=tx1*sin+this.ty*cos;return this;};/**\n     * Appends the given Matrix to this Matrix.\n     *\n     * @param matrix - The matrix to append.\n     * @return This matrix. Good for chaining method calls.\n     */Matrix.prototype.append=function(matrix){var a1=this.a;var b1=this.b;var c1=this.c;var d1=this.d;this.a=matrix.a*a1+matrix.b*c1;this.b=matrix.a*b1+matrix.b*d1;this.c=matrix.c*a1+matrix.d*c1;this.d=matrix.c*b1+matrix.d*d1;this.tx=matrix.tx*a1+matrix.ty*c1+this.tx;this.ty=matrix.tx*b1+matrix.ty*d1+this.ty;return this;};/**\n     * Sets the matrix based on all the available properties\n     *\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @return This matrix. Good for chaining method calls.\n     */Matrix.prototype.setTransform=function(x,y,pivotX,pivotY,scaleX,scaleY,rotation,skewX,skewY){this.a=Math.cos(rotation+skewY)*scaleX;this.b=Math.sin(rotation+skewY)*scaleX;this.c=-Math.sin(rotation-skewX)*scaleY;this.d=Math.cos(rotation-skewX)*scaleY;this.tx=x-(pivotX*this.a+pivotY*this.c);this.ty=y-(pivotX*this.b+pivotY*this.d);return this;};/**\n     * Prepends the given Matrix to this Matrix.\n     *\n     * @param matrix - The matrix to prepend\n     * @return This matrix. Good for chaining method calls.\n     */Matrix.prototype.prepend=function(matrix){var tx1=this.tx;if(matrix.a!==1||matrix.b!==0||matrix.c!==0||matrix.d!==1){var a1=this.a;var c1=this.c;this.a=a1*matrix.a+this.b*matrix.c;this.b=a1*matrix.b+this.b*matrix.d;this.c=c1*matrix.a+this.d*matrix.c;this.d=c1*matrix.b+this.d*matrix.d;}this.tx=tx1*matrix.a+this.ty*matrix.c+matrix.tx;this.ty=tx1*matrix.b+this.ty*matrix.d+matrix.ty;return this;};/**\n     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n     *\n     * @param transform - The transform to apply the properties to.\n     * @return The transform with the newly applied properties\n     */Matrix.prototype.decompose=function(transform){// sort out rotation / skew..\nvar a=this.a;var b=this.b;var c=this.c;var d=this.d;var pivot=transform.pivot;var skewX=-Math.atan2(-c,d);var skewY=Math.atan2(b,a);var delta=Math.abs(skewX+skewY);if(delta<0.00001||Math.abs(PI_2-delta)<0.00001){transform.rotation=skewY;transform.skew.x=transform.skew.y=0;}else{transform.rotation=0;transform.skew.x=skewX;transform.skew.y=skewY;}// next set scale\ntransform.scale.x=Math.sqrt(a*a+b*b);transform.scale.y=Math.sqrt(c*c+d*d);// next set position\ntransform.position.x=this.tx+(pivot.x*a+pivot.y*c);transform.position.y=this.ty+(pivot.x*b+pivot.y*d);return transform;};/**\n     * Inverts this matrix\n     *\n     * @return This matrix. Good for chaining method calls.\n     */Matrix.prototype.invert=function(){var a1=this.a;var b1=this.b;var c1=this.c;var d1=this.d;var tx1=this.tx;var n=a1*d1-b1*c1;this.a=d1/n;this.b=-b1/n;this.c=-c1/n;this.d=a1/n;this.tx=(c1*this.ty-d1*tx1)/n;this.ty=-(a1*this.ty-b1*tx1)/n;return this;};/**\n     * Resets this Matrix to an identity (default) matrix.\n     *\n     * @return This matrix. Good for chaining method calls.\n     */Matrix.prototype.identity=function(){this.a=1;this.b=0;this.c=0;this.d=1;this.tx=0;this.ty=0;return this;};/**\n     * Creates a new Matrix object with the same values as this one.\n     *\n     * @return A copy of this matrix. Good for chaining method calls.\n     */Matrix.prototype.clone=function(){var matrix=new Matrix();matrix.a=this.a;matrix.b=this.b;matrix.c=this.c;matrix.d=this.d;matrix.tx=this.tx;matrix.ty=this.ty;return matrix;};/**\n     * Changes the values of the given matrix to be the same as the ones in this matrix\n     *\n     * @param matrix - The matrix to copy to.\n     * @return The matrix given in parameter with its values updated.\n     */Matrix.prototype.copyTo=function(matrix){matrix.a=this.a;matrix.b=this.b;matrix.c=this.c;matrix.d=this.d;matrix.tx=this.tx;matrix.ty=this.ty;return matrix;};/**\n     * Changes the values of the matrix to be the same as the ones in given matrix\n     *\n     * @param {PIXI.Matrix} matrix - The matrix to copy from.\n     * @return {PIXI.Matrix} this\n     */Matrix.prototype.copyFrom=function(matrix){this.a=matrix.a;this.b=matrix.b;this.c=matrix.c;this.d=matrix.d;this.tx=matrix.tx;this.ty=matrix.ty;return this;};Matrix.prototype.toString=function(){return\"[@pixi/math:Matrix a=\"+this.a+\" b=\"+this.b+\" c=\"+this.c+\" d=\"+this.d+\" tx=\"+this.tx+\" ty=\"+this.ty+\"]\";};Object.defineProperty(Matrix,\"IDENTITY\",{/**\n         * A default (identity) matrix\n         *\n         * @readonly\n         */get:function get(){return new Matrix();},enumerable:false,configurable:true});Object.defineProperty(Matrix,\"TEMP_MATRIX\",{/**\n         * A temp matrix\n         *\n         * @readonly\n         */get:function get(){return new Matrix();},enumerable:false,configurable:true});return Matrix;}();// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group\n/*\n * Transform matrix for operation n is:\n * | ux | vx |\n * | uy | vy |\n */var ux=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1];var uy=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1];var vx=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1];var vy=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1];/**\n * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n * for the composition of each rotation in the dihederal group D8.\n *\n * @type number[][]\n * @private\n */var rotationCayley=[];/**\n * Matrices for each `GD8Symmetry` rotation.\n *\n * @type Matrix[]\n * @private\n */var rotationMatrices=[];/*\n * Alias for {@code Math.sign}.\n */var signum=Math.sign;/*\n * Initializes `rotationCayley` and `rotationMatrices`. It is called\n * only once below.\n */function init(){for(var i=0;i<16;i++){var row=[];rotationCayley.push(row);for(var j=0;j<16;j++){/* Multiplies rotation matrices i and j. */var _ux=signum(ux[i]*ux[j]+vx[i]*uy[j]);var _uy=signum(uy[i]*ux[j]+vy[i]*uy[j]);var _vx=signum(ux[i]*vx[j]+vx[i]*vy[j]);var _vy=signum(uy[i]*vx[j]+vy[i]*vy[j]);/* Finds rotation matrix matching the product and pushes it. */for(var k=0;k<16;k++){if(ux[k]===_ux&&uy[k]===_uy&&vx[k]===_vx&&vy[k]===_vy){row.push(k);break;}}}}for(var i=0;i<16;i++){var mat=new Matrix();mat.set(ux[i],uy[i],vx[i],vy[i],0,0);rotationMatrices.push(mat);}}init();/**\n * @memberof PIXI\n * @typedef {number} GD8Symmetry\n * @see PIXI.groupD8\n */ /**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n *\n * **Origin:**<br>\n *  This is the small part of gameofbombs.com portal system. It works.\n *\n * @see PIXI.groupD8.E\n * @see PIXI.groupD8.SE\n * @see PIXI.groupD8.S\n * @see PIXI.groupD8.SW\n * @see PIXI.groupD8.W\n * @see PIXI.groupD8.NW\n * @see PIXI.groupD8.N\n * @see PIXI.groupD8.NE\n * @author Ivan @ivanpopelyshev\n * @namespace PIXI.groupD8\n * @memberof PIXI\n */var groupD8={/**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 0°       | East      |\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */E:0,/**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 45°↻     | Southeast |\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */SE:1,/**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 90°↻     | South     |\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */S:2,/**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 135°↻    | Southwest |\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */SW:3,/**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 180°     | West      |\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */W:4,/**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -135°/225°↻ | Northwest    |\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */NW:5,/**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -90°/270°↻  | North        |\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */N:6,/**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -45°/315°↻  | Northeast    |\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */NE:7,/**\n     * Reflection about Y-axis.\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */MIRROR_VERTICAL:8,/**\n     * Reflection about the main diagonal.\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */MAIN_DIAGONAL:10,/**\n     * Reflection about X-axis.\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */MIRROR_HORIZONTAL:12,/**\n     * Reflection about reverse diagonal.\n     *\n     * @memberof PIXI.groupD8\n     * @constant {PIXI.GD8Symmetry}\n     */REVERSE_DIAGONAL:14,/**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n     * @return {PIXI.GD8Symmetry} The X-component of the U-axis\n     *    after rotating the axes.\n     */uX:function uX(ind){return ux[ind];},/**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n     * @return {PIXI.GD8Symmetry} The Y-component of the U-axis\n     *    after rotating the axes.\n     */uY:function uY(ind){return uy[ind];},/**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n     * @return {PIXI.GD8Symmetry} The X-component of the V-axis\n     *    after rotating the axes.\n     */vX:function vX(ind){return vx[ind];},/**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n     * @return {PIXI.GD8Symmetry} The Y-component of the V-axis\n     *    after rotating the axes.\n     */vY:function vY(ind){return vy[ind];},/**\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite\n     *   is needed. Only rotations have opposite symmetries while\n     *   reflections don't.\n     * @return {PIXI.GD8Symmetry} The opposite symmetry of `rotation`\n     */inv:function inv(rotation){if(rotation&8)// true only if between 8 & 15 (reflections)\n{return rotation&15;// or rotation % 16\n}return-rotation&7;// or (8 - rotation) % 8\n},/**\n     * Composes the two D8 operations.\n     *\n     * Taking `^` as reflection:\n     *\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n     *\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which\n     *   is the row in the above cayley table.\n     * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which\n     *   is the column in the above cayley table.\n     * @return {PIXI.GD8Symmetry} Composed operation\n     */add:function add(rotationSecond,rotationFirst){return rotationCayley[rotationSecond][rotationFirst];},/**\n     * Reverse of `add`.\n     *\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} rotationSecond - Second operation\n     * @param {PIXI.GD8Symmetry} rotationFirst - First operation\n     * @return {PIXI.GD8Symmetry} Result\n     */sub:function sub(rotationSecond,rotationFirst){return rotationCayley[rotationSecond][groupD8.inv(rotationFirst)];},/**\n     * Adds 180 degrees to rotation, which is a commutative\n     * operation.\n     *\n     * @memberof PIXI.groupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} Rotated number\n     */rotate180:function rotate180(rotation){return rotation^4;},/**\n     * Checks if the rotation angle is vertical, i.e. south\n     * or north. It doesn't work for reflections.\n     *\n     * @memberof PIXI.groupD8\n     * @param {PIXI.GD8Symmetry} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */isVertical:function isVertical(rotation){return(rotation&3)===2;},/**\n     * Approximates the vector `V(dx,dy)` into one of the\n     * eight directions provided by `groupD8`.\n     *\n     * @memberof PIXI.groupD8\n     * @param {number} dx - X-component of the vector\n     * @param {number} dy - Y-component of the vector\n     * @return {PIXI.GD8Symmetry} Approximation of the vector into\n     *  one of the eight symmetries.\n     */byDirection:function byDirection(dx,dy){if(Math.abs(dx)*2<=Math.abs(dy)){if(dy>=0){return groupD8.S;}return groupD8.N;}else if(Math.abs(dy)*2<=Math.abs(dx)){if(dx>0){return groupD8.E;}return groupD8.W;}else if(dy>0){if(dx>0){return groupD8.SE;}return groupD8.SW;}else if(dx>0){return groupD8.NE;}return groupD8.NW;},/**\n     * Helps sprite to compensate texture packer rotation.\n     *\n     * @memberof PIXI.groupD8\n     * @param {PIXI.Matrix} matrix - sprite world matrix\n     * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */matrixAppendRotationInv:function matrixAppendRotationInv(matrix,rotation,tx,ty){if(tx===void 0){tx=0;}if(ty===void 0){ty=0;}// Packer used \"rotation\", we use \"inv(rotation)\"\nvar mat=rotationMatrices[groupD8.inv(rotation)];mat.tx=tx;mat.ty=ty;matrix.append(mat);}};/**\n * Transform that takes care about its versions.\n *\n * @memberof PIXI\n */var Transform=/** @class */function(){function Transform(){this.worldTransform=new Matrix();this.localTransform=new Matrix();this.position=new ObservablePoint(this.onChange,this,0,0);this.scale=new ObservablePoint(this.onChange,this,1,1);this.pivot=new ObservablePoint(this.onChange,this,0,0);this.skew=new ObservablePoint(this.updateSkew,this,0,0);this._rotation=0;this._cx=1;this._sx=0;this._cy=0;this._sy=1;this._localID=0;this._currentLocalID=0;this._worldID=0;this._parentID=0;}/** Called when a value changes. */Transform.prototype.onChange=function(){this._localID++;};/** Called when the skew or the rotation changes. */Transform.prototype.updateSkew=function(){this._cx=Math.cos(this._rotation+this.skew.y);this._sx=Math.sin(this._rotation+this.skew.y);this._cy=-Math.sin(this._rotation-this.skew.x);// cos, added PI/2\nthis._sy=Math.cos(this._rotation-this.skew.x);// sin, added PI/2\nthis._localID++;};Transform.prototype.toString=function(){return\"[@pixi/math:Transform \"+(\"position=(\"+this.position.x+\", \"+this.position.y+\") \")+(\"rotation=\"+this.rotation+\" \")+(\"scale=(\"+this.scale.x+\", \"+this.scale.y+\") \")+(\"skew=(\"+this.skew.x+\", \"+this.skew.y+\") \")+\"]\";};/** Updates the local transformation matrix. */Transform.prototype.updateLocalTransform=function(){var lt=this.localTransform;if(this._localID!==this._currentLocalID){// get the matrix values of the displayobject based on its transform properties..\nlt.a=this._cx*this.scale.x;lt.b=this._sx*this.scale.x;lt.c=this._cy*this.scale.y;lt.d=this._sy*this.scale.y;lt.tx=this.position.x-(this.pivot.x*lt.a+this.pivot.y*lt.c);lt.ty=this.position.y-(this.pivot.x*lt.b+this.pivot.y*lt.d);this._currentLocalID=this._localID;// force an update..\nthis._parentID=-1;}};/**\n     * Updates the local and the world transformation matrices.\n     *\n     * @param parentTransform - The parent transform\n     */Transform.prototype.updateTransform=function(parentTransform){var lt=this.localTransform;if(this._localID!==this._currentLocalID){// get the matrix values of the displayobject based on its transform properties..\nlt.a=this._cx*this.scale.x;lt.b=this._sx*this.scale.x;lt.c=this._cy*this.scale.y;lt.d=this._sy*this.scale.y;lt.tx=this.position.x-(this.pivot.x*lt.a+this.pivot.y*lt.c);lt.ty=this.position.y-(this.pivot.x*lt.b+this.pivot.y*lt.d);this._currentLocalID=this._localID;// force an update..\nthis._parentID=-1;}if(this._parentID!==parentTransform._worldID){// concat the parent matrix with the objects transform.\nvar pt=parentTransform.worldTransform;var wt=this.worldTransform;wt.a=lt.a*pt.a+lt.b*pt.c;wt.b=lt.a*pt.b+lt.b*pt.d;wt.c=lt.c*pt.a+lt.d*pt.c;wt.d=lt.c*pt.b+lt.d*pt.d;wt.tx=lt.tx*pt.a+lt.ty*pt.c+pt.tx;wt.ty=lt.tx*pt.b+lt.ty*pt.d+pt.ty;this._parentID=parentTransform._worldID;// update the id of the transform..\nthis._worldID++;}};/**\n     * Decomposes a matrix and sets the transforms properties based on it.\n     *\n     * @param matrix - The matrix to decompose\n     */Transform.prototype.setFromMatrix=function(matrix){matrix.decompose(this);this._localID++;};Object.defineProperty(Transform.prototype,\"rotation\",{/** The rotation of the object in radians. */get:function get(){return this._rotation;},set:function set(value){if(this._rotation!==value){this._rotation=value;this.updateSkew();}},enumerable:false,configurable:true});/** A default (identity) transform. */Transform.IDENTITY=new Transform();return Transform;}();export{Circle,DEG_TO_RAD,Ellipse,Matrix,ObservablePoint,PI_2,Point,Polygon,RAD_TO_DEG,Rectangle,RoundedRectangle,SHAPES,Transform,groupD8};","map":null,"metadata":{},"sourceType":"module"}