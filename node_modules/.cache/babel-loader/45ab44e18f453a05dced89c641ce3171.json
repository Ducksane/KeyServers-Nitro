{"ast":null,"code":"/*!\n * @pixi/events - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/events is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */import{EventEmitter}from'@pixi/utils';import{Point}from'@pixi/math';import{DisplayObject}from'@pixi/display';/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */ /* global Reflect, Promise */var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b){if(b.hasOwnProperty(p)){d[p]=b[p];}}};return _extendStatics(d,b);};function __extends(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());}/**\n * An DOM-compatible synthetic event implementation that is \"forwarded\" on behalf of an original\n * FederatedEvent or native {@link https://dom.spec.whatwg.org/#event Event}.\n *\n * @memberof PIXI\n * @typeParam N - The type of native event held.\n */var FederatedEvent=/** @class */function(){/**\n     * @param manager - The event boundary which manages this event. Propagation can only occur\n     *  within the boundary's jurisdiction.\n     */function FederatedEvent(manager){/** Flags whether this event bubbles. This will take effect only if it is set before propagation. */this.bubbles=true;/** @deprecated */this.cancelBubble=true;/**\n         * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n         * false (for now).\n         */this.cancelable=false;/**\n         * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events\n         * API.\n         *\n         * @see https://dom.spec.whatwg.org/#dom-event-composed\n         */this.composed=false;/** Flags whether the default response of the user agent was prevent through this event. */this.defaultPrevented=false;/**\n         * The propagation phase.\n         *\n         * @default {@link FederatedEvent.NONE}\n         */this.eventPhase=FederatedEvent.prototype.NONE;/** Flags whether propagation was stopped. */this.propagationStopped=false;/** Flags whether propagation was immediately stopped. */this.propagationImmediatelyStopped=false;/**\n         * The coordinates of the evnet relative to the nearest DOM layer. This is a non-standard\n         * property.\n         */this.layer=new Point();/**\n         * The coordinates of the event relative to the DOM document. This is a non-standard property.\n         */this.page=new Point();this.AT_TARGET=1;this.BUBBLING_PHASE=2;this.CAPTURING_PHASE=3;this.NONE=0;this.manager=manager;}Object.defineProperty(FederatedEvent.prototype,\"layerX\",{/** @readonly */get:function get(){return this.layer.x;},enumerable:false,configurable:true});Object.defineProperty(FederatedEvent.prototype,\"layerY\",{/** @readonly */get:function get(){return this.layer.y;},enumerable:false,configurable:true});Object.defineProperty(FederatedEvent.prototype,\"pageX\",{/** @readonly */get:function get(){return this.page.x;},enumerable:false,configurable:true});Object.defineProperty(FederatedEvent.prototype,\"pageY\",{/** @readonly */get:function get(){return this.page.y;},enumerable:false,configurable:true});Object.defineProperty(FederatedEvent.prototype,\"data\",{/**\n         * Fallback for the deprecated {@link PIXI.InteractionEvent.data}.\n         *\n         * @deprecated\n         */get:function get(){return this;},enumerable:false,configurable:true});/**\n     * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n     */FederatedEvent.prototype.composedPath=function(){// Find the propagation path if it isn't cached or if the target has changed since since\n// the last evaluation.\nif(this.manager&&(!this.path||this.path[this.path.length-1]!==this.target)){this.path=this.target?this.manager.propagationPath(this.target):[];}return this.path;};/**\n     * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw\n     * an {@code Error}.\n     */FederatedEvent.prototype.initEvent=function(_type,_bubbles,_cancelable){throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');};/**\n     * Prevent default behavior of PixiJS and the user agent.\n     */FederatedEvent.prototype.preventDefault=function(){if(this.nativeEvent instanceof Event&&this.nativeEvent.cancelable){this.nativeEvent.preventDefault();}this.defaultPrevented=true;};/**\n     * Stop this event from propagating to any addition listeners, including on the\n     * {@link FederatedEventTarget.currentTarget currentTarget} and also the following\n     * event targets on the propagation path.\n     */FederatedEvent.prototype.stopImmediatePropagation=function(){this.propagationImmediatelyStopped=true;};/**\n     * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners\n     * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.\n     */FederatedEvent.prototype.stopPropagation=function(){this.propagationStopped=true;};return FederatedEvent;}();/**\n * A {@link PIXI.FederatedEvent} for mouse events.\n *\n * @memberof PIXI\n */var FederatedMouseEvent=/** @class */function(_super){__extends(FederatedMouseEvent,_super);function FederatedMouseEvent(){var _this=_super!==null&&_super.apply(this,arguments)||this;/**\n         * The coordinates of the mouse event relative to the canvas.\n         */_this.client=new Point();/**\n         * The movement in this pointer relative to the last `mousemove` event.\n         */_this.movement=new Point();/**\n         * The offset of the pointer coordinates w.r.t. target DisplayObject in world space. This is\n         * not supported at the moment.\n         */_this.offset=new Point();/**\n         * The pointer coordinates in world space.\n         */_this.global=new Point();/**\n         * The pointer coordinates in the renderer's {@link PIXI.Renderer.screen screen}. This has slightly\n         * different semantics than native PointerEvent screenX/screenY.\n         */_this.screen=new Point();return _this;}Object.defineProperty(FederatedMouseEvent.prototype,\"clientX\",{/** @readonly */get:function get(){return this.client.x;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"clientY\",{/** @readonly */get:function get(){return this.client.y;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"x\",{/**\n         * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n         *\n         * @readonly\n         */get:function get(){return this.clientX;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"y\",{/**\n         * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n         *\n         * @readonly\n         */get:function get(){return this.clientY;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"movementX\",{/** @readonly */get:function get(){return this.movement.x;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"movementY\",{/** @readonly */get:function get(){return this.movement.y;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"offsetX\",{/** @readonly */get:function get(){return this.offset.x;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"offsetY\",{/** @readonly */get:function get(){return this.offset.y;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"globalX\",{/** @readonly */get:function get(){return this.global.x;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"globalY\",{/** @readonly */get:function get(){return this.global.y;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"screenX\",{/**\n         * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.\n         *\n         * @readonly\n         */get:function get(){return this.screen.x;},enumerable:false,configurable:true});Object.defineProperty(FederatedMouseEvent.prototype,\"screenY\",{/**\n         * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.\n         *\n         * @readonly\n         */get:function get(){return this.screen.y;},enumerable:false,configurable:true});/**\n     * Whether the modifier key was pressed when this event natively occurred.\n     *\n     * @param key - The modifier key.\n     */FederatedMouseEvent.prototype.getModifierState=function(key){return'getModifierState'in this.nativeEvent&&this.nativeEvent.getModifierState(key);};/**\n     * Not supported.\n     *\n     * @deprecated\n     */ // eslint-disable-next-line max-params\nFederatedMouseEvent.prototype.initMouseEvent=function(_typeArg,_canBubbleArg,_cancelableArg,_viewArg,_detailArg,_screenXArg,_screenYArg,_clientXArg,_clientYArg,_ctrlKeyArg,_altKeyArg,_shiftKeyArg,_metaKeyArg,_buttonArg,_relatedTargetArg){throw new Error('Method not implemented.');};return FederatedMouseEvent;}(FederatedEvent);/**\n * A {@link PIXI.FederatedEvent} for pointer events.\n *\n * @memberof PIXI\n */var FederatedPointerEvent=/** @class */function(_super){__extends(FederatedPointerEvent,_super);function FederatedPointerEvent(){var _this=_super!==null&&_super.apply(this,arguments)||this;/**\n         * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n         * radiusX of TouchEvents will be represented by this value.\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n         */_this.width=0;/**\n         * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n         * radiusY of TouchEvents will be represented by this value.\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n         */_this.height=0;/**\n         * Indicates whether or not the pointer device that created the event is the primary pointer.\n         *\n         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n         */_this.isPrimary=false;return _this;}// Only included for completeness for now\nFederatedPointerEvent.prototype.getCoalescedEvents=function(){if(this.type==='pointermove'||this.type==='mousemove'||this.type==='touchmove'){return[this];}return[];};// Only included for completeness for now\nFederatedPointerEvent.prototype.getPredictedEvents=function(){throw new Error('getPredictedEvents is not supported!');};return FederatedPointerEvent;}(FederatedMouseEvent);/**\n * A {@link PIXI.FederatedEvent} for wheel events.\n *\n * @memberof PIXI\n */var FederatedWheelEvent=/** @class */function(_super){__extends(FederatedWheelEvent,_super);function FederatedWheelEvent(){var _this=_super!==null&&_super.apply(this,arguments)||this;/** Units specified in lines. */_this.DOM_DELTA_LINE=0;/** Units specified in pages. */_this.DOM_DELTA_PAGE=1;/** Units specified in pixels. */_this.DOM_DELTA_PIXEL=2;return _this;}return FederatedWheelEvent;}(FederatedMouseEvent);// The maximum iterations used in propagation. This prevent infinite loops.\nvar PROPAGATION_LIMIT=2048;var tempHitLocation=new Point();var tempLocalMapping=new Point();/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link PIXI.EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link PIXI.EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link PIXI.FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from '@pixi/display';\n * import { EventBoundary } from '@pixi/events';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends DisplayObject\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n *\n * @memberof PIXI\n */var EventBoundary=/** @class */function(){/**\n     * @param rootTarget - The holder of the event boundary.\n     */function EventBoundary(rootTarget){/**\n         * Emits events after they were dispatched into the scene graph.\n         *\n         * This can be used for global events listening, regardless of the scene graph being used. It should\n         * not be used by interactive libraries for normal use.\n         *\n         * Special events that do not bubble all the way to the root target are not emitted from here,\n         * e.g. pointerenter, pointerleave, click.\n         */this.dispatch=new EventEmitter();/**\n         * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all DisplayObjects.\n         *\n         * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n         * the Pointer Event API's approach.\n         */this.moveOnAll=false;/**\n         * State object for mapping methods.\n         *\n         * @see PIXI.EventBoundary#trackingData\n         */this.mappingState={trackingData:{}};/**\n         * The event pool maps event constructors to an free pool of instances of those specific events.\n         *\n         * @see PIXI.EventBoundary#allocateEvent\n         * @see PIXI.EventBoundary#freeEvent\n         */this.eventPool=new Map();this.rootTarget=rootTarget;this.hitPruneFn=this.hitPruneFn.bind(this);this.hitTestFn=this.hitTestFn.bind(this);this.mapPointerDown=this.mapPointerDown.bind(this);this.mapPointerMove=this.mapPointerMove.bind(this);this.mapPointerOut=this.mapPointerOut.bind(this);this.mapPointerOver=this.mapPointerOver.bind(this);this.mapPointerUp=this.mapPointerUp.bind(this);this.mapPointerUpOutside=this.mapPointerUpOutside.bind(this);this.mapWheel=this.mapWheel.bind(this);this.mappingTable={};this.addEventMapping('pointerdown',this.mapPointerDown);this.addEventMapping('pointermove',this.mapPointerMove);this.addEventMapping('pointerout',this.mapPointerOut);this.addEventMapping('pointerleave',this.mapPointerOut);this.addEventMapping('pointerover',this.mapPointerOver);this.addEventMapping('pointerup',this.mapPointerUp);this.addEventMapping('pointerupoutside',this.mapPointerUpOutside);this.addEventMapping('wheel',this.mapWheel);}/**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     *\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */EventBoundary.prototype.addEventMapping=function(type,fn){if(!this.mappingTable[type]){this.mappingTable[type]=[];}this.mappingTable[type].push({fn:fn,priority:0});this.mappingTable[type].sort(function(a,b){return a.priority-b.priority;});};/** Dispatches the given event */EventBoundary.prototype.dispatchEvent=function(e,type){e.propagationStopped=false;e.propagationImmediatelyStopped=false;this.propagate(e,type);this.dispatch.emit(type||e.type,e);};/** Maps the given upstream event through the event boundary and propagates it downstream. */EventBoundary.prototype.mapEvent=function(e){if(!this.rootTarget){return;}var mappers=this.mappingTable[e.type];if(mappers){for(var i=0,j=mappers.length;i<j;i++){mappers[i].fn(e);}}else{console.warn(\"[EventBoundary]: Event mapping not defined for \"+e.type);}};/**\n     * Finds the DisplayObject that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     */EventBoundary.prototype.hitTest=function(x,y){var invertedPath=this.hitTestRecursive(this.rootTarget,this.rootTarget.interactive,tempHitLocation.set(x,y),this.hitTestFn,this.hitPruneFn);return invertedPath&&invertedPath[0];};/**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target {@code e.target}.\n     *\n     * @param e - The event to propagate.\n     */EventBoundary.prototype.propagate=function(e,type){if(!e.target){// This usually occurs when the scene graph is not interactive.\nreturn;}var composedPath=e.composedPath();// Capturing phase\ne.eventPhase=e.CAPTURING_PHASE;for(var i=0,j=composedPath.length-1;i<j;i++){e.currentTarget=composedPath[i];this.notifyTarget(e,type);if(e.propagationStopped||e.propagationImmediatelyStopped){return;}}// At target phase\ne.eventPhase=e.AT_TARGET;e.currentTarget=e.target;this.notifyTarget(e,type);if(e.propagationStopped||e.propagationImmediatelyStopped){return;}// Bubbling phase\ne.eventPhase=e.BUBBLING_PHASE;for(var i=composedPath.length-2;i>=0;i--){e.currentTarget=composedPath[i];this.notifyTarget(e,type);if(e.propagationStopped||e.propagationImmediatelyStopped){return;}}};/**\n     * Emits the event {@link e} to all display objects. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `pointermove` legacy mode.\n     *\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     */EventBoundary.prototype.all=function(e,type,target){if(target===void 0){target=this.rootTarget;}e.eventPhase=e.BUBBLING_PHASE;var children=target.children;if(children){for(var i=0;i<children.length;i++){this.all(e,type,children[i]);}}e.currentTarget=target;this.notifyTarget(e,type);};/**\n     * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed\n     * {@code target}. The last element in the path is {@code target}.\n     *\n     * @param target\n     */EventBoundary.prototype.propagationPath=function(target){var propagationPath=[target];for(var i=0;i<PROPAGATION_LIMIT&&target!==this.rootTarget;i++){if(!target.parent){throw new Error('Cannot find propagation path to disconnected target');}propagationPath.push(target.parent);target=target.parent;}propagationPath.reverse();return propagationPath;};/**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     *\n     * @param currentTarget - The DisplayObject that is to be hit tested.\n     * @param interactive - Flags whether `currentTarget` or one of its parents are interactive.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the display object.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @return An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */EventBoundary.prototype.hitTestRecursive=function(currentTarget,interactive,location,testFn,pruneFn){if(!currentTarget||!currentTarget.visible){return null;}// Attempt to prune this DisplayObject and its subtree as an optimization.\nif(pruneFn(currentTarget,location)){return null;}// Find a child that passes the hit testing and return one, if any.\nif(currentTarget.interactiveChildren&&currentTarget.children){var children=currentTarget.children;for(var i=children.length-1;i>=0;i--){var child=children[i];var nestedHit=this.hitTestRecursive(child,interactive||child.interactive,location,testFn,pruneFn);if(nestedHit){// Its a good idea to check if a child has lost its parent.\n// this means it has been removed whilst looping so its best\nif(nestedHit.length>0&&!nestedHit[nestedHit.length-1].parent){continue;}// Only add the current hit-test target to the hit-test chain if the chain\n// has already started (i.e. the event target has been found) or if the current\n// target is interactive (i.e. it becomes the event target).\nif(nestedHit.length>0||currentTarget.interactive){nestedHit.push(currentTarget);}return nestedHit;}}}// Finally, hit test this DisplayObject itself.\nif(interactive&&testFn(currentTarget,location)){// The current hit-test target is the event's target only if it is interactive. Otherwise,\n// the first interactive ancestor will be the event's target.\nreturn currentTarget.interactive?[currentTarget]:[];}return null;};/**\n     * Checks whether the display object or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link PIXI.DisplayObject.hitArea hitArea}\n     * and {@link PIXI.DisplayObject._mask} for pruning.\n     *\n     * @param displayObject\n     * @param location\n     */EventBoundary.prototype.hitPruneFn=function(displayObject,location){if(displayObject.hitArea){displayObject.worldTransform.applyInverse(location,tempLocalMapping);if(!displayObject.hitArea.contains(tempLocalMapping.x,tempLocalMapping.y)){return true;}}if(displayObject._mask){var mask=displayObject._mask;if(!(mask.containsPoint&&mask.containsPoint(location))){return true;}}return false;};/**\n     * Checks whether the display object passes hit testing for the given location.\n     *\n     * @param displayObject\n     * @param location\n     * @return - Whether `displayObject` passes hit testing for `location`.\n     */EventBoundary.prototype.hitTestFn=function(displayObject,location){// If the display object failed pruning with a hitArea, then it must pass it.\nif(displayObject.hitArea){return true;}if(displayObject.containsPoint){return displayObject.containsPoint(location);}// TODO: Should we hit test based on bounds?\nreturn false;};/**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * @param e - The event passed to the target.\n     */EventBoundary.prototype.notifyTarget=function(e,type){type=type!==null&&type!==void 0?type:e.type;var key=e.eventPhase===e.CAPTURING_PHASE||e.eventPhase===e.AT_TARGET?type+\"capture\":type;this.notifyListeners(e,key);if(e.eventPhase===e.AT_TARGET){this.notifyListeners(e,type);}};/**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     *\n     * @param from\n     */EventBoundary.prototype.mapPointerDown=function(from){if(!(from instanceof FederatedPointerEvent)){console.warn('EventBoundary cannot map a non-pointer event as a pointer event');return;}var e=this.createPointerEvent(from);this.dispatchEvent(e,'pointerdown');if(e.pointerType==='touch'){this.dispatchEvent(e,'touchstart');}else if(e.pointerType==='mouse'||e.pointerType==='pen'){var isRightButton=e.button===2;this.dispatchEvent(e,isRightButton?'rightdown':'mousedown');}var trackingData=this.trackingData(from.pointerId);trackingData.pressTargetsByButton[from.button]=e.composedPath();this.freeEvent(e);};/**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     *\n     * @param from - The upstream `pointermove` event.\n     */EventBoundary.prototype.mapPointerMove=function(from){var _a;if(!(from instanceof FederatedPointerEvent)){console.warn('EventBoundary cannot map a non-pointer event as a pointer event');return;}var e=this.createPointerEvent(from);var isMouse=e.pointerType==='mouse'||e.pointerType==='pen';var trackingData=this.trackingData(from.pointerId);var outTarget=this.findMountedTarget(trackingData.overTargets);// First pointerout/pointerleave\nif(trackingData.overTargets&&outTarget!==e.target){// pointerout always occurs on the overTarget when the pointer hovers over another element.\nvar outType=from.type==='mousemove'?'mouseout':'pointerout';var outEvent=this.createPointerEvent(from,outType,outTarget);this.dispatchEvent(outEvent,'pointerout');if(isMouse){this.dispatchEvent(outEvent,'mouseout');}// If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n// is dispatched to all ancestors that no longer capture the pointer.\nif(!e.composedPath().includes(outTarget)){var leaveEvent=this.createPointerEvent(from,'pointerleave',outTarget);leaveEvent.eventPhase=leaveEvent.AT_TARGET;while(leaveEvent.target&&!e.composedPath().includes(leaveEvent.target)){leaveEvent.currentTarget=leaveEvent.target;this.notifyTarget(leaveEvent);if(isMouse){this.notifyTarget(leaveEvent,'mouseleave');}leaveEvent.target=leaveEvent.target.parent;}this.freeEvent(leaveEvent);}this.freeEvent(outEvent);}// Then pointerover\nif(outTarget!==e.target){// pointerover always occurs on the new overTarget\nvar overType=from.type==='mousemove'?'mouseover':'pointerover';var overEvent=this.clonePointerEvent(e,overType);// clone faster\nthis.dispatchEvent(overEvent,'pointerover');if(isMouse){this.dispatchEvent(overEvent,'mouseover');}// Probe whether the newly hovered DisplayObject is an ancestor of the original overTarget.\nvar overTargetAncestor=outTarget===null||outTarget===void 0?void 0:outTarget.parent;while(overTargetAncestor&&overTargetAncestor!==this.rootTarget.parent){if(overTargetAncestor===e.target){break;}overTargetAncestor=overTargetAncestor.parent;}// The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n// event.\nvar didPointerEnter=!overTargetAncestor||overTargetAncestor===this.rootTarget.parent;if(didPointerEnter){var enterEvent=this.clonePointerEvent(e,'pointerenter');enterEvent.eventPhase=enterEvent.AT_TARGET;while(enterEvent.target&&enterEvent.target!==outTarget&&enterEvent.target!==this.rootTarget.parent){enterEvent.currentTarget=enterEvent.target;this.notifyTarget(enterEvent);if(isMouse){this.notifyTarget(enterEvent,'mouseenter');}enterEvent.target=enterEvent.target.parent;}this.freeEvent(enterEvent);}this.freeEvent(overEvent);}var propagationMethod=this.moveOnAll?'all':'dispatchEvent';// Then pointermove\nthis[propagationMethod](e,'pointermove');if(e.pointerType==='touch'){this[propagationMethod](e,'touchmove');}if(isMouse){this[propagationMethod](e,'mousemove');this.cursor=(_a=e.target)===null||_a===void 0?void 0:_a.cursor;}trackingData.overTargets=e.composedPath();this.freeEvent(e);};/**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     *\n     * @param from - The upstream `pointerover` event.\n     */EventBoundary.prototype.mapPointerOver=function(from){var _a;if(!(from instanceof FederatedPointerEvent)){console.warn('EventBoundary cannot map a non-pointer event as a pointer event');return;}var trackingData=this.trackingData(from.pointerId);var e=this.createPointerEvent(from);var isMouse=e.pointerType==='mouse'||e.pointerType==='pen';this.dispatchEvent(e,'pointerover');if(isMouse){this.dispatchEvent(e,'mouseover');}if(e.pointerType==='mouse'){this.cursor=(_a=e.target)===null||_a===void 0?void 0:_a.cursor;}// pointerenter events must be fired since the pointer entered from upstream.\nvar enterEvent=this.clonePointerEvent(e,'pointerenter');enterEvent.eventPhase=enterEvent.AT_TARGET;while(enterEvent.target&&enterEvent.target!==this.rootTarget.parent){enterEvent.currentTarget=enterEvent.target;this.notifyTarget(enterEvent);if(isMouse){this.notifyTarget(enterEvent,'mouseenter');}enterEvent.target=enterEvent.target.parent;}trackingData.overTargets=e.composedPath();this.freeEvent(e);this.freeEvent(enterEvent);};/**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     *\n     * @param from - The upstream `pointerout` event.\n     */EventBoundary.prototype.mapPointerOut=function(from){if(!(from instanceof FederatedPointerEvent)){console.warn('EventBoundary cannot map a non-pointer event as a pointer event');return;}var trackingData=this.trackingData(from.pointerId);if(trackingData.overTargets){var isMouse=from.pointerType==='mouse'||from.pointerType==='pen';var outTarget=this.findMountedTarget(trackingData.overTargets);// pointerout first\nvar outEvent=this.createPointerEvent(from,'pointerout',outTarget);this.dispatchEvent(outEvent);if(isMouse){this.dispatchEvent(outEvent,'mouseout');}// pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n// get an upstream pointerout event (upstream events do not know rootTarget has descendants).\nvar leaveEvent=this.createPointerEvent(from,'pointerleave',outTarget);leaveEvent.eventPhase=leaveEvent.AT_TARGET;while(leaveEvent.target&&leaveEvent.target!==this.rootTarget.parent){leaveEvent.currentTarget=leaveEvent.target;this.notifyTarget(leaveEvent);if(isMouse){this.notifyTarget(leaveEvent,'mouseleave');}leaveEvent.target=leaveEvent.target.parent;}trackingData.overTargets=null;this.freeEvent(outEvent);this.freeEvent(leaveEvent);}this.cursor=null;};/**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`, and `click`/`pointertap` events,\n     * in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     *\n     * @param from - The upstream `pointerup` event.\n     */EventBoundary.prototype.mapPointerUp=function(from){if(!(from instanceof FederatedPointerEvent)){console.warn('EventBoundary cannot map a non-pointer event as a pointer event');return;}var now=performance.now();var e=this.createPointerEvent(from);this.dispatchEvent(e,'pointerup');if(e.pointerType==='touch'){this.dispatchEvent(e,'touchend');}else if(e.pointerType==='mouse'||e.pointerType==='pen'){var isRightButton=e.button===2;this.dispatchEvent(e,isRightButton?'rightup':'mouseup');}var trackingData=this.trackingData(from.pointerId);var pressTarget=this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);var clickTarget=pressTarget;// pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n// the pointerup location.\nif(pressTarget&&!e.composedPath().includes(pressTarget)){var currentTarget=pressTarget;while(currentTarget&&!e.composedPath().includes(currentTarget)){e.currentTarget=currentTarget;this.notifyTarget(e,'pointerupoutside');if(e.pointerType==='touch'){this.notifyTarget(e,'touchendoutside');}else if(e.pointerType==='mouse'||e.pointerType==='pen'){var isRightButton=e.button===2;this.notifyTarget(e,isRightButton?'rightupoutside':'mouseupoutside');}currentTarget=currentTarget.parent;}delete trackingData.pressTargetsByButton[from.button];// currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n// targets. That is - it's our click target!\nclickTarget=currentTarget;}// click!\nif(clickTarget){var clickEvent=this.clonePointerEvent(e,'click');clickEvent.target=clickTarget;clickEvent.path=null;if(!trackingData.clicksByButton[from.button]){trackingData.clicksByButton[from.button]={clickCount:0,target:clickEvent.target,timeStamp:now};}var clickHistory=trackingData.clicksByButton[from.button];if(clickHistory.target===clickEvent.target&&now-clickHistory.timeStamp<200){++clickHistory.clickCount;}else{clickHistory.clickCount=1;}clickHistory.target=clickEvent.target;clickHistory.timeStamp=now;clickEvent.detail=clickHistory.clickCount;if(clickEvent.pointerType==='mouse'){this.dispatchEvent(clickEvent,'click');}else if(clickEvent.pointerType==='touch'){this.dispatchEvent(clickEvent,'tap');}else{this.dispatchEvent(clickEvent,'pointertap');}this.freeEvent(clickEvent);}this.freeEvent(e);};/**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the {@code EventBoundary}'s\n     * root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     *\n     * @param from - The upstream `pointerupoutside` event.\n     */EventBoundary.prototype.mapPointerUpOutside=function(from){if(!(from instanceof FederatedPointerEvent)){console.warn('EventBoundary cannot map a non-pointer event as a pointer event');return;}var trackingData=this.trackingData(from.pointerId);var pressTarget=this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);var e=this.createPointerEvent(from);if(pressTarget){var currentTarget=pressTarget;while(currentTarget){e.currentTarget=currentTarget;this.notifyTarget(e,'pointerupoutside');if(e.pointerType==='touch'){this.notifyTarget(e,'touchendoutside');}else if(e.pointerType==='mouse'||e.pointerType==='pen'){this.notifyTarget(e,e.button===2?'rightupoutside':'mouseupoutside');}currentTarget=currentTarget.parent;}delete trackingData.pressTargetsByButton[from.button];}this.freeEvent(e);};/**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     *\n     * @param from - The upstream `wheel` event.\n     */EventBoundary.prototype.mapWheel=function(from){if(!(from instanceof FederatedWheelEvent)){console.warn('EventBoundary cannot map a non-wheel event as a wheel event');return;}var wheelEvent=this.createWheelEvent(from);this.dispatchEvent(wheelEvent);this.freeEvent(wheelEvent);};/**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     *\n     * @param propagationPath - The propagation path was valid in the past.\n     * @return - The most specific event-target still mounted at the same location in the scene graph.\n     */EventBoundary.prototype.findMountedTarget=function(propagationPath){if(!propagationPath){return null;}var currentTarget=propagationPath[0];for(var i=1;i<propagationPath.length;i++){// Set currentTarget to the next target in the path only if it is still attached to the\n// scene graph (i.e. parent still points to the expected ancestor).\nif(propagationPath[i].parent===currentTarget){currentTarget=propagationPath[i];}else{break;}}return currentTarget;};/**\n     * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n     *\n     * @param from - The {@code originalEvent} for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */EventBoundary.prototype.createPointerEvent=function(from,type,target){var event=this.allocateEvent(FederatedPointerEvent);this.copyPointerData(from,event);this.copyMouseData(from,event);this.copyData(from,event);event.nativeEvent=from.nativeEvent;event.originalEvent=from;event.target=target!==null&&target!==void 0?target:this.hitTest(event.global.x,event.global.y);if(typeof type==='string'){event.type=type;}return event;};/**\n     * Creates a wheel event whose {@code originalEvent} is {@code from}.\n     *\n     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n     *\n     * @param from - The upstream wheel event.\n     */EventBoundary.prototype.createWheelEvent=function(from){var event=this.allocateEvent(FederatedWheelEvent);this.copyWheelData(from,event);this.copyMouseData(from,event);this.copyData(from,event);event.nativeEvent=from.nativeEvent;event.originalEvent=from;event.target=this.hitTest(event.global.x,event.global.y);return event;};/**\n     * Clones the event {@code from}, with an optional {@code type} override.\n     *\n     * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n     *\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */EventBoundary.prototype.clonePointerEvent=function(from,type){var event=this.allocateEvent(FederatedPointerEvent);event.nativeEvent=from.nativeEvent;event.originalEvent=from.originalEvent;this.copyPointerData(from,event);this.copyMouseData(from,event);this.copyData(from,event);// copy propagation path for perf\nevent.target=from.target;event.path=from.composedPath().slice();event.type=type!==null&&type!==void 0?type:event.type;return event;};/**\n     * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     *\n     * @param from\n     * @param to\n     */EventBoundary.prototype.copyWheelData=function(from,to){to.deltaMode=from.deltaMode;to.deltaX=from.deltaX;to.deltaY=from.deltaY;to.deltaZ=from.deltaZ;};/**\n     * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     *\n     * @param from\n     * @param to\n     */EventBoundary.prototype.copyPointerData=function(from,to){if(!(from instanceof FederatedPointerEvent&&to instanceof FederatedPointerEvent)){return;}to.pointerId=from.pointerId;to.width=from.width;to.height=from.height;to.isPrimary=from.isPrimary;to.pointerType=from.pointerType;to.pressure=from.pressure;to.tangentialPressure=from.tangentialPressure;to.tiltX=from.tiltX;to.tiltY=from.tiltY;to.twist=from.twist;};/**\n     * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + global\n     *\n     * @param from\n     * @param to\n     */EventBoundary.prototype.copyMouseData=function(from,to){if(!(from instanceof FederatedMouseEvent&&to instanceof FederatedMouseEvent)){return;}to.altKey=from.altKey;to.button=from.button;to.buttons=from.buttons;to.client.copyFrom(from.client);to.ctrlKey=from.ctrlKey;to.metaKey=from.metaKey;to.movement.copyFrom(from.movement);to.screen.copyFrom(from.screen);to.global.copyFrom(from.global);};/**\n     * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     *\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */EventBoundary.prototype.copyData=function(from,to){to.isTrusted=from.isTrusted;to.srcElement=from.srcElement;to.timeStamp=performance.now();to.type=from.type;to.detail=from.detail;to.view=from.view;to.which=from.which;to.layer.copyFrom(from.layer);to.page.copyFrom(from.page);};/**\n     * @param id - The pointer ID.\n     * @return The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */EventBoundary.prototype.trackingData=function(id){if(!this.mappingState.trackingData[id]){this.mappingState.trackingData[id]={pressTargetsByButton:{},clicksByButton:{},overTarget:null};}return this.mappingState.trackingData[id];};/**\n     * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     *\n     * @param constructor - The event's constructor.\n     */EventBoundary.prototype.allocateEvent=function(constructor){if(!this.eventPool.has(constructor)){this.eventPool.set(constructor,[]);}var event=this.eventPool.get(constructor).pop()||new constructor(this);event.eventPhase=event.NONE;event.currentTarget=null;event.path=null;event.target=null;return event;};/**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     *\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */EventBoundary.prototype.freeEvent=function(event){if(event.manager!==this){throw new Error('It is illegal to free an event not managed by this EventBoundary!');}var constructor=event.constructor;if(!this.eventPool.has(constructor)){this.eventPool.set(constructor,[]);}this.eventPool.get(constructor).push(event);};/**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     *\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */EventBoundary.prototype.notifyListeners=function(e,type){var listeners=e.currentTarget._events[type];if(!listeners){return;}if('fn'in listeners){listeners.fn.call(listeners.context,e);}else{for(var i=0,j=listeners.length;i<j&&!e.propagationImmediatelyStopped;i++){listeners[i].fn.call(listeners[i].context,e);}}};return EventBoundary;}();/**\n * Fired when a mouse button (usually a mouse left-button) is pressed on the display.\n * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mousedown\n * @param {PIXI.FederatedPointerEvent} event - The mousedown event.\n */ /**\n * Capture phase equivalent of {@code mousedown}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mousedowncapture\n * @param {PIXI.FederatedPointerEvent} event - The capture phase mousedown.\n */ /**\n * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#rightdown\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code rightdown}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#rightdowncapture\n * @param {PIXI.FederatedPointerEvent} event - The rightdowncapture event.\n */ /**\n * Fired when a pointer device button (usually a mouse left-button) is released over the display\n * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseup\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code mouseup}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseupcature\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device secondary button (usually a mouse right-button) is released\n * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#rightup\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code rightup}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#rightupcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * A {@code click} event fires after the {@code pointerdown} and {@code pointerup} events, in that\n * order. If the mouse is moved over another DisplayObject after the {@code pointerdown} event, the\n * {@code click} event is fired on the most specific common ancestor of the two target DisplayObjects.\n *\n * The {@code detail} property of the event is the number of clicks that occurred within a 200ms\n * window of each other upto the current click. For example, it will be {@code 2} for a double click.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#click\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code click}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#clickcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This event follows the semantics of {@code click}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#rightclick\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code rightclick}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#rightclickcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device button (usually a mouse left-button) is released outside the\n * display object that initially registered a\n * [mousedown]{@link PIXI.DisplayObject#event:mousedown}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This event is specific to the Federated Events API. It does not have a capture phase, unlike most of the\n * other events. It only bubbles to the most specific ancestor of the targets of the corresponding {@code pointerdown}\n * and {@code pointerup} events, i.e. the target of the {@code click} event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseupoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code mouseupoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseupoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device secondary button (usually a mouse right-button) is released\n * outside the display object that initially registered a\n * [rightdown]{@link PIXI.DisplayObject#event:rightdown}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#rightupoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code rightupoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#rightupoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device (usually a mouse) is moved while over the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mousemove\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code mousemove}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mousemovecature\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device (usually a mouse) is moved onto the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseover\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code mouseover}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseovercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when the mouse pointer is moved over a DisplayObject and its descendant's hit testing boundaries.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseenter\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code mouseenter}\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseentercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device (usually a mouse) is moved off the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This may be fired on a DisplayObject that was removed from the scene graph immediately after\n * a {@code mouseover} event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseout\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code mouseout}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseoutcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when the mouse pointer exits a DisplayObject and its descendants.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseleave\n * @param {PIXI.FederatedPointerEvent} event\n */ /**\n * Capture phase equivalent of {@code mouseleave}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#mouseleavecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device button is pressed on the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerdown\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code pointerdown}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerdowncapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device button is released over the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerup\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code pointerup}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerupcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when the operating system cancels a pointer event.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointercancel\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code pointercancel}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointercancelcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device button is pressed and released on the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointertap\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code pointertap}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointertapcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device button is released outside the display object that initially\n * registered a [pointerdown]{@link PIXI.DisplayObject#event:pointerdown}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * This event is specific to the Federated Events API. It does not have a capture phase, unlike most of the\n * other events. It only bubbles to the most specific ancestor of the targets of the corresponding {@code pointerdown}\n * and {@code pointerup} events, i.e. the target of the {@code click} event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerupoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code pointerupoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerupoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device is moved while over the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointermove\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code pointermove}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointermovecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device is moved onto the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerover\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code pointerover}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerovercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when the pointer is moved over a DisplayObject and its descendant's hit testing boundaries.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerenter\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code pointerenter}\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerentercapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a pointer device is moved off the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerout\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code pointerout}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointeroutcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when the pointer leaves the hit testing boundaries of a DisplayObject and its descendants.\n *\n * This event notifies only the target and does not bubble.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerleave\n * @param {PIXI.FederatedPointerEvent} event - The `pointerleave` event.\n */ /**\n * Capture phase equivalent of {@code pointerleave}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#pointerleavecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a touch point is placed on the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchstart\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code touchstart}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchstartcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a touch point is removed from the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchend\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code touchend}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchendcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when the operating system cancels a touch.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchcancel\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code touchcancel}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchcancelcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a touch point is placed and removed from the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#tap\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code tap}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#tapcapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a touch point is removed outside of the display object that initially\n * registered a [touchstart]{@link PIXI.DisplayObject#event:touchstart}.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchendoutside\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code touchendoutside}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchendoutsidecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a touch point is moved along the display object.\n * DisplayObject's `interactive` property must be set to `true` to fire event.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchmove\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Capture phase equivalent of {@code touchmove}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#touchmovecapture\n * @param {PIXI.FederatedPointerEvent} event - Event\n */ /**\n * Fired when a the user scrolls with the mouse cursor over a DisplayObject.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#wheel\n * @type {PIXI.FederatedWheelEvent}\n */ /**\n * Capture phase equivalent of {@code wheel}.\n *\n * These events are propagating from the {@link PIXI.EventSystem EventSystem} in @pixi/events.\n *\n * @event PIXI.DisplayObject#wheelcapture\n * @type {PIXI.FederatedWheelEvent}\n */var MOUSE_POINTER_ID=1;var TOUCH_TO_POINTER={touchstart:'pointerdown',touchend:'pointerup',touchendoutside:'pointerupoutside',touchmove:'pointermove',touchcancel:'pointercancel'};/**\n * The system for handling UI events.\n *\n * @memberof PIXI\n */var EventSystem=/** @class */function(){/**\n     * @param {PIXI.Renderer} renderer\n     */function EventSystem(renderer){/**\n         * Does the device support touch events\n         * https://www.w3.org/TR/touch-events/\n         */this.supportsTouchEvents='ontouchstart'in globalThis;/**\n         * Does the device support pointer events\n         * https://www.w3.org/Submission/pointer-events/\n         */this.supportsPointerEvents=!!globalThis.PointerEvent;/**\n         * The resolution used to convert between the DOM client space into world space.\n         */this.resolution=1;if(renderer.plugins.interaction){throw new Error('EventSystem cannot initialize with the InteractionManager installed!');}this.renderer=renderer;this.rootBoundary=new EventBoundary(null);this.autoPreventDefault=true;this.eventsAdded=false;this.rootPointerEvent=new FederatedPointerEvent(null);this.rootWheelEvent=new FederatedWheelEvent(null);this.cursorStyles={default:'inherit',pointer:'pointer'};this.domElement=renderer.view;this.onPointerDown=this.onPointerDown.bind(this);this.onPointerMove=this.onPointerMove.bind(this);this.onPointerUp=this.onPointerUp.bind(this);this.onPointerOverOut=this.onPointerOverOut.bind(this);this.onWheel=this.onWheel.bind(this);this.setTargetElement(this.domElement);this.resolution=this.renderer.resolution;}/**\n     * Destroys all event listeners and detaches the renderer.\n     */EventSystem.prototype.destroy=function(){this.setTargetElement(null);this.renderer=null;};/**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     *\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */EventSystem.prototype.setCursor=function(mode){mode=mode||'default';var applyStyles=true;// offscreen canvas does not support setting styles, but cursor modes can be functions,\n// in order to handle pixi rendered cursors, so we can't bail\nif(globalThis.OffscreenCanvas&&this.domElement instanceof OffscreenCanvas){applyStyles=false;}// if the mode didn't actually change, bail early\nif(this.currentCursor===mode){return;}this.currentCursor=mode;var style=this.cursorStyles[mode];// only do things if there is a cursor style for it\nif(style){switch(typeof style){case'string':// string styles are handled as cursor CSS\nif(applyStyles){this.domElement.style.cursor=style;}break;case'function':// functions are just called, and passed the cursor mode\nstyle(mode);break;case'object':// if it is an object, assume that it is a dictionary of CSS styles,\n// apply it to the interactionDOMElement\nif(applyStyles){Object.assign(this.domElement.style,style);}break;}}else if(applyStyles&&typeof mode==='string'&&!Object.prototype.hasOwnProperty.call(this.cursorStyles,mode)){// if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n// for the mode, then assume that the dev wants it to be CSS for the cursor.\nthis.domElement.style.cursor=mode;}};/**\n     * Event handler for pointer down events on {@link PIXI.EventSystem#domElement this.domElement}.\n     *\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */EventSystem.prototype.onPointerDown=function(nativeEvent){this.rootBoundary.rootTarget=this.renderer._lastObjectRendered;// if we support touch events, then only use those for touch events, not pointer events\nif(this.supportsTouchEvents&&nativeEvent.pointerType==='touch'){return;}var events=this.normalizeToPointerData(nativeEvent);/*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */ // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\nif(this.autoPreventDefault&&events[0].isNormalized){var cancelable=nativeEvent.cancelable||!('cancelable'in nativeEvent);if(cancelable){nativeEvent.preventDefault();}}for(var i=0,j=events.length;i<j;i++){var nativeEvent_1=events[i];var federatedEvent=this.bootstrapEvent(this.rootPointerEvent,nativeEvent_1);this.rootBoundary.mapEvent(federatedEvent);}this.setCursor(this.rootBoundary.cursor);};/**\n     * Event handler for pointer move events on on {@link PIXI.EventSystem#domElement this.domElement}.\n     *\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */EventSystem.prototype.onPointerMove=function(nativeEvent){this.rootBoundary.rootTarget=this.renderer._lastObjectRendered;// if we support touch events, then only use those for touch events, not pointer events\nif(this.supportsTouchEvents&&nativeEvent.pointerType==='touch'){return;}var normalizedEvents=this.normalizeToPointerData(nativeEvent);for(var i=0,j=normalizedEvents.length;i<j;i++){var event=this.bootstrapEvent(this.rootPointerEvent,normalizedEvents[i]);this.rootBoundary.mapEvent(event);}this.setCursor(this.rootBoundary.cursor);};/**\n     * Event handler for pointer up events on {@link PIXI.EventSystem#domElement this.domElement}.\n     *\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */EventSystem.prototype.onPointerUp=function(nativeEvent){this.rootBoundary.rootTarget=this.renderer._lastObjectRendered;// if we support touch events, then only use those for touch events, not pointer events\nif(this.supportsTouchEvents&&nativeEvent.pointerType==='touch'){return;}var outside=nativeEvent.target!==this.domElement?'outside':'';var normalizedEvents=this.normalizeToPointerData(nativeEvent);for(var i=0,j=normalizedEvents.length;i<j;i++){var event=this.bootstrapEvent(this.rootPointerEvent,normalizedEvents[i]);event.type+=outside;this.rootBoundary.mapEvent(event);}this.setCursor(this.rootBoundary.cursor);};/**\n     * Event handler for pointer over & out events on {@link PIXI.EventSystem#domElement this.domElement}.\n     *\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */EventSystem.prototype.onPointerOverOut=function(nativeEvent){this.rootBoundary.rootTarget=this.renderer._lastObjectRendered;// if we support touch events, then only use those for touch events, not pointer events\nif(this.supportsTouchEvents&&nativeEvent.pointerType==='touch'){return;}var normalizedEvents=this.normalizeToPointerData(nativeEvent);for(var i=0,j=normalizedEvents.length;i<j;i++){var event=this.bootstrapEvent(this.rootPointerEvent,normalizedEvents[i]);this.rootBoundary.mapEvent(event);}this.setCursor(this.rootBoundary.cursor);};/**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     *\n     * @param nativeEvent - The native wheel event.\n     */EventSystem.prototype.onWheel=function(nativeEvent){var wheelEvent=this.normalizeWheelEvent(nativeEvent);this.rootBoundary.rootTarget=this.renderer._lastObjectRendered;this.rootBoundary.mapEvent(wheelEvent);};/**\n     * Sets the {@link PIXI.EventSystem#domElement domElement} and binds event listeners.\n     *\n     * To deregister the current DOM element without setting a new one, pass {@code null}.\n     *\n     * @param element - The new DOM element.\n     */EventSystem.prototype.setTargetElement=function(element){this.removeEvents();this.domElement=element;this.addEvents();};/**\n     * Register event listeners on {@link PIXI.Renderer#domElement this.domElement}.\n     */EventSystem.prototype.addEvents=function(){if(this.eventsAdded||!this.domElement){return;}var style=this.domElement.style;if(globalThis.navigator.msPointerEnabled){style.msContentZooming='none';style.msTouchAction='none';}else if(this.supportsPointerEvents){style.touchAction='none';}/*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */if(this.supportsPointerEvents){globalThis.document.addEventListener('pointermove',this.onPointerMove,true);this.domElement.addEventListener('pointerdown',this.onPointerDown,true);// pointerout is fired in addition to pointerup (for touch events) and pointercancel\n// we already handle those, so for the purposes of what we do in onPointerOut, we only\n// care about the pointerleave event\nthis.domElement.addEventListener('pointerleave',this.onPointerOverOut,true);this.domElement.addEventListener('pointerover',this.onPointerOverOut,true);// globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\nglobalThis.addEventListener('pointerup',this.onPointerUp,true);}else{globalThis.document.addEventListener('mousemove',this.onPointerMove,true);this.domElement.addEventListener('mousedown',this.onPointerDown,true);this.domElement.addEventListener('mouseout',this.onPointerOverOut,true);this.domElement.addEventListener('mouseover',this.onPointerOverOut,true);globalThis.addEventListener('mouseup',this.onPointerUp,true);}// Always look directly for touch events so that we can provide original data\n// In a future version we should change this to being just a fallback and rely solely on\n// PointerEvents whenever available\nif(this.supportsTouchEvents){this.domElement.addEventListener('touchstart',this.onPointerDown,true);// this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\nthis.domElement.addEventListener('touchend',this.onPointerUp,true);this.domElement.addEventListener('touchmove',this.onPointerMove,true);}this.domElement.addEventListener('wheel',this.onWheel,{passive:true,capture:true});this.eventsAdded=true;};/**\n     * Unregister event listeners on {@link PIXI.EventSystem#domElement this.domElement}.\n     */EventSystem.prototype.removeEvents=function(){if(!this.eventsAdded||!this.domElement){return;}var style=this.domElement.style;if(globalThis.navigator.msPointerEnabled){style.msContentZooming='';style.msTouchAction='';}else if(this.supportsPointerEvents){style.touchAction='';}if(this.supportsPointerEvents){globalThis.document.removeEventListener('pointermove',this.onPointerMove,true);this.domElement.removeEventListener('pointerdown',this.onPointerDown,true);this.domElement.removeEventListener('pointerleave',this.onPointerOverOut,true);this.domElement.removeEventListener('pointerover',this.onPointerOverOut,true);// globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\nglobalThis.removeEventListener('pointerup',this.onPointerUp,true);}else{globalThis.document.removeEventListener('mousemove',this.onPointerMove,true);this.domElement.removeEventListener('mousedown',this.onPointerDown,true);this.domElement.removeEventListener('mouseout',this.onPointerOverOut,true);this.domElement.removeEventListener('mouseover',this.onPointerOverOut,true);globalThis.removeEventListener('mouseup',this.onPointerUp,true);}if(this.supportsTouchEvents){this.domElement.removeEventListener('touchstart',this.onPointerDown,true);// this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\nthis.domElement.removeEventListener('touchend',this.onPointerUp,true);this.domElement.removeEventListener('touchmove',this.onPointerMove,true);}this.domElement.removeEventListener('wheel',this.onWheel,true);this.domElement=null;this.eventsAdded=false;};/**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     *\n     * @param  {PIXI.IPointData} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */EventSystem.prototype.mapPositionToPoint=function(point,x,y){var rect;// IE 11 fix\nif(!this.domElement.parentElement){rect={x:0,y:0,width:this.domElement.width,height:this.domElement.height,left:0,top:0};}else{rect=this.domElement.getBoundingClientRect();}var resolutionMultiplier=1.0/this.resolution;point.x=(x-rect.left)*(this.domElement.width/rect.width)*resolutionMultiplier;point.y=(y-rect.top)*(this.domElement.height/rect.height)*resolutionMultiplier;};/**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     *\n     * @param event - The original event data from a touch or mouse event\n     * @return An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */EventSystem.prototype.normalizeToPointerData=function(event){var normalizedEvents=[];if(this.supportsTouchEvents&&event instanceof TouchEvent){for(var i=0,li=event.changedTouches.length;i<li;i++){var touch=event.changedTouches[i];if(typeof touch.button==='undefined'){touch.button=event.touches.length?1:0;}if(typeof touch.buttons==='undefined'){touch.buttons=event.touches.length?1:0;}if(typeof touch.isPrimary==='undefined'){touch.isPrimary=event.touches.length===1&&event.type==='touchstart';}if(typeof touch.width==='undefined'){touch.width=touch.radiusX||1;}if(typeof touch.height==='undefined'){touch.height=touch.radiusY||1;}if(typeof touch.tiltX==='undefined'){touch.tiltX=0;}if(typeof touch.tiltY==='undefined'){touch.tiltY=0;}if(typeof touch.pointerType==='undefined'){touch.pointerType='touch';}if(typeof touch.pointerId==='undefined'){touch.pointerId=touch.identifier||0;}if(typeof touch.pressure==='undefined'){touch.pressure=touch.force||0.5;}if(typeof touch.twist==='undefined'){touch.twist=0;}if(typeof touch.tangentialPressure==='undefined'){touch.tangentialPressure=0;}// TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n// support, and the fill ins are not quite the same\n// offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n// left is not 0,0 on the page\nif(typeof touch.layerX==='undefined'){touch.layerX=touch.offsetX=touch.clientX;}if(typeof touch.layerY==='undefined'){touch.layerY=touch.offsetY=touch.clientY;}// mark the touch as normalized, just so that we know we did it\ntouch.isNormalized=true;touch.type=event.type;normalizedEvents.push(touch);}}// apparently PointerEvent subclasses MouseEvent, so yay\nelse if(!globalThis.MouseEvent||event instanceof MouseEvent&&(!this.supportsPointerEvents||!(event instanceof globalThis.PointerEvent))){var tempEvent=event;if(typeof tempEvent.isPrimary==='undefined'){tempEvent.isPrimary=true;}if(typeof tempEvent.width==='undefined'){tempEvent.width=1;}if(typeof tempEvent.height==='undefined'){tempEvent.height=1;}if(typeof tempEvent.tiltX==='undefined'){tempEvent.tiltX=0;}if(typeof tempEvent.tiltY==='undefined'){tempEvent.tiltY=0;}if(typeof tempEvent.pointerType==='undefined'){tempEvent.pointerType='mouse';}if(typeof tempEvent.pointerId==='undefined'){tempEvent.pointerId=MOUSE_POINTER_ID;}if(typeof tempEvent.pressure==='undefined'){tempEvent.pressure=0.5;}if(typeof tempEvent.twist==='undefined'){tempEvent.twist=0;}if(typeof tempEvent.tangentialPressure==='undefined'){tempEvent.tangentialPressure=0;}// mark the mouse event as normalized, just so that we know we did it\ntempEvent.isNormalized=true;normalizedEvents.push(tempEvent);}else{normalizedEvents.push(event);}return normalizedEvents;};/**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link PIXI.FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     *\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @return A federated wheel event.\n     */EventSystem.prototype.normalizeWheelEvent=function(nativeEvent){var event=this.rootWheelEvent;this.transferMouseData(event,nativeEvent);event.deltaMode=nativeEvent.deltaMode;event.deltaX=nativeEvent.deltaX;event.deltaY=nativeEvent.deltaY;event.deltaZ=nativeEvent.deltaZ;this.mapPositionToPoint(event.screen,nativeEvent.clientX,nativeEvent.clientY);event.global.copyFrom(event.screen);event.offset.copyFrom(event.screen);event.nativeEvent=nativeEvent;event.type=nativeEvent.type;return event;};/**\n     * Normalizes the {@code nativeEvent} into a federateed {@code FederatedPointerEvent}.\n     *\n     * @param event\n     * @param nativeEvent\n     */EventSystem.prototype.bootstrapEvent=function(event,nativeEvent){event.originalEvent=null;event.nativeEvent=nativeEvent;event.pointerId=nativeEvent.pointerId;event.width=nativeEvent.width;event.height=nativeEvent.height;event.isPrimary=nativeEvent.isPrimary;event.pointerType=nativeEvent.pointerType;event.pressure=nativeEvent.pressure;event.tangentialPressure=nativeEvent.tangentialPressure;event.tiltX=nativeEvent.tiltX;event.tiltY=nativeEvent.tiltY;event.twist=nativeEvent.twist;this.transferMouseData(event,nativeEvent);this.mapPositionToPoint(event.screen,nativeEvent.clientX,nativeEvent.clientY);event.global.copyFrom(event.screen);// global = screen for top-level\nevent.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\nevent.isTrusted=nativeEvent.isTrusted;if(event.type==='pointerleave'){event.type='pointerout';}if(event.type.startsWith('mouse')){event.type=event.type.replace('mouse','pointer');}if(event.type.startsWith('touch')){event.type=TOUCH_TO_POINTER[event.type]||event.type;}return event;};/**\n     * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n     *\n     * @param event\n     * @param nativeEvent\n     */EventSystem.prototype.transferMouseData=function(event,nativeEvent){event.isTrusted=nativeEvent.isTrusted;event.srcElement=nativeEvent.srcElement;event.timeStamp=performance.now();event.type=nativeEvent.type;event.altKey=nativeEvent.altKey;event.button=nativeEvent.button;event.buttons=nativeEvent.buttons;event.client.x=nativeEvent.clientX;event.client.y=nativeEvent.clientY;event.ctrlKey=nativeEvent.ctrlKey;event.metaKey=nativeEvent.metaKey;event.movement.x=nativeEvent.movementX;event.movement.y=nativeEvent.movementY;event.page.x=nativeEvent.pageX;event.page.y=nativeEvent.pageY;event.relatedTarget=null;};return EventSystem;}();var FederatedDisplayObject={/**\n     * Enable interaction events for the DisplayObject. Touch, pointer and mouse\n     * events will not be emitted unless `interactive` is set to `true`.\n     *\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.on('tap', (event) => {\n     *    //handle event\n     * });\n     * @memberof PIXI.DisplayObject#\n     */interactive:false,/**\n     * Determines if the children to the displayObject can be clicked/touched\n     * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n     *\n     * @memberof PIXI.Container#\n     */interactiveChildren:true,/**\n     * Interaction shape. Children will be hit first, then this shape will be checked.\n     * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.\n     *\n     * @example\n     * const sprite = new PIXI.Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);\n     * @member {PIXI.IHitArea}\n     * @memberof PIXI.DisplayObject#\n     */hitArea:null,/**\n     * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n     * seeks to be compatible with the DOM's `addEventListener` with support for options.\n     * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.\n     * @memberof PIXI.DisplayObject\n     * @param type - The type of event to listen to.\n     * @param listener - The listener callback or object.\n     * @param options - Listener options, used for capture phase.\n     * @example\n     * // Tell the user whether they did a single, double, triple, or nth click.\n     * button.addEventListener('click', {\n     *   handleEvent(e): {\n     *     let prefix;\n     *\n     *     switch (e.detail) {\n     *       case 1: prefix = 'single'; break;\n     *       case 2: prefix = 'double'; break;\n     *       case 3: prefix = 'triple'; break;\n     *       default: prefix = e.detail + 'th'; break;\n     *     }\n     *\n     *     console.log('That was a ' + prefix + 'click');\n     *   }\n     * });\n     *\n     * // But skip the first click!\n     * button.parent.addEventListener('click', function blockClickOnce(e) {\n     *   e.stopImmediatePropagation();\n     *   button.parent.removeEventListener('click', blockClickOnce, true);\n     * }, {\n     *   capture: true,\n     * })\n     */addEventListener:function addEventListener(type,listener,options){var capture=typeof options==='boolean'&&options||typeof options==='object'&&options.capture;var context=typeof listener==='function'?undefined:listener;type=capture?type+\"capture\":type;listener=typeof listener==='function'?listener:listener.handleEvent;this.on(type,listener,context);},/**\n     * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n     * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n     * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.\n     * @memberof PIXI.DisplayObject\n     * @param type - The type of event the listener is bound to.\n     * @param listener - The listener callback or object.\n     * @param options - The original listener options. This is required to deregister a capture phase listener.\n     */removeEventListener:function removeEventListener(type,listener,options){var capture=typeof options==='boolean'&&options||typeof options==='object'&&options.capture;var context=typeof listener==='function'?undefined:listener;type=capture?type+\"capture\":type;listener=typeof listener==='function'?listener:listener.handleEvent;this.off(type,listener,context);},/**\n     * Dispatch the event on this {@link PIXI.DisplayObject} using the event's {@link PIXI.EventBoundary}.\n     *\n     * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n     *\n     * **IMPORTANT:** _Only_ available if using the `@pixi/events` package.\n     * @memberof PIXI.DisplayObject\n     * @param e - The event to dispatch.\n     * @return Whether the {@link PIXI.FederatedEvent.preventDefault preventDefault}() method was not invoked.\n     * @example\n     * // Reuse a click event!\n     * button.dispatchEvent(clickEvent);\n     */dispatchEvent:function dispatchEvent(e){if(!(e instanceof FederatedEvent)){throw new Error('DisplayObject cannot propagate events outside of the Federated Events API');}e.defaultPrevented=false;e.path=null;e.target=this;e.manager.dispatchEvent(e);return!e.defaultPrevented;}};DisplayObject.mixin(FederatedDisplayObject);export{EventBoundary,EventSystem,FederatedDisplayObject,FederatedEvent,FederatedMouseEvent,FederatedPointerEvent,FederatedWheelEvent};","map":null,"metadata":{},"sourceType":"module"}