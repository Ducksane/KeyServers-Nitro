(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tsparticles-engine"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Grabber = exports.drawGrabLine = void 0;
    const tsparticles_engine_1 = require("tsparticles-engine");
    function drawGrabLine(context, width, begin, end, colorLine, opacity) {
        context.save();
        (0, tsparticles_engine_1.drawLine)(context, begin, end);
        context.strokeStyle = (0, tsparticles_engine_1.getStyleFromRgb)(colorLine, opacity);
        context.lineWidth = width;
        context.stroke();
        context.restore();
    }
    exports.drawGrabLine = drawGrabLine;
    function drawGrab(container, particle, lineColor, opacity, mousePos) {
        container.canvas.draw((ctx) => {
            var _a;
            const beginPos = particle.getPosition();
            drawGrabLine(ctx, (_a = particle.retina.linksWidth) !== null && _a !== void 0 ? _a : container.retina.linksWidth, beginPos, mousePos, lineColor, opacity);
        });
    }
    class Grabber extends tsparticles_engine_1.ExternalInteractorBase {
        constructor(container) {
            super(container);
        }
        clear() {
        }
        init() {
        }
        async interact() {
            var _a;
            const container = this.container, options = container.actualOptions, interactivity = options.interactivity;
            if (!interactivity.events.onHover.enable || container.interactivity.status !== tsparticles_engine_1.mouseMoveEvent) {
                return;
            }
            const mousePos = container.interactivity.mouse.position;
            if (!mousePos) {
                return;
            }
            const distance = container.retina.grabModeDistance, query = container.particles.quadTree.queryCircle(mousePos, distance, (p) => this.isEnabled(p));
            for (const particle of query) {
                const pos = particle.getPosition(), pointDistance = (0, tsparticles_engine_1.getDistance)(pos, mousePos);
                if (pointDistance > distance) {
                    continue;
                }
                const grabLineOptions = interactivity.modes.grab.links, lineOpacity = grabLineOptions.opacity, opacityLine = lineOpacity - (pointDistance * lineOpacity) / distance;
                if (opacityLine <= 0) {
                    continue;
                }
                const optColor = (_a = grabLineOptions.color) !== null && _a !== void 0 ? _a : particle.options.links.color;
                if (!container.particles.grabLineColor) {
                    const linksOptions = options.interactivity.modes.grab.links;
                    container.particles.grabLineColor = (0, tsparticles_engine_1.getLinkRandomColor)(optColor, linksOptions.blink, linksOptions.consent);
                }
                const colorLine = (0, tsparticles_engine_1.getLinkColor)(particle, undefined, container.particles.grabLineColor);
                if (!colorLine) {
                    return;
                }
                drawGrab(container, particle, colorLine, opacityLine, mousePos);
            }
        }
        isEnabled(particle) {
            var _a;
            const container = this.container, mouse = container.interactivity.mouse, events = ((_a = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _a !== void 0 ? _a : container.actualOptions.interactivity).events;
            return events.onHover.enable && !!mouse.position && (0, tsparticles_engine_1.isInArray)("grab", events.onHover.mode);
        }
        reset() {
        }
    }
    exports.Grabber = Grabber;
});
